
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <Reset_Handler>:
 80001c0:	b672      	cpsid	i
 80001c2:	4822      	ldr	r0, [pc, #136]	; (800024c <endfiniloop+0x4>)
 80001c4:	f380 8809 	msr	PSP, r0
 80001c8:	2002      	movs	r0, #2
 80001ca:	f380 8814 	msr	CONTROL, r0
 80001ce:	f3bf 8f6f 	isb	sy
 80001d2:	f004 ffd5 	bl	8005180 <__core_init>
 80001d6:	f001 f953 	bl	8001480 <__early_init>
 80001da:	481d      	ldr	r0, [pc, #116]	; (8000250 <endfiniloop+0x8>)
 80001dc:	491d      	ldr	r1, [pc, #116]	; (8000254 <endfiniloop+0xc>)
 80001de:	4a1e      	ldr	r2, [pc, #120]	; (8000258 <endfiniloop+0x10>)

080001e0 <msloop>:
 80001e0:	4291      	cmp	r1, r2
 80001e2:	bf3c      	itt	cc
 80001e4:	f841 0b04 	strcc.w	r0, [r1], #4
 80001e8:	e7fa      	bcc.n	80001e0 <msloop>
 80001ea:	491c      	ldr	r1, [pc, #112]	; (800025c <endfiniloop+0x14>)
 80001ec:	4a17      	ldr	r2, [pc, #92]	; (800024c <endfiniloop+0x4>)

080001ee <psloop>:
 80001ee:	4291      	cmp	r1, r2
 80001f0:	bf3c      	itt	cc
 80001f2:	f841 0b04 	strcc.w	r0, [r1], #4
 80001f6:	e7fa      	bcc.n	80001ee <psloop>
 80001f8:	4919      	ldr	r1, [pc, #100]	; (8000260 <endfiniloop+0x18>)
 80001fa:	4a1a      	ldr	r2, [pc, #104]	; (8000264 <endfiniloop+0x1c>)
 80001fc:	4b1a      	ldr	r3, [pc, #104]	; (8000268 <endfiniloop+0x20>)

080001fe <dloop>:
 80001fe:	429a      	cmp	r2, r3
 8000200:	bf3e      	ittt	cc
 8000202:	f851 0b04 	ldrcc.w	r0, [r1], #4
 8000206:	f842 0b04 	strcc.w	r0, [r2], #4
 800020a:	e7f8      	bcc.n	80001fe <dloop>
 800020c:	2000      	movs	r0, #0
 800020e:	4917      	ldr	r1, [pc, #92]	; (800026c <endfiniloop+0x24>)
 8000210:	4a17      	ldr	r2, [pc, #92]	; (8000270 <endfiniloop+0x28>)

08000212 <bloop>:
 8000212:	4291      	cmp	r1, r2
 8000214:	bf3c      	itt	cc
 8000216:	f841 0b04 	strcc.w	r0, [r1], #4
 800021a:	e7fa      	bcc.n	8000212 <bloop>
 800021c:	f004 ffc8 	bl	80051b0 <__init_ram_areas>
 8000220:	f004 ffb6 	bl	8005190 <__late_init>
 8000224:	4c13      	ldr	r4, [pc, #76]	; (8000274 <endfiniloop+0x2c>)
 8000226:	4d14      	ldr	r5, [pc, #80]	; (8000278 <endfiniloop+0x30>)

08000228 <initloop>:
 8000228:	42ac      	cmp	r4, r5
 800022a:	da03      	bge.n	8000234 <endinitloop>
 800022c:	f854 1b04 	ldr.w	r1, [r4], #4
 8000230:	4788      	blx	r1
 8000232:	e7f9      	b.n	8000228 <initloop>

08000234 <endinitloop>:
 8000234:	f000 fbcc 	bl	80009d0 <main>
 8000238:	4c10      	ldr	r4, [pc, #64]	; (800027c <endfiniloop+0x34>)
 800023a:	4d11      	ldr	r5, [pc, #68]	; (8000280 <endfiniloop+0x38>)

0800023c <finiloop>:
 800023c:	42ac      	cmp	r4, r5
 800023e:	da03      	bge.n	8000248 <endfiniloop>
 8000240:	f854 1b04 	ldr.w	r1, [r4], #4
 8000244:	4788      	blx	r1
 8000246:	e7f9      	b.n	800023c <finiloop>

08000248 <endfiniloop>:
 8000248:	f004 bfaa 	b.w	80051a0 <__default_exit>
 800024c:	20000800 	.word	0x20000800
 8000250:	55555555 	.word	0x55555555
 8000254:	20000000 	.word	0x20000000
 8000258:	20000400 	.word	0x20000400
 800025c:	20000400 	.word	0x20000400
 8000260:	08006f48 	.word	0x08006f48
 8000264:	20000800 	.word	0x20000800
 8000268:	20000808 	.word	0x20000808
 800026c:	20000808 	.word	0x20000808
 8000270:	20000f44 	.word	0x20000f44
 8000274:	080001c0 	.word	0x080001c0
 8000278:	080001c0 	.word	0x080001c0
 800027c:	080001c0 	.word	0x080001c0
 8000280:	080001c0 	.word	0x080001c0
	...

08000290 <_port_switch>:
 8000290:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000294:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000298:	68c3      	ldr	r3, [r0, #12]
 800029a:	469d      	mov	sp, r3
 800029c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002a0 <_port_thread_start>:
 80002a0:	2300      	movs	r3, #0
 80002a2:	f383 8811 	msr	BASEPRI, r3
 80002a6:	4628      	mov	r0, r5
 80002a8:	47a0      	blx	r4
 80002aa:	2000      	movs	r0, #0
 80002ac:	f005 fe68 	bl	8005f80 <chThdExit>

080002b0 <_port_switch_from_isr>:
 80002b0:	f005 fcfe 	bl	8005cb0 <chSchDoReschedule>

080002b4 <_port_exit_from_isr>:
 80002b4:	df00      	svc	0
 80002b6:	e7fe      	b.n	80002b6 <_port_exit_from_isr+0x2>
	...

080002c0 <memcpy>:
 80002c0:	4684      	mov	ip, r0
 80002c2:	ea41 0300 	orr.w	r3, r1, r0
 80002c6:	f013 0303 	ands.w	r3, r3, #3
 80002ca:	d16d      	bne.n	80003a8 <memcpy+0xe8>
 80002cc:	3a40      	subs	r2, #64	; 0x40
 80002ce:	d341      	bcc.n	8000354 <memcpy+0x94>
 80002d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002d4:	f840 3b04 	str.w	r3, [r0], #4
 80002d8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002dc:	f840 3b04 	str.w	r3, [r0], #4
 80002e0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002e4:	f840 3b04 	str.w	r3, [r0], #4
 80002e8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002ec:	f840 3b04 	str.w	r3, [r0], #4
 80002f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002f4:	f840 3b04 	str.w	r3, [r0], #4
 80002f8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002fc:	f840 3b04 	str.w	r3, [r0], #4
 8000300:	f851 3b04 	ldr.w	r3, [r1], #4
 8000304:	f840 3b04 	str.w	r3, [r0], #4
 8000308:	f851 3b04 	ldr.w	r3, [r1], #4
 800030c:	f840 3b04 	str.w	r3, [r0], #4
 8000310:	f851 3b04 	ldr.w	r3, [r1], #4
 8000314:	f840 3b04 	str.w	r3, [r0], #4
 8000318:	f851 3b04 	ldr.w	r3, [r1], #4
 800031c:	f840 3b04 	str.w	r3, [r0], #4
 8000320:	f851 3b04 	ldr.w	r3, [r1], #4
 8000324:	f840 3b04 	str.w	r3, [r0], #4
 8000328:	f851 3b04 	ldr.w	r3, [r1], #4
 800032c:	f840 3b04 	str.w	r3, [r0], #4
 8000330:	f851 3b04 	ldr.w	r3, [r1], #4
 8000334:	f840 3b04 	str.w	r3, [r0], #4
 8000338:	f851 3b04 	ldr.w	r3, [r1], #4
 800033c:	f840 3b04 	str.w	r3, [r0], #4
 8000340:	f851 3b04 	ldr.w	r3, [r1], #4
 8000344:	f840 3b04 	str.w	r3, [r0], #4
 8000348:	f851 3b04 	ldr.w	r3, [r1], #4
 800034c:	f840 3b04 	str.w	r3, [r0], #4
 8000350:	3a40      	subs	r2, #64	; 0x40
 8000352:	d2bd      	bcs.n	80002d0 <memcpy+0x10>
 8000354:	3230      	adds	r2, #48	; 0x30
 8000356:	d311      	bcc.n	800037c <memcpy+0xbc>
 8000358:	f851 3b04 	ldr.w	r3, [r1], #4
 800035c:	f840 3b04 	str.w	r3, [r0], #4
 8000360:	f851 3b04 	ldr.w	r3, [r1], #4
 8000364:	f840 3b04 	str.w	r3, [r0], #4
 8000368:	f851 3b04 	ldr.w	r3, [r1], #4
 800036c:	f840 3b04 	str.w	r3, [r0], #4
 8000370:	f851 3b04 	ldr.w	r3, [r1], #4
 8000374:	f840 3b04 	str.w	r3, [r0], #4
 8000378:	3a10      	subs	r2, #16
 800037a:	d2ed      	bcs.n	8000358 <memcpy+0x98>
 800037c:	320c      	adds	r2, #12
 800037e:	d305      	bcc.n	800038c <memcpy+0xcc>
 8000380:	f851 3b04 	ldr.w	r3, [r1], #4
 8000384:	f840 3b04 	str.w	r3, [r0], #4
 8000388:	3a04      	subs	r2, #4
 800038a:	d2f9      	bcs.n	8000380 <memcpy+0xc0>
 800038c:	3204      	adds	r2, #4
 800038e:	d008      	beq.n	80003a2 <memcpy+0xe2>
 8000390:	07d2      	lsls	r2, r2, #31
 8000392:	bf1c      	itt	ne
 8000394:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000398:	f800 3b01 	strbne.w	r3, [r0], #1
 800039c:	d301      	bcc.n	80003a2 <memcpy+0xe2>
 800039e:	880b      	ldrh	r3, [r1, #0]
 80003a0:	8003      	strh	r3, [r0, #0]
 80003a2:	4660      	mov	r0, ip
 80003a4:	4770      	bx	lr
 80003a6:	bf00      	nop
 80003a8:	2a08      	cmp	r2, #8
 80003aa:	d313      	bcc.n	80003d4 <memcpy+0x114>
 80003ac:	078b      	lsls	r3, r1, #30
 80003ae:	d08d      	beq.n	80002cc <memcpy+0xc>
 80003b0:	f010 0303 	ands.w	r3, r0, #3
 80003b4:	d08a      	beq.n	80002cc <memcpy+0xc>
 80003b6:	f1c3 0304 	rsb	r3, r3, #4
 80003ba:	1ad2      	subs	r2, r2, r3
 80003bc:	07db      	lsls	r3, r3, #31
 80003be:	bf1c      	itt	ne
 80003c0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003c4:	f800 3b01 	strbne.w	r3, [r0], #1
 80003c8:	d380      	bcc.n	80002cc <memcpy+0xc>
 80003ca:	f831 3b02 	ldrh.w	r3, [r1], #2
 80003ce:	f820 3b02 	strh.w	r3, [r0], #2
 80003d2:	e77b      	b.n	80002cc <memcpy+0xc>
 80003d4:	3a04      	subs	r2, #4
 80003d6:	d3d9      	bcc.n	800038c <memcpy+0xcc>
 80003d8:	3a01      	subs	r2, #1
 80003da:	f811 3b01 	ldrb.w	r3, [r1], #1
 80003de:	f800 3b01 	strb.w	r3, [r0], #1
 80003e2:	d2f9      	bcs.n	80003d8 <memcpy+0x118>
 80003e4:	780b      	ldrb	r3, [r1, #0]
 80003e6:	7003      	strb	r3, [r0, #0]
 80003e8:	784b      	ldrb	r3, [r1, #1]
 80003ea:	7043      	strb	r3, [r0, #1]
 80003ec:	788b      	ldrb	r3, [r1, #2]
 80003ee:	7083      	strb	r3, [r0, #2]
 80003f0:	4660      	mov	r0, ip
 80003f2:	4770      	bx	lr
	...

08000400 <port_lock.lto_priv.24>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000400:	b082      	sub	sp, #8
 8000402:	2320      	movs	r3, #32
 8000404:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000406:	9b01      	ldr	r3, [sp, #4]
 8000408:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800040c:	b002      	add	sp, #8
 800040e:	4770      	bx	lr

08000410 <port_unlock.lto_priv.22>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000410:	b082      	sub	sp, #8
 8000412:	2300      	movs	r3, #0
 8000414:	9301      	str	r3, [sp, #4]
 8000416:	9b01      	ldr	r3, [sp, #4]
 8000418:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800041c:	b002      	add	sp, #8
 800041e:	4770      	bx	lr

08000420 <port_lock_from_isr.lto_priv.20>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000420:	b508      	push	{r3, lr}

  port_lock();
 8000422:	f7ff ffed 	bl	8000400 <port_lock.lto_priv.24>
}
 8000426:	bd08      	pop	{r3, pc}
	...

08000430 <port_unlock_from_isr.lto_priv.18>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000430:	b508      	push	{r3, lr}

  port_unlock();
 8000432:	f7ff ffed 	bl	8000410 <port_unlock.lto_priv.22>
}
 8000436:	bd08      	pop	{r3, pc}
	...

08000440 <chSysLockFromISR.lto_priv.16>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000440:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000442:	f7ff ffed 	bl	8000420 <port_lock_from_isr.lto_priv.20>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8000446:	bd08      	pop	{r3, pc}
	...

08000450 <chSysUnlockFromISR.lto_priv.14>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000450:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000452:	f7ff ffed 	bl	8000430 <port_unlock_from_isr.lto_priv.18>
}
 8000456:	bd08      	pop	{r3, pc}
	...

08000460 <get_descriptor.lto_priv.331>:
 * handled here.
 */
static const USBDescriptor *get_descriptor(USBDriver *usbp,
                                           uint8_t dtype,
                                           uint8_t dindex,
                                           uint16_t lang) {
 8000460:	b082      	sub	sp, #8
 8000462:	9001      	str	r0, [sp, #4]
 8000464:	4608      	mov	r0, r1
 8000466:	4611      	mov	r1, r2
 8000468:	461a      	mov	r2, r3
 800046a:	4603      	mov	r3, r0
 800046c:	f88d 3003 	strb.w	r3, [sp, #3]
 8000470:	460b      	mov	r3, r1
 8000472:	f88d 3002 	strb.w	r3, [sp, #2]
 8000476:	4613      	mov	r3, r2
 8000478:	f8ad 3000 	strh.w	r3, [sp]

  (void)usbp;
  (void)lang;
  switch (dtype) {
 800047c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000480:	2b02      	cmp	r3, #2
 8000482:	d005      	beq.n	8000490 <get_descriptor.lto_priv.331+0x30>
 8000484:	2b03      	cmp	r3, #3
 8000486:	d005      	beq.n	8000494 <get_descriptor.lto_priv.331+0x34>
 8000488:	2b01      	cmp	r3, #1
 800048a:	d10d      	bne.n	80004a8 <get_descriptor.lto_priv.331+0x48>
  case USB_DESCRIPTOR_DEVICE:
    return &usb_device_descriptor;
 800048c:	4b08      	ldr	r3, [pc, #32]	; (80004b0 <get_descriptor.lto_priv.331+0x50>)
 800048e:	e00c      	b.n	80004aa <get_descriptor.lto_priv.331+0x4a>
  case USB_DESCRIPTOR_CONFIGURATION:
    return &usb_configuration_descriptor;
 8000490:	4b08      	ldr	r3, [pc, #32]	; (80004b4 <get_descriptor.lto_priv.331+0x54>)
 8000492:	e00a      	b.n	80004aa <get_descriptor.lto_priv.331+0x4a>
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
 8000494:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8000498:	2b03      	cmp	r3, #3
 800049a:	d805      	bhi.n	80004a8 <get_descriptor.lto_priv.331+0x48>
      return &usb_strings[dindex];
 800049c:	f89d 3002 	ldrb.w	r3, [sp, #2]
 80004a0:	00db      	lsls	r3, r3, #3
 80004a2:	4a05      	ldr	r2, [pc, #20]	; (80004b8 <get_descriptor.lto_priv.331+0x58>)
 80004a4:	4413      	add	r3, r2
 80004a6:	e000      	b.n	80004aa <get_descriptor.lto_priv.331+0x4a>
  }
  return NULL;
 80004a8:	2300      	movs	r3, #0
}
 80004aa:	4618      	mov	r0, r3
 80004ac:	b002      	add	sp, #8
 80004ae:	4770      	bx	lr
 80004b0:	08006cd0 	.word	0x08006cd0
 80004b4:	08006d00 	.word	0x08006d00
 80004b8:	08006db0 	.word	0x08006db0
 80004bc:	00000000 	.word	0x00000000

080004c0 <usb_event.lto_priv.330>:
};

/*
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {
 80004c0:	b500      	push	{lr}
 80004c2:	b083      	sub	sp, #12
 80004c4:	9001      	str	r0, [sp, #4]
 80004c6:	460b      	mov	r3, r1
 80004c8:	f88d 3003 	strb.w	r3, [sp, #3]

  switch (event) {
 80004cc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80004d0:	2b05      	cmp	r3, #5
 80004d2:	d81d      	bhi.n	8000510 <usb_event.lto_priv.330+0x50>
 80004d4:	a201      	add	r2, pc, #4	; (adr r2, 80004dc <usb_event.lto_priv.330+0x1c>)
 80004d6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80004da:	bf00      	nop
 80004dc:	08000511 	.word	0x08000511
 80004e0:	08000511 	.word	0x08000511
 80004e4:	080004f5 	.word	0x080004f5
 80004e8:	08000511 	.word	0x08000511
 80004ec:	08000511 	.word	0x08000511
 80004f0:	08000511 	.word	0x08000511
  case USB_EVENT_RESET:
    return;
  case USB_EVENT_ADDRESS:
    return;
  case USB_EVENT_CONFIGURED:
    chSysLockFromISR();
 80004f4:	f7ff ffa4 	bl	8000440 <chSysLockFromISR.lto_priv.16>

    /* Enables the endpoints specified into the configuration.
       Note, this callback is invoked from an ISR so I-Class functions
       must be used.*/
    usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
 80004f8:	9801      	ldr	r0, [sp, #4]
 80004fa:	2101      	movs	r1, #1
 80004fc:	4a06      	ldr	r2, [pc, #24]	; (8000518 <usb_event.lto_priv.330+0x58>)
 80004fe:	f003 fe3f 	bl	8004180 <usbInitEndpointI>
    usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);
 8000502:	9801      	ldr	r0, [sp, #4]
 8000504:	2102      	movs	r1, #2
 8000506:	4a05      	ldr	r2, [pc, #20]	; (800051c <usb_event.lto_priv.330+0x5c>)
 8000508:	f003 fe3a 	bl	8004180 <usbInitEndpointI>

    chSysUnlockFromISR();
 800050c:	f7ff ffa0 	bl	8000450 <chSysUnlockFromISR.lto_priv.14>
    return;
  case USB_EVENT_STALLED:
    return;
  }
  return;
}
 8000510:	b003      	add	sp, #12
 8000512:	f85d fb04 	ldr.w	pc, [sp], #4
 8000516:	bf00      	nop
 8000518:	08006dd0 	.word	0x08006dd0
 800051c:	08006e00 	.word	0x08006e00

08000520 <request_hook>:
static cdc_linecoding_t linecoding = {
  {0x00, 0x96, 0x00, 0x00},             /* 38400.                           */
  LC_STOP_1, LC_PARITY_NONE, 8
};

bool request_hook(USBDriver *usbp) {
 8000520:	b082      	sub	sp, #8
 8000522:	9001      	str	r0, [sp, #4]

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8000524:	9b01      	ldr	r3, [sp, #4]
 8000526:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800052a:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800052e:	2b20      	cmp	r3, #32
 8000530:	d12c      	bne.n	800058c <request_hook+0x6c>
    switch (usbp->setup[1]) {
 8000532:	9b01      	ldr	r3, [sp, #4]
 8000534:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8000538:	2b21      	cmp	r3, #33	; 0x21
 800053a:	d004      	beq.n	8000546 <request_hook+0x26>
 800053c:	2b22      	cmp	r3, #34	; 0x22
 800053e:	d018      	beq.n	8000572 <request_hook+0x52>
 8000540:	2b20      	cmp	r3, #32
 8000542:	d00b      	beq.n	800055c <request_hook+0x3c>
 8000544:	e020      	b.n	8000588 <request_hook+0x68>
    case CDC_GET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 8000546:	9b01      	ldr	r3, [sp, #4]
 8000548:	4a12      	ldr	r2, [pc, #72]	; (8000594 <request_hook+0x74>)
 800054a:	639a      	str	r2, [r3, #56]	; 0x38
 800054c:	9b01      	ldr	r3, [sp, #4]
 800054e:	2207      	movs	r2, #7
 8000550:	63da      	str	r2, [r3, #60]	; 0x3c
 8000552:	9b01      	ldr	r3, [sp, #4]
 8000554:	2200      	movs	r2, #0
 8000556:	641a      	str	r2, [r3, #64]	; 0x40
      return true;
 8000558:	2301      	movs	r3, #1
 800055a:	e018      	b.n	800058e <request_hook+0x6e>
    case CDC_SET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 800055c:	9b01      	ldr	r3, [sp, #4]
 800055e:	4a0d      	ldr	r2, [pc, #52]	; (8000594 <request_hook+0x74>)
 8000560:	639a      	str	r2, [r3, #56]	; 0x38
 8000562:	9b01      	ldr	r3, [sp, #4]
 8000564:	2207      	movs	r2, #7
 8000566:	63da      	str	r2, [r3, #60]	; 0x3c
 8000568:	9b01      	ldr	r3, [sp, #4]
 800056a:	2200      	movs	r2, #0
 800056c:	641a      	str	r2, [r3, #64]	; 0x40
      return true;
 800056e:	2301      	movs	r3, #1
 8000570:	e00d      	b.n	800058e <request_hook+0x6e>
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8000572:	9b01      	ldr	r3, [sp, #4]
 8000574:	2200      	movs	r2, #0
 8000576:	639a      	str	r2, [r3, #56]	; 0x38
 8000578:	9b01      	ldr	r3, [sp, #4]
 800057a:	2200      	movs	r2, #0
 800057c:	63da      	str	r2, [r3, #60]	; 0x3c
 800057e:	9b01      	ldr	r3, [sp, #4]
 8000580:	2200      	movs	r2, #0
 8000582:	641a      	str	r2, [r3, #64]	; 0x40
      return true;
 8000584:	2301      	movs	r3, #1
 8000586:	e002      	b.n	800058e <request_hook+0x6e>
    default:
      return false;
 8000588:	2300      	movs	r3, #0
 800058a:	e000      	b.n	800058e <request_hook+0x6e>
    }
  }
  return false;
 800058c:	2300      	movs	r3, #0
}
 800058e:	4618      	mov	r0, r3
 8000590:	b002      	add	sp, #8
 8000592:	4770      	bx	lr
 8000594:	20000800 	.word	0x20000800
	...

080005a0 <port_lock.lto_priv.25>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80005a0:	b082      	sub	sp, #8
 80005a2:	2320      	movs	r3, #32
 80005a4:	9301      	str	r3, [sp, #4]
 80005a6:	9b01      	ldr	r3, [sp, #4]
 80005a8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80005ac:	b002      	add	sp, #8
 80005ae:	4770      	bx	lr

080005b0 <port_unlock.lto_priv.23>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80005b0:	b082      	sub	sp, #8
 80005b2:	2300      	movs	r3, #0
 80005b4:	9301      	str	r3, [sp, #4]
 80005b6:	9b01      	ldr	r3, [sp, #4]
 80005b8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80005bc:	b002      	add	sp, #8
 80005be:	4770      	bx	lr

080005c0 <port_lock_from_isr.lto_priv.21>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80005c0:	b508      	push	{r3, lr}

  port_lock();
 80005c2:	f7ff ffed 	bl	80005a0 <port_lock.lto_priv.25>
}
 80005c6:	bd08      	pop	{r3, pc}
	...

080005d0 <port_unlock_from_isr.lto_priv.19>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80005d0:	b508      	push	{r3, lr}

  port_unlock();
 80005d2:	f7ff ffed 	bl	80005b0 <port_unlock.lto_priv.23>
}
 80005d6:	bd08      	pop	{r3, pc}
	...

080005e0 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80005e0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80005e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80005e6:	4618      	mov	r0, r3
 80005e8:	4770      	bx	lr
 80005ea:	bf00      	nop
 80005ec:	0000      	movs	r0, r0
	...

080005f0 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 80005f0:	b508      	push	{r3, lr}

  return stGetCounter();
 80005f2:	f7ff fff5 	bl	80005e0 <st_lld_get_counter>
 80005f6:	4603      	mov	r3, r0
}
 80005f8:	4618      	mov	r0, r3
 80005fa:	bd08      	pop	{r3, pc}
 80005fc:	0000      	movs	r0, r0
	...

08000600 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8000600:	b508      	push	{r3, lr}

  port_lock();
 8000602:	f7ff ffcd 	bl	80005a0 <port_lock.lto_priv.25>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8000606:	bd08      	pop	{r3, pc}
	...

08000610 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8000610:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8000612:	f7ff ffcd 	bl	80005b0 <port_unlock.lto_priv.23>
}
 8000616:	bd08      	pop	{r3, pc}
	...

08000620 <chSysLockFromISR.lto_priv.17>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000620:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000622:	f7ff ffcd 	bl	80005c0 <port_lock_from_isr.lto_priv.21>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8000626:	bd08      	pop	{r3, pc}
	...

08000630 <chSysUnlockFromISR.lto_priv.15>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000630:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000632:	f7ff ffcd 	bl	80005d0 <port_unlock_from_isr.lto_priv.19>
}
 8000636:	bd08      	pop	{r3, pc}
	...

08000640 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8000640:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8000642:	f7ff ffd5 	bl	80005f0 <port_timer_get_time>
 8000646:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000648:	4618      	mov	r0, r3
 800064a:	bd08      	pop	{r3, pc}
 800064c:	0000      	movs	r0, r0
	...

08000650 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 8000650:	b500      	push	{lr}
 8000652:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 8000654:	f7ff ffd4 	bl	8000600 <chSysLock>
  systime = chVTGetSystemTimeX();
 8000658:	f7ff fff2 	bl	8000640 <chVTGetSystemTimeX>
 800065c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800065e:	f7ff ffd7 	bl	8000610 <chSysUnlock>

  return systime;
 8000662:	9b01      	ldr	r3, [sp, #4]
}
 8000664:	4618      	mov	r0, r3
 8000666:	b003      	add	sp, #12
 8000668:	f85d fb04 	ldr.w	pc, [sp], #4
 800066c:	0000      	movs	r0, r0
	...

08000670 <chVTTimeElapsedSinceX>:
 * @param[in] start     start time
 * @return              The elapsed time.
 *
 * @xclass
 */
static inline systime_t chVTTimeElapsedSinceX(systime_t start) {
 8000670:	b500      	push	{lr}
 8000672:	b083      	sub	sp, #12
 8000674:	9001      	str	r0, [sp, #4]

  return chVTGetSystemTimeX() - start;
 8000676:	f7ff ffe3 	bl	8000640 <chVTGetSystemTimeX>
 800067a:	4602      	mov	r2, r0
 800067c:	9b01      	ldr	r3, [sp, #4]
 800067e:	1ad3      	subs	r3, r2, r3
}
 8000680:	4618      	mov	r0, r3
 8000682:	b003      	add	sp, #12
 8000684:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000690 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8000690:	4b01      	ldr	r3, [pc, #4]	; (8000698 <chThdGetSelfX+0x8>)
 8000692:	699b      	ldr	r3, [r3, #24]
}
 8000694:	4618      	mov	r0, r3
 8000696:	4770      	bx	lr
 8000698:	20000808 	.word	0x20000808
 800069c:	00000000 	.word	0x00000000

080006a0 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 80006a0:	b082      	sub	sp, #8
 80006a2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 80006a4:	4b02      	ldr	r3, [pc, #8]	; (80006b0 <chRegSetThreadName+0x10>)
 80006a6:	699b      	ldr	r3, [r3, #24]
 80006a8:	9a01      	ldr	r2, [sp, #4]
 80006aa:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 80006ac:	b002      	add	sp, #8
 80006ae:	4770      	bx	lr
 80006b0:	20000808 	.word	0x20000808
	...

080006c0 <extCallback.lto_priv.329>:

/*
 * Hardware interrupt which wakes accel thread
 */
static void extCallback(EXTDriver *extp, expchannel_t channel)
{
 80006c0:	b500      	push	{lr}
 80006c2:	b083      	sub	sp, #12
 80006c4:	9001      	str	r0, [sp, #4]
 80006c6:	9100      	str	r1, [sp, #0]
  (void)extp;
  (void)channel;

  chSysLockFromISR();
 80006c8:	f7ff ffaa 	bl	8000620 <chSysLockFromISR.lto_priv.17>
  chEvtSignalI(tp_accel, (eventmask_t)1); /* Wake thread */
 80006cc:	4b05      	ldr	r3, [pc, #20]	; (80006e4 <extCallback.lto_priv.329+0x24>)
 80006ce:	681b      	ldr	r3, [r3, #0]
 80006d0:	4618      	mov	r0, r3
 80006d2:	2101      	movs	r1, #1
 80006d4:	f004 fcac 	bl	8005030 <chEvtSignalI>
  chSysUnlockFromISR();
 80006d8:	f7ff ffaa 	bl	8000630 <chSysUnlockFromISR.lto_priv.15>
}
 80006dc:	b003      	add	sp, #12
 80006de:	f85d fb04 	ldr.w	pc, [sp], #4
 80006e2:	bf00      	nop
 80006e4:	20000cac 	.word	0x20000cac
	...

080006f0 <Writer>:

/*
 * USB writer. This thread writes accelerometer data to the USB at maximum rate.
 */
static THD_WORKING_AREA(waWriter, 128);
static THD_FUNCTION(Writer, arg) {
 80006f0:	b510      	push	{r4, lr}
 80006f2:	b094      	sub	sp, #80	; 0x50
 80006f4:	9001      	str	r0, [sp, #4]

  (void)arg;
  chRegSetThreadName("writer");
 80006f6:	482a      	ldr	r0, [pc, #168]	; (80007a0 <Writer+0xb0>)
 80006f8:	f7ff ffd2 	bl	80006a0 <chRegSetThreadName>
  systime_t time = chVTGetSystemTime();
 80006fc:	f7ff ffa8 	bl	8000650 <chVTGetSystemTime>
 8000700:	9013      	str	r0, [sp, #76]	; 0x4c
  static int8_t pwmState;

  while (true) {
    /* Concatenate accelerometer data */
    uint8_t usbBuf[5*CHUNK];
    memcpy(usbBuf                            , &xbuf, sizeof(xbuf));
 8000702:	4a28      	ldr	r2, [pc, #160]	; (80007a4 <Writer+0xb4>)
 8000704:	ab03      	add	r3, sp, #12
 8000706:	ca07      	ldmia	r2, {r0, r1, r2}
 8000708:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    memcpy(usbBuf+sizeof(xbuf)               , &ybuf, sizeof(ybuf));
 800070c:	ab03      	add	r3, sp, #12
 800070e:	330c      	adds	r3, #12
 8000710:	4a25      	ldr	r2, [pc, #148]	; (80007a8 <Writer+0xb8>)
 8000712:	461c      	mov	r4, r3
 8000714:	4613      	mov	r3, r2
 8000716:	cb07      	ldmia	r3!, {r0, r1, r2}
 8000718:	6020      	str	r0, [r4, #0]
 800071a:	6061      	str	r1, [r4, #4]
 800071c:	60a2      	str	r2, [r4, #8]
    memcpy(usbBuf+2*sizeof(xbuf)             , &zbuf, sizeof(zbuf));
 800071e:	ab03      	add	r3, sp, #12
 8000720:	3318      	adds	r3, #24
 8000722:	4a22      	ldr	r2, [pc, #136]	; (80007ac <Writer+0xbc>)
 8000724:	461c      	mov	r4, r3
 8000726:	4613      	mov	r3, r2
 8000728:	cb07      	ldmia	r3!, {r0, r1, r2}
 800072a:	6020      	str	r0, [r4, #0]
 800072c:	6061      	str	r1, [r4, #4]
 800072e:	60a2      	str	r2, [r4, #8]
    memcpy(usbBuf+3*sizeof(xbuf)             , &timebuf, sizeof(timebuf));
 8000730:	ab03      	add	r3, sp, #12
 8000732:	3324      	adds	r3, #36	; 0x24
 8000734:	4618      	mov	r0, r3
 8000736:	491e      	ldr	r1, [pc, #120]	; (80007b0 <Writer+0xc0>)
 8000738:	2218      	movs	r2, #24
 800073a:	f7ff fdc1 	bl	80002c0 <memcpy>

    msg_t msg = usbTransmit(&USBD1, USBD1_DATA_REQUEST_EP, usbBuf, sizeof(usbBuf));
 800073e:	ab03      	add	r3, sp, #12
 8000740:	481c      	ldr	r0, [pc, #112]	; (80007b4 <Writer+0xc4>)
 8000742:	2101      	movs	r1, #1
 8000744:	461a      	mov	r2, r3
 8000746:	233c      	movs	r3, #60	; 0x3c
 8000748:	f003 fdba 	bl	80042c0 <usbTransmit>
 800074c:	9012      	str	r0, [sp, #72]	; 0x48

    /* Indicate thread frequency on red LED */
    if(++usbCnt >= 1)
 800074e:	4b1a      	ldr	r3, [pc, #104]	; (80007b8 <Writer+0xc8>)
 8000750:	781b      	ldrb	r3, [r3, #0]
 8000752:	3301      	adds	r3, #1
 8000754:	b2da      	uxtb	r2, r3
 8000756:	4b18      	ldr	r3, [pc, #96]	; (80007b8 <Writer+0xc8>)
 8000758:	701a      	strb	r2, [r3, #0]
 800075a:	4b17      	ldr	r3, [pc, #92]	; (80007b8 <Writer+0xc8>)
 800075c:	781b      	ldrb	r3, [r3, #0]
 800075e:	2b00      	cmp	r3, #0
 8000760:	d013      	beq.n	800078a <Writer+0x9a>
    {
      pwmState = pwmState ? 0x00 : 0xFF; /* toggle */
 8000762:	4b16      	ldr	r3, [pc, #88]	; (80007bc <Writer+0xcc>)
 8000764:	781b      	ldrb	r3, [r3, #0]
 8000766:	2b00      	cmp	r3, #0
 8000768:	d001      	beq.n	800076e <Writer+0x7e>
 800076a:	2200      	movs	r2, #0
 800076c:	e000      	b.n	8000770 <Writer+0x80>
 800076e:	22ff      	movs	r2, #255	; 0xff
 8000770:	4b12      	ldr	r3, [pc, #72]	; (80007bc <Writer+0xcc>)
 8000772:	701a      	strb	r2, [r3, #0]
      pwmEnableChannel(&PWMD4, 2, (pwmcnt_t)pwmState);
 8000774:	4b11      	ldr	r3, [pc, #68]	; (80007bc <Writer+0xcc>)
 8000776:	781b      	ldrb	r3, [r3, #0]
 8000778:	b25b      	sxtb	r3, r3
 800077a:	4811      	ldr	r0, [pc, #68]	; (80007c0 <Writer+0xd0>)
 800077c:	2102      	movs	r1, #2
 800077e:	461a      	mov	r2, r3
 8000780:	f004 fbc6 	bl	8004f10 <pwmEnableChannel>
      usbCnt = 0;
 8000784:	4b0c      	ldr	r3, [pc, #48]	; (80007b8 <Writer+0xc8>)
 8000786:	2200      	movs	r2, #0
 8000788:	701a      	strb	r2, [r3, #0]
    }

    /* Operate at (400/CHUNK) Hz : Waiting until the next 30 milliseconds time interval */
    if(msg == MSG_RESET)
 800078a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800078c:	f113 0f02 	cmn.w	r3, #2
 8000790:	d1b7      	bne.n	8000702 <Writer+0x12>
      chThdSleepUntil(time += MS2ST(CHUNK*0.1*2.5f));
 8000792:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8000794:	331e      	adds	r3, #30
 8000796:	9313      	str	r3, [sp, #76]	; 0x4c
 8000798:	9813      	ldr	r0, [sp, #76]	; 0x4c
 800079a:	f005 fbd9 	bl	8005f50 <chThdSleepUntil>
 800079e:	e7b0      	b.n	8000702 <Writer+0x12>
 80007a0:	08006298 	.word	0x08006298
 80007a4:	20000c70 	.word	0x20000c70
 80007a8:	20000c7c 	.word	0x20000c7c
 80007ac:	20000c88 	.word	0x20000c88
 80007b0:	20000c94 	.word	0x20000c94
 80007b4:	20000a10 	.word	0x20000a10
 80007b8:	20000f40 	.word	0x20000f40
 80007bc:	20000f41 	.word	0x20000f41
 80007c0:	20000c10 	.word	0x20000c10
	...

080007d0 <AccelThread>:
/*
 * This is a data-ready-triggered thread that reads accelerometer and outputs
 * result to PWM. Read data is available for USB Writer thread.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(AccelThread, arg) {
 80007d0:	b500      	push	{lr}
 80007d2:	b085      	sub	sp, #20
 80007d4:	9001      	str	r0, [sp, #4]
#endif
  static uint8_t readCnt;
  static int8_t pwmState;

  (void)arg;
  chRegSetThreadName("accelReader");
 80007d6:	4856      	ldr	r0, [pc, #344]	; (8000930 <AccelThread+0x160>)
 80007d8:	f7ff ff62 	bl	80006a0 <chRegSetThreadName>
  tp_accel = chThdGetSelfX();
 80007dc:	f7ff ff58 	bl	8000690 <chThdGetSelfX>
 80007e0:	4602      	mov	r2, r0
 80007e2:	4b54      	ldr	r3, [pc, #336]	; (8000934 <AccelThread+0x164>)
 80007e4:	601a      	str	r2, [r3, #0]
  const systime_t start = chVTGetSystemTime();
 80007e6:	f7ff ff33 	bl	8000650 <chVTGetSystemTime>
 80007ea:	9002      	str	r0, [sp, #8]

  /* Accelerometer reader thread loop.*/
  while (true) {

    /* Checks if an IRQ happened else wait.*/
    chEvtWaitAny((eventmask_t)1);
 80007ec:	2001      	movs	r0, #1
 80007ee:	f004 fc4f 	bl	8005090 <chEvtWaitAny>

    unsigned i;
    /* Keeping an history of the latest accelerometer readings with timestamp */
    for (i = CHUNK-1; i > 0; i--) {
 80007f2:	230b      	movs	r3, #11
 80007f4:	9303      	str	r3, [sp, #12]
 80007f6:	e026      	b.n	8000846 <AccelThread+0x76>
      xbuf[i] = xbuf[i - 1];
 80007f8:	9b03      	ldr	r3, [sp, #12]
 80007fa:	3b01      	subs	r3, #1
 80007fc:	4a4e      	ldr	r2, [pc, #312]	; (8000938 <AccelThread+0x168>)
 80007fe:	5cd1      	ldrb	r1, [r2, r3]
 8000800:	4a4d      	ldr	r2, [pc, #308]	; (8000938 <AccelThread+0x168>)
 8000802:	9b03      	ldr	r3, [sp, #12]
 8000804:	4413      	add	r3, r2
 8000806:	460a      	mov	r2, r1
 8000808:	701a      	strb	r2, [r3, #0]
      ybuf[i] = ybuf[i - 1];
 800080a:	9b03      	ldr	r3, [sp, #12]
 800080c:	3b01      	subs	r3, #1
 800080e:	4a4b      	ldr	r2, [pc, #300]	; (800093c <AccelThread+0x16c>)
 8000810:	5cd1      	ldrb	r1, [r2, r3]
 8000812:	4a4a      	ldr	r2, [pc, #296]	; (800093c <AccelThread+0x16c>)
 8000814:	9b03      	ldr	r3, [sp, #12]
 8000816:	4413      	add	r3, r2
 8000818:	460a      	mov	r2, r1
 800081a:	701a      	strb	r2, [r3, #0]
      zbuf[i] = zbuf[i - 1];
 800081c:	9b03      	ldr	r3, [sp, #12]
 800081e:	3b01      	subs	r3, #1
 8000820:	4a47      	ldr	r2, [pc, #284]	; (8000940 <AccelThread+0x170>)
 8000822:	5cd1      	ldrb	r1, [r2, r3]
 8000824:	4a46      	ldr	r2, [pc, #280]	; (8000940 <AccelThread+0x170>)
 8000826:	9b03      	ldr	r3, [sp, #12]
 8000828:	4413      	add	r3, r2
 800082a:	460a      	mov	r2, r1
 800082c:	701a      	strb	r2, [r3, #0]
      timebuf[i] = timebuf[i - 1];
 800082e:	9b03      	ldr	r3, [sp, #12]
 8000830:	3b01      	subs	r3, #1
 8000832:	4a44      	ldr	r2, [pc, #272]	; (8000944 <AccelThread+0x174>)
 8000834:	f832 1013 	ldrh.w	r1, [r2, r3, lsl #1]
 8000838:	4a42      	ldr	r2, [pc, #264]	; (8000944 <AccelThread+0x174>)
 800083a:	9b03      	ldr	r3, [sp, #12]
 800083c:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
    /* Checks if an IRQ happened else wait.*/
    chEvtWaitAny((eventmask_t)1);

    unsigned i;
    /* Keeping an history of the latest accelerometer readings with timestamp */
    for (i = CHUNK-1; i > 0; i--) {
 8000840:	9b03      	ldr	r3, [sp, #12]
 8000842:	3b01      	subs	r3, #1
 8000844:	9303      	str	r3, [sp, #12]
 8000846:	9b03      	ldr	r3, [sp, #12]
 8000848:	2b00      	cmp	r3, #0
 800084a:	d1d5      	bne.n	80007f8 <AccelThread+0x28>
      zbuf[i] = zbuf[i - 1];
      timebuf[i] = timebuf[i - 1];
    }

    /* Reading MEMS accelerometer X, Y and Z registers.*/
    xbuf[0] = (int8_t)lis302dlReadRegister(&SPID1, LIS302DL_OUTX);
 800084c:	483e      	ldr	r0, [pc, #248]	; (8000948 <AccelThread+0x178>)
 800084e:	2129      	movs	r1, #41	; 0x29
 8000850:	f000 f93e 	bl	8000ad0 <lis302dlReadRegister>
 8000854:	4603      	mov	r3, r0
 8000856:	b2da      	uxtb	r2, r3
 8000858:	4b37      	ldr	r3, [pc, #220]	; (8000938 <AccelThread+0x168>)
 800085a:	701a      	strb	r2, [r3, #0]
    ybuf[0] = (int8_t)lis302dlReadRegister(&SPID1, LIS302DL_OUTY);
 800085c:	483a      	ldr	r0, [pc, #232]	; (8000948 <AccelThread+0x178>)
 800085e:	212b      	movs	r1, #43	; 0x2b
 8000860:	f000 f936 	bl	8000ad0 <lis302dlReadRegister>
 8000864:	4603      	mov	r3, r0
 8000866:	b2da      	uxtb	r2, r3
 8000868:	4b34      	ldr	r3, [pc, #208]	; (800093c <AccelThread+0x16c>)
 800086a:	701a      	strb	r2, [r3, #0]
    zbuf[0] = (int8_t)lis302dlReadRegister(&SPID1, LIS302DL_OUTZ);
 800086c:	4836      	ldr	r0, [pc, #216]	; (8000948 <AccelThread+0x178>)
 800086e:	212d      	movs	r1, #45	; 0x2d
 8000870:	f000 f92e 	bl	8000ad0 <lis302dlReadRegister>
 8000874:	4603      	mov	r3, r0
 8000876:	b2da      	uxtb	r2, r3
 8000878:	4b31      	ldr	r3, [pc, #196]	; (8000940 <AccelThread+0x170>)
 800087a:	701a      	strb	r2, [r3, #0]
    /* Current time */
    timebuf[0] = (uint16_t)ST2MS(chVTTimeElapsedSinceX(start));
 800087c:	9802      	ldr	r0, [sp, #8]
 800087e:	f7ff fef7 	bl	8000670 <chVTTimeElapsedSinceX>
 8000882:	4602      	mov	r2, r0
 8000884:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000888:	fb03 f302 	mul.w	r3, r3, r2
 800088c:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 8000890:	330f      	adds	r3, #15
 8000892:	4a2e      	ldr	r2, [pc, #184]	; (800094c <AccelThread+0x17c>)
 8000894:	fba2 2303 	umull	r2, r3, r2, r3
 8000898:	0b5b      	lsrs	r3, r3, #13
 800089a:	b29a      	uxth	r2, r3
 800089c:	4b29      	ldr	r3, [pc, #164]	; (8000944 <AccelThread+0x174>)
 800089e:	801a      	strh	r2, [r3, #0]

    /* Reprogramming the three PWM channels using the accelerometer data.*/
    if (ybuf[0] < 0) {
 80008a0:	4b26      	ldr	r3, [pc, #152]	; (800093c <AccelThread+0x16c>)
 80008a2:	781b      	ldrb	r3, [r3, #0]
 80008a4:	b25b      	sxtb	r3, r3
 80008a6:	2b00      	cmp	r3, #0
 80008a8:	da09      	bge.n	80008be <AccelThread+0xee>
      pwmEnableChannel(&PWMD4, 0, (pwmcnt_t)-ybuf[0]);
 80008aa:	4b24      	ldr	r3, [pc, #144]	; (800093c <AccelThread+0x16c>)
 80008ac:	781b      	ldrb	r3, [r3, #0]
 80008ae:	b25b      	sxtb	r3, r3
 80008b0:	425b      	negs	r3, r3
 80008b2:	4827      	ldr	r0, [pc, #156]	; (8000950 <AccelThread+0x180>)
 80008b4:	2100      	movs	r1, #0
 80008b6:	461a      	mov	r2, r3
 80008b8:	f004 fb2a 	bl	8004f10 <pwmEnableChannel>
 80008bc:	e004      	b.n	80008c8 <AccelThread+0xf8>
      //pwmEnableChannel(&PWMD4, 2, (pwmcnt_t)0);
    }
    else {
      //pwmEnableChannel(&PWMD4, 2, (pwmcnt_t)ybuf[0]);
      pwmEnableChannel(&PWMD4, 0, (pwmcnt_t)0);
 80008be:	4824      	ldr	r0, [pc, #144]	; (8000950 <AccelThread+0x180>)
 80008c0:	2100      	movs	r1, #0
 80008c2:	2200      	movs	r2, #0
 80008c4:	f004 fb24 	bl	8004f10 <pwmEnableChannel>
    }
    if (xbuf[0] < 0) {
 80008c8:	4b1b      	ldr	r3, [pc, #108]	; (8000938 <AccelThread+0x168>)
 80008ca:	781b      	ldrb	r3, [r3, #0]
 80008cc:	b25b      	sxtb	r3, r3
 80008ce:	2b00      	cmp	r3, #0
 80008d0:	da09      	bge.n	80008e6 <AccelThread+0x116>
      pwmEnableChannel(&PWMD4, 1, (pwmcnt_t)-xbuf[0]);
 80008d2:	4b19      	ldr	r3, [pc, #100]	; (8000938 <AccelThread+0x168>)
 80008d4:	781b      	ldrb	r3, [r3, #0]
 80008d6:	b25b      	sxtb	r3, r3
 80008d8:	425b      	negs	r3, r3
 80008da:	481d      	ldr	r0, [pc, #116]	; (8000950 <AccelThread+0x180>)
 80008dc:	2101      	movs	r1, #1
 80008de:	461a      	mov	r2, r3
 80008e0:	f004 fb16 	bl	8004f10 <pwmEnableChannel>
 80008e4:	e004      	b.n	80008f0 <AccelThread+0x120>
      //pwmEnableChannel(&PWMD4, 3, (pwmcnt_t)0);
    }
    else {
      //pwmEnableChannel(&PWMD4, 3, (pwmcnt_t)xbuf[0]);
      pwmEnableChannel(&PWMD4, 1, (pwmcnt_t)0);
 80008e6:	481a      	ldr	r0, [pc, #104]	; (8000950 <AccelThread+0x180>)
 80008e8:	2101      	movs	r1, #1
 80008ea:	2200      	movs	r2, #0
 80008ec:	f004 fb10 	bl	8004f10 <pwmEnableChannel>
    }

    /* Indicate 1 Hz on blue LED */
    if(++readCnt >= 200)
 80008f0:	4b18      	ldr	r3, [pc, #96]	; (8000954 <AccelThread+0x184>)
 80008f2:	781b      	ldrb	r3, [r3, #0]
 80008f4:	3301      	adds	r3, #1
 80008f6:	b2da      	uxtb	r2, r3
 80008f8:	4b16      	ldr	r3, [pc, #88]	; (8000954 <AccelThread+0x184>)
 80008fa:	701a      	strb	r2, [r3, #0]
 80008fc:	4b15      	ldr	r3, [pc, #84]	; (8000954 <AccelThread+0x184>)
 80008fe:	781b      	ldrb	r3, [r3, #0]
 8000900:	2bc7      	cmp	r3, #199	; 0xc7
 8000902:	f67f af73 	bls.w	80007ec <AccelThread+0x1c>
    {
      pwmState = pwmState ? 0x00 : 0xFF; /* toggle */
 8000906:	4b14      	ldr	r3, [pc, #80]	; (8000958 <AccelThread+0x188>)
 8000908:	781b      	ldrb	r3, [r3, #0]
 800090a:	2b00      	cmp	r3, #0
 800090c:	d001      	beq.n	8000912 <AccelThread+0x142>
 800090e:	2200      	movs	r2, #0
 8000910:	e000      	b.n	8000914 <AccelThread+0x144>
 8000912:	22ff      	movs	r2, #255	; 0xff
 8000914:	4b10      	ldr	r3, [pc, #64]	; (8000958 <AccelThread+0x188>)
 8000916:	701a      	strb	r2, [r3, #0]
      pwmEnableChannel(&PWMD4, 3, (pwmcnt_t)pwmState);
 8000918:	4b0f      	ldr	r3, [pc, #60]	; (8000958 <AccelThread+0x188>)
 800091a:	781b      	ldrb	r3, [r3, #0]
 800091c:	b25b      	sxtb	r3, r3
 800091e:	480c      	ldr	r0, [pc, #48]	; (8000950 <AccelThread+0x180>)
 8000920:	2103      	movs	r1, #3
 8000922:	461a      	mov	r2, r3
 8000924:	f004 faf4 	bl	8004f10 <pwmEnableChannel>
      readCnt = 0;
 8000928:	4b0a      	ldr	r3, [pc, #40]	; (8000954 <AccelThread+0x184>)
 800092a:	2200      	movs	r2, #0
 800092c:	701a      	strb	r2, [r3, #0]
 800092e:	e75d      	b.n	80007ec <AccelThread+0x1c>
 8000930:	080062a0 	.word	0x080062a0
 8000934:	20000cac 	.word	0x20000cac
 8000938:	20000c70 	.word	0x20000c70
 800093c:	20000c7c 	.word	0x20000c7c
 8000940:	20000c88 	.word	0x20000c88
 8000944:	20000c94 	.word	0x20000c94
 8000948:	20000bdc 	.word	0x20000bdc
 800094c:	d1b71759 	.word	0xd1b71759
 8000950:	20000c10 	.word	0x20000c10
 8000954:	20000f42 	.word	0x20000f42
 8000958:	20000f43 	.word	0x20000f43
 800095c:	00000000 	.word	0x00000000

08000960 <lis302init>:
   * LIS302DL initialization: X,Y,Z axes with 400Hz rate,
   * enable DataReady signal INT1 (PE0 pin) by setting I1CFG in CTRL_REG3 to "100"
   * Sensor is in "Power down" state until first dummy read
   */
static void lis302init(void)
{
 8000960:	b508      	push	{r3, lr}
  /* Reboot memory content */
  lis302dlWriteRegister(&SPID1, LIS302DL_CTRL_REG2, 0x40);
 8000962:	4819      	ldr	r0, [pc, #100]	; (80009c8 <lis302init+0x68>)
 8000964:	2121      	movs	r1, #33	; 0x21
 8000966:	2240      	movs	r2, #64	; 0x40
 8000968:	f000 f8da 	bl	8000b20 <lis302dlWriteRegister>
  while(lis302dlReadRegister(&SPID1, LIS302DL_CTRL_REG2) & 0x40)
 800096c:	4816      	ldr	r0, [pc, #88]	; (80009c8 <lis302init+0x68>)
 800096e:	2121      	movs	r1, #33	; 0x21
 8000970:	f000 f8ae 	bl	8000ad0 <lis302dlReadRegister>
 8000974:	4603      	mov	r3, r0
 8000976:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800097a:	2b00      	cmp	r3, #0
 800097c:	d1f6      	bne.n	800096c <lis302init+0xc>
    ;

  lis302dlWriteRegister(&SPID1, LIS302DL_CTRL_REG1,
 800097e:	4812      	ldr	r0, [pc, #72]	; (80009c8 <lis302init+0x68>)
 8000980:	2120      	movs	r1, #32
 8000982:	2287      	movs	r2, #135	; 0x87
 8000984:	f000 f8cc 	bl	8000b20 <lis302dlWriteRegister>
           LIS302DL_CTRL_XYZ_EN | LIS302DL_CTRL_400HZ);
  lis302dlWriteRegister(&SPID1, LIS302DL_CTRL_REG3, LIS302DL_CTRL_DATAREADY1);
 8000988:	480f      	ldr	r0, [pc, #60]	; (80009c8 <lis302init+0x68>)
 800098a:	2122      	movs	r1, #34	; 0x22
 800098c:	2204      	movs	r2, #4
 800098e:	f000 f8c7 	bl	8000b20 <lis302dlWriteRegister>

  /* dummy read to put down accelerometer interrupt */
  lis302dlReadRegister(&SPID1, LIS302DL_STATUS_REG);
 8000992:	480d      	ldr	r0, [pc, #52]	; (80009c8 <lis302init+0x68>)
 8000994:	2127      	movs	r1, #39	; 0x27
 8000996:	f000 f89b 	bl	8000ad0 <lis302dlReadRegister>
  lis302dlReadRegister(&SPID1, LIS302DL_OUTX);
 800099a:	480b      	ldr	r0, [pc, #44]	; (80009c8 <lis302init+0x68>)
 800099c:	2129      	movs	r1, #41	; 0x29
 800099e:	f000 f897 	bl	8000ad0 <lis302dlReadRegister>
  lis302dlReadRegister(&SPID1, LIS302DL_OUTY);
 80009a2:	4809      	ldr	r0, [pc, #36]	; (80009c8 <lis302init+0x68>)
 80009a4:	212b      	movs	r1, #43	; 0x2b
 80009a6:	f000 f893 	bl	8000ad0 <lis302dlReadRegister>
  lis302dlReadRegister(&SPID1, LIS302DL_OUTZ);
 80009aa:	4807      	ldr	r0, [pc, #28]	; (80009c8 <lis302init+0x68>)
 80009ac:	212d      	movs	r1, #45	; 0x2d
 80009ae:	f000 f88f 	bl	8000ad0 <lis302dlReadRegister>

  /* enable external interrupt on STM32 */
  extChannelEnable(&EXTD1, 0);  // PE0
 80009b2:	4806      	ldr	r0, [pc, #24]	; (80009cc <lis302init+0x6c>)
 80009b4:	2100      	movs	r1, #0
 80009b6:	f004 fa33 	bl	8004e20 <extChannelEnable>

  /* Power up sensor */
  lis302dlWriteRegister(&SPID1, LIS302DL_CTRL_REG1,
 80009ba:	4803      	ldr	r0, [pc, #12]	; (80009c8 <lis302init+0x68>)
 80009bc:	2120      	movs	r1, #32
 80009be:	22c7      	movs	r2, #199	; 0xc7
 80009c0:	f000 f8ae 	bl	8000b20 <lis302dlWriteRegister>
             LIS302DL_CTRL_XYZ_EN | LIS302DL_CTRL_POWER | LIS302DL_CTRL_400HZ);
}
 80009c4:	bd08      	pop	{r3, pc}
 80009c6:	bf00      	nop
 80009c8:	20000bdc 	.word	0x20000bdc
 80009cc:	20000a04 	.word	0x20000a04

080009d0 <main>:
/*===========================================================================*/

/*
 * Application entry point.
 */
int main(void) {
 80009d0:	b500      	push	{lr}
 80009d2:	b083      	sub	sp, #12
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 80009d4:	f004 f95c 	bl	8004c90 <halInit>
  chSysInit();
 80009d8:	f004 fdaa 	bl	8005530 <chSysInit>
  /*
   * Activates the USB driver and then the USB bus pull-up on D+.
   * Note, a delay is inserted in order to not have to disconnect the cable
   * after a reset.
   */
  usbDisconnectBus(&USBD1);
 80009dc:	4b2c      	ldr	r3, [pc, #176]	; (8000a90 <main+0xc0>)
 80009de:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80009e0:	4a2b      	ldr	r2, [pc, #172]	; (8000a90 <main+0xc0>)
 80009e2:	6d12      	ldr	r2, [r2, #80]	; 0x50
 80009e4:	6b92      	ldr	r2, [r2, #56]	; 0x38
 80009e6:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 80009ea:	639a      	str	r2, [r3, #56]	; 0x38
  chThdSleepMilliseconds(1500);
 80009ec:	f643 2098 	movw	r0, #15000	; 0x3a98
 80009f0:	f005 fa9e 	bl	8005f30 <chThdSleep>
  usbStart(&USBD1, &usbcfg);
 80009f4:	4826      	ldr	r0, [pc, #152]	; (8000a90 <main+0xc0>)
 80009f6:	4927      	ldr	r1, [pc, #156]	; (8000a94 <main+0xc4>)
 80009f8:	f003 fb9a 	bl	8004130 <usbStart>
  usbConnectBus(&USBD1);
 80009fc:	4b24      	ldr	r3, [pc, #144]	; (8000a90 <main+0xc0>)
 80009fe:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8000a00:	4a23      	ldr	r2, [pc, #140]	; (8000a90 <main+0xc0>)
 8000a02:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8000a04:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8000a06:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8000a0a:	639a      	str	r2, [r3, #56]	; 0x38

  /*
   * Initializes the SPI driver 1 in order to access the MEMS. The signals
   * are already initialized in the board file.
   */
  spiStart(&SPID1, &spi1cfg);
 8000a0c:	4822      	ldr	r0, [pc, #136]	; (8000a98 <main+0xc8>)
 8000a0e:	4923      	ldr	r1, [pc, #140]	; (8000a9c <main+0xcc>)
 8000a10:	f003 f85e 	bl	8003ad0 <spiStart>

  /*
   * Initializes the EXT Driver to react to LIS302 interrupt on PE0 pin of Discovery board.
   */
  extStart(&EXTD1, &extcfg);
 8000a14:	4822      	ldr	r0, [pc, #136]	; (8000aa0 <main+0xd0>)
 8000a16:	4923      	ldr	r1, [pc, #140]	; (8000aa4 <main+0xd4>)
 8000a18:	f004 f9ea 	bl	8004df0 <extStart>

  /*
   * Initializes accelerometer with PE0 external interrupt on data ready.
   */
  lis302init();
 8000a1c:	f7ff ffa0 	bl	8000960 <lis302init>

  /*
   * Initializes the PWM driver 4, routes the TIM4 outputs to the board LEDs.
   */
  pwmStart(&PWMD4, &pwmcfg);
 8000a20:	4821      	ldr	r0, [pc, #132]	; (8000aa8 <main+0xd8>)
 8000a22:	4922      	ldr	r1, [pc, #136]	; (8000aac <main+0xdc>)
 8000a24:	f004 fa54 	bl	8004ed0 <pwmStart>
  palSetPadMode(GPIOD, GPIOD_LED4, PAL_MODE_ALTERNATE(2));      /* Green.   */
 8000a28:	4821      	ldr	r0, [pc, #132]	; (8000ab0 <main+0xe0>)
 8000a2a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8000a2e:	f44f 7281 	mov.w	r2, #258	; 0x102
 8000a32:	f002 fdc5 	bl	80035c0 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOD, GPIOD_LED3, PAL_MODE_ALTERNATE(2));      /* Orange.  */
 8000a36:	481e      	ldr	r0, [pc, #120]	; (8000ab0 <main+0xe0>)
 8000a38:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8000a3c:	f44f 7281 	mov.w	r2, #258	; 0x102
 8000a40:	f002 fdbe 	bl	80035c0 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOD, GPIOD_LED5, PAL_MODE_ALTERNATE(2));      /* Red.     */
 8000a44:	481a      	ldr	r0, [pc, #104]	; (8000ab0 <main+0xe0>)
 8000a46:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8000a4a:	f44f 7281 	mov.w	r2, #258	; 0x102
 8000a4e:	f002 fdb7 	bl	80035c0 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOD, GPIOD_LED6, PAL_MODE_ALTERNATE(2));      /* Blue.    */
 8000a52:	4817      	ldr	r0, [pc, #92]	; (8000ab0 <main+0xe0>)
 8000a54:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000a58:	f44f 7281 	mov.w	r2, #258	; 0x102
 8000a5c:	f002 fdb0 	bl	80035c0 <_pal_lld_setgroupmode>

  /*
   * Starting threads.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, AccelThread, NULL);
 8000a60:	2300      	movs	r3, #0
 8000a62:	9300      	str	r3, [sp, #0]
 8000a64:	4813      	ldr	r0, [pc, #76]	; (8000ab4 <main+0xe4>)
 8000a66:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8000a6a:	2240      	movs	r2, #64	; 0x40
 8000a6c:	4b12      	ldr	r3, [pc, #72]	; (8000ab8 <main+0xe8>)
 8000a6e:	f005 fa2f 	bl	8005ed0 <chThdCreateStatic>
  chThdCreateStatic(waWriter, sizeof(waWriter), NORMALPRIO, Writer, NULL);
 8000a72:	2300      	movs	r3, #0
 8000a74:	9300      	str	r3, [sp, #0]
 8000a76:	4811      	ldr	r0, [pc, #68]	; (8000abc <main+0xec>)
 8000a78:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8000a7c:	2240      	movs	r2, #64	; 0x40
 8000a7e:	4b10      	ldr	r3, [pc, #64]	; (8000ac0 <main+0xf0>)
 8000a80:	f005 fa26 	bl	8005ed0 <chThdCreateStatic>

  /*
   * Normal main() thread activity
   */
  while (true) {
    chThdSleepMilliseconds(200);
 8000a84:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8000a88:	f005 fa52 	bl	8005f30 <chThdSleep>
 8000a8c:	e7fa      	b.n	8000a84 <main+0xb4>
 8000a8e:	bf00      	nop
 8000a90:	20000a10 	.word	0x20000a10
 8000a94:	08006e30 	.word	0x08006e30
 8000a98:	20000bdc 	.word	0x20000bdc
 8000a9c:	08006e80 	.word	0x08006e80
 8000aa0:	20000a04 	.word	0x20000a04
 8000aa4:	08006e90 	.word	0x08006e90
 8000aa8:	20000c10 	.word	0x20000c10
 8000aac:	08006e40 	.word	0x08006e40
 8000ab0:	40020c00 	.word	0x40020c00
 8000ab4:	20000df8 	.word	0x20000df8
 8000ab8:	080007d1 	.word	0x080007d1
 8000abc:	20000cb0 	.word	0x20000cb0
 8000ac0:	080006f1 	.word	0x080006f1
	...

08000ad0 <lis302dlReadRegister>:
 *
 * @param[in] spip      pointer to the SPI initerface
 * @param[in] reg       register number
 * @return              The register value.
 */
uint8_t lis302dlReadRegister(SPIDriver *spip, uint8_t reg) {
 8000ad0:	b500      	push	{lr}
 8000ad2:	b083      	sub	sp, #12
 8000ad4:	9001      	str	r0, [sp, #4]
 8000ad6:	460b      	mov	r3, r1
 8000ad8:	f88d 3003 	strb.w	r3, [sp, #3]

  spiSelect(spip);
 8000adc:	9801      	ldr	r0, [sp, #4]
 8000ade:	f003 f80f 	bl	8003b00 <spiSelect>
  txbuf[0] = 0x80 | reg;
 8000ae2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000ae6:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8000aea:	b2da      	uxtb	r2, r3
 8000aec:	4b09      	ldr	r3, [pc, #36]	; (8000b14 <lis302dlReadRegister+0x44>)
 8000aee:	701a      	strb	r2, [r3, #0]
  txbuf[1] = 0xff;
 8000af0:	4b08      	ldr	r3, [pc, #32]	; (8000b14 <lis302dlReadRegister+0x44>)
 8000af2:	22ff      	movs	r2, #255	; 0xff
 8000af4:	705a      	strb	r2, [r3, #1]
  spiExchange(spip, 2, txbuf, rxbuf);
 8000af6:	9801      	ldr	r0, [sp, #4]
 8000af8:	2102      	movs	r1, #2
 8000afa:	4a06      	ldr	r2, [pc, #24]	; (8000b14 <lis302dlReadRegister+0x44>)
 8000afc:	4b06      	ldr	r3, [pc, #24]	; (8000b18 <lis302dlReadRegister+0x48>)
 8000afe:	f003 f81f 	bl	8003b40 <spiExchange>
  spiUnselect(spip);
 8000b02:	9801      	ldr	r0, [sp, #4]
 8000b04:	f003 f80c 	bl	8003b20 <spiUnselect>
  return rxbuf[1];
 8000b08:	4b03      	ldr	r3, [pc, #12]	; (8000b18 <lis302dlReadRegister+0x48>)
 8000b0a:	785b      	ldrb	r3, [r3, #1]
}
 8000b0c:	4618      	mov	r0, r3
 8000b0e:	b003      	add	sp, #12
 8000b10:	f85d fb04 	ldr.w	pc, [sp], #4
 8000b14:	20000c2c 	.word	0x20000c2c
 8000b18:	20000c30 	.word	0x20000c30
 8000b1c:	00000000 	.word	0x00000000

08000b20 <lis302dlWriteRegister>:
 *
 * @param[in] spip      pointer to the SPI initerface
 * @param[in] reg       register number
 * @param[in] value     the value to be written
 */
void lis302dlWriteRegister(SPIDriver *spip, uint8_t reg, uint8_t value) {
 8000b20:	b500      	push	{lr}
 8000b22:	b083      	sub	sp, #12
 8000b24:	9001      	str	r0, [sp, #4]
 8000b26:	460b      	mov	r3, r1
 8000b28:	f88d 3003 	strb.w	r3, [sp, #3]
 8000b2c:	4613      	mov	r3, r2
 8000b2e:	f88d 3002 	strb.w	r3, [sp, #2]

  switch (reg) {
 8000b32:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000b36:	3b0f      	subs	r3, #15
 8000b38:	2b30      	cmp	r3, #48	; 0x30
 8000b3a:	d878      	bhi.n	8000c2e <lis302dlWriteRegister+0x10e>
 8000b3c:	a201      	add	r2, pc, #4	; (adr r2, 8000b44 <lis302dlWriteRegister+0x24>)
 8000b3e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000b42:	bf00      	nop
 8000b44:	08000c2f 	.word	0x08000c2f
 8000b48:	08000c2f 	.word	0x08000c2f
 8000b4c:	08000c2f 	.word	0x08000c2f
 8000b50:	08000c2f 	.word	0x08000c2f
 8000b54:	08000c2f 	.word	0x08000c2f
 8000b58:	08000c2f 	.word	0x08000c2f
 8000b5c:	08000c2f 	.word	0x08000c2f
 8000b60:	08000c2f 	.word	0x08000c2f
 8000b64:	08000c2f 	.word	0x08000c2f
 8000b68:	08000c2f 	.word	0x08000c2f
 8000b6c:	08000c2f 	.word	0x08000c2f
 8000b70:	08000c2f 	.word	0x08000c2f
 8000b74:	08000c2f 	.word	0x08000c2f
 8000b78:	08000c2f 	.word	0x08000c2f
 8000b7c:	08000c2f 	.word	0x08000c2f
 8000b80:	08000c2f 	.word	0x08000c2f
 8000b84:	08000c2f 	.word	0x08000c2f
 8000b88:	08000c09 	.word	0x08000c09
 8000b8c:	08000c09 	.word	0x08000c09
 8000b90:	08000c09 	.word	0x08000c09
 8000b94:	08000c2f 	.word	0x08000c2f
 8000b98:	08000c2f 	.word	0x08000c2f
 8000b9c:	08000c2f 	.word	0x08000c2f
 8000ba0:	08000c2f 	.word	0x08000c2f
 8000ba4:	08000c2f 	.word	0x08000c2f
 8000ba8:	08000c2f 	.word	0x08000c2f
 8000bac:	08000c2f 	.word	0x08000c2f
 8000bb0:	08000c2f 	.word	0x08000c2f
 8000bb4:	08000c2f 	.word	0x08000c2f
 8000bb8:	08000c2f 	.word	0x08000c2f
 8000bbc:	08000c2f 	.word	0x08000c2f
 8000bc0:	08000c2f 	.word	0x08000c2f
 8000bc4:	08000c2f 	.word	0x08000c2f
 8000bc8:	08000c09 	.word	0x08000c09
 8000bcc:	08000c2f 	.word	0x08000c2f
 8000bd0:	08000c09 	.word	0x08000c09
 8000bd4:	08000c09 	.word	0x08000c09
 8000bd8:	08000c09 	.word	0x08000c09
 8000bdc:	08000c2f 	.word	0x08000c2f
 8000be0:	08000c09 	.word	0x08000c09
 8000be4:	08000c09 	.word	0x08000c09
 8000be8:	08000c09 	.word	0x08000c09
 8000bec:	08000c2f 	.word	0x08000c2f
 8000bf0:	08000c2f 	.word	0x08000c2f
 8000bf4:	08000c09 	.word	0x08000c09
 8000bf8:	08000c09 	.word	0x08000c09
 8000bfc:	08000c09 	.word	0x08000c09
 8000c00:	08000c09 	.word	0x08000c09
 8000c04:	08000c09 	.word	0x08000c09
  case LIS302DL_CLICK_THSY_X:
  case LIS302DL_CLICK_THSZ:
  case LIS302DL_CLICK_TIMELIMIT:
  case LIS302DL_CLICK_LATENCY:
  case LIS302DL_CLICK_WINDOW:
    spiSelect(spip);
 8000c08:	9801      	ldr	r0, [sp, #4]
 8000c0a:	f002 ff79 	bl	8003b00 <spiSelect>
    txbuf[0] = reg;
 8000c0e:	4a09      	ldr	r2, [pc, #36]	; (8000c34 <lis302dlWriteRegister+0x114>)
 8000c10:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000c14:	7013      	strb	r3, [r2, #0]
    txbuf[1] = value;
 8000c16:	4a07      	ldr	r2, [pc, #28]	; (8000c34 <lis302dlWriteRegister+0x114>)
 8000c18:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8000c1c:	7053      	strb	r3, [r2, #1]
    spiSend(spip, 2, txbuf);
 8000c1e:	9801      	ldr	r0, [sp, #4]
 8000c20:	2102      	movs	r1, #2
 8000c22:	4a04      	ldr	r2, [pc, #16]	; (8000c34 <lis302dlWriteRegister+0x114>)
 8000c24:	f002 ffac 	bl	8003b80 <spiSend>
    spiUnselect(spip);
 8000c28:	9801      	ldr	r0, [sp, #4]
 8000c2a:	f002 ff79 	bl	8003b20 <spiUnselect>
  }
}
 8000c2e:	b003      	add	sp, #12
 8000c30:	f85d fb04 	ldr.w	pc, [sp], #4
 8000c34:	20000c2c 	.word	0x20000c2c
	...

08000c40 <usb_lld_pump>:
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 8000c40:	b500      	push	{lr}
 8000c42:	b089      	sub	sp, #36	; 0x24
 8000c44:	9001      	str	r0, [sp, #4]
  USBDriver *usbp = (USBDriver *)p;
 8000c46:	9b01      	ldr	r3, [sp, #4]
 8000c48:	9306      	str	r3, [sp, #24]
  stm32_otg_t *otgp = usbp->otg;
 8000c4a:	9b06      	ldr	r3, [sp, #24]
 8000c4c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8000c4e:	9305      	str	r3, [sp, #20]

#if defined(_CHIBIOS_RT_)
  chRegSetThreadName("usb_lld_pump");
 8000c50:	483d      	ldr	r0, [pc, #244]	; (8000d48 <usb_lld_pump+0x108>)
 8000c52:	f002 fdbd 	bl	80037d0 <chRegSetThreadName.lto_priv.159>
#endif
  osalSysLock();
 8000c56:	f002 fdcb 	bl	80037f0 <osalSysLock.lto_priv.154>
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 8000c5a:	9b06      	ldr	r3, [sp, #24]
 8000c5c:	781b      	ldrb	r3, [r3, #0]
 8000c5e:	2b01      	cmp	r3, #1
 8000c60:	d009      	beq.n	8000c76 <usb_lld_pump+0x36>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 8000c62:	9b06      	ldr	r3, [sp, #24]
 8000c64:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 8000c66:	2b00      	cmp	r3, #0
 8000c68:	d110      	bne.n	8000c8c <usb_lld_pump+0x4c>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 8000c6a:	9b05      	ldr	r3, [sp, #20]
 8000c6c:	695b      	ldr	r3, [r3, #20]
 8000c6e:	f003 0310 	and.w	r3, r3, #16
 8000c72:	2b00      	cmp	r3, #0
 8000c74:	d10a      	bne.n	8000c8c <usb_lld_pump+0x4c>
      otgp->GINTMSK |= GINTMSK_RXFLVLM;
 8000c76:	9b05      	ldr	r3, [sp, #20]
 8000c78:	699b      	ldr	r3, [r3, #24]
 8000c7a:	f043 0210 	orr.w	r2, r3, #16
 8000c7e:	9b05      	ldr	r3, [sp, #20]
 8000c80:	619a      	str	r2, [r3, #24]
      osalThreadSuspendS(&usbp->wait);
 8000c82:	9b06      	ldr	r3, [sp, #24]
 8000c84:	3360      	adds	r3, #96	; 0x60
 8000c86:	4618      	mov	r0, r3
 8000c88:	f002 fde2 	bl	8003850 <osalThreadSuspendS.lto_priv.158>
    }
    osalSysUnlock();
 8000c8c:	f002 fdb8 	bl	8003800 <osalSysUnlock.lto_priv.155>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8000c90:	2300      	movs	r3, #0
 8000c92:	f88d 301f 	strb.w	r3, [sp, #31]
 8000c96:	e04c      	b.n	8000d32 <usb_lld_pump+0xf2>

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
        otg_rxfifo_handler(usbp);
 8000c98:	9806      	ldr	r0, [sp, #24]
 8000c9a:	f000 fc01 	bl	80014a0 <otg_rxfifo_handler.lto_priv.157>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 8000c9e:	9b05      	ldr	r3, [sp, #20]
 8000ca0:	695b      	ldr	r3, [r3, #20]
 8000ca2:	f003 0310 	and.w	r3, r3, #16
 8000ca6:	2b00      	cmp	r3, #0
 8000ca8:	d1f6      	bne.n	8000c98 <usb_lld_pump+0x58>
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 8000caa:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8000cae:	2201      	movs	r2, #1
 8000cb0:	fa02 f303 	lsl.w	r3, r2, r3
 8000cb4:	9304      	str	r3, [sp, #16]
      if (usbp->txpending & epmask) {
 8000cb6:	9b06      	ldr	r3, [sp, #24]
 8000cb8:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8000cba:	9b04      	ldr	r3, [sp, #16]
 8000cbc:	4013      	ands	r3, r2
 8000cbe:	2b00      	cmp	r3, #0
 8000cc0:	d032      	beq.n	8000d28 <usb_lld_pump+0xe8>
        bool done;

        osalSysLock();
 8000cc2:	f002 fd95 	bl	80037f0 <osalSysLock.lto_priv.154>
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 8000cc6:	9b05      	ldr	r3, [sp, #20]
 8000cc8:	689b      	ldr	r3, [r3, #8]
 8000cca:	f023 0201 	bic.w	r2, r3, #1
 8000cce:	9b05      	ldr	r3, [sp, #20]
 8000cd0:	609a      	str	r2, [r3, #8]
        usbp->txpending &= ~epmask;
 8000cd2:	9b06      	ldr	r3, [sp, #24]
 8000cd4:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8000cd6:	9b04      	ldr	r3, [sp, #16]
 8000cd8:	43db      	mvns	r3, r3
 8000cda:	401a      	ands	r2, r3
 8000cdc:	9b06      	ldr	r3, [sp, #24]
 8000cde:	65da      	str	r2, [r3, #92]	; 0x5c
        osalSysUnlock();
 8000ce0:	f002 fd8e 	bl	8003800 <osalSysUnlock.lto_priv.155>

        done = otg_txfifo_handler(usbp, ep);
 8000ce4:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8000ce8:	9806      	ldr	r0, [sp, #24]
 8000cea:	4619      	mov	r1, r3
 8000cec:	f000 fc60 	bl	80015b0 <otg_txfifo_handler.lto_priv.156>
 8000cf0:	4603      	mov	r3, r0
 8000cf2:	f88d 300f 	strb.w	r3, [sp, #15]

        osalSysLock();
 8000cf6:	f002 fd7b 	bl	80037f0 <osalSysLock.lto_priv.154>
        otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8000cfa:	9b05      	ldr	r3, [sp, #20]
 8000cfc:	689b      	ldr	r3, [r3, #8]
 8000cfe:	f043 0201 	orr.w	r2, r3, #1
 8000d02:	9b05      	ldr	r3, [sp, #20]
 8000d04:	609a      	str	r2, [r3, #8]
        if (!done)
 8000d06:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8000d0a:	f083 0301 	eor.w	r3, r3, #1
 8000d0e:	b2db      	uxtb	r3, r3
 8000d10:	2b00      	cmp	r3, #0
 8000d12:	d007      	beq.n	8000d24 <usb_lld_pump+0xe4>
          otgp->DIEPEMPMSK |= epmask;
 8000d14:	9b05      	ldr	r3, [sp, #20]
 8000d16:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8000d1a:	9b04      	ldr	r3, [sp, #16]
 8000d1c:	431a      	orrs	r2, r3
 8000d1e:	9b05      	ldr	r3, [sp, #20]
 8000d20:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
        osalSysUnlock();
 8000d24:	f002 fd6c 	bl	8003800 <osalSysUnlock.lto_priv.155>
      osalThreadSuspendS(&usbp->wait);
    }
    osalSysUnlock();

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8000d28:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8000d2c:	3301      	adds	r3, #1
 8000d2e:	f88d 301f 	strb.w	r3, [sp, #31]
 8000d32:	f89d 201f 	ldrb.w	r2, [sp, #31]
 8000d36:	9b06      	ldr	r3, [sp, #24]
 8000d38:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8000d3a:	689b      	ldr	r3, [r3, #8]
 8000d3c:	429a      	cmp	r2, r3
 8000d3e:	d9ae      	bls.n	8000c9e <usb_lld_pump+0x5e>
        if (!done)
          otgp->DIEPEMPMSK |= epmask;
        osalSysUnlock();
      }
    }
    osalSysLock();
 8000d40:	f002 fd56 	bl	80037f0 <osalSysLock.lto_priv.154>
 8000d44:	e789      	b.n	8000c5a <usb_lld_pump+0x1a>
 8000d46:	bf00      	nop
 8000d48:	080062b0 	.word	0x080062b0
 8000d4c:	00000000 	.word	0x00000000

08000d50 <port_lock.lto_priv.142>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000d50:	b082      	sub	sp, #8
 8000d52:	2320      	movs	r3, #32
 8000d54:	9301      	str	r3, [sp, #4]
 8000d56:	9b01      	ldr	r3, [sp, #4]
 8000d58:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000d5c:	b002      	add	sp, #8
 8000d5e:	4770      	bx	lr

08000d60 <port_unlock.lto_priv.139>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000d60:	b082      	sub	sp, #8
 8000d62:	2300      	movs	r3, #0
 8000d64:	9301      	str	r3, [sp, #4]
 8000d66:	9b01      	ldr	r3, [sp, #4]
 8000d68:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000d6c:	b002      	add	sp, #8
 8000d6e:	4770      	bx	lr

08000d70 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000d70:	b508      	push	{r3, lr}

  port_lock();
 8000d72:	f7ff ffed 	bl	8000d50 <port_lock.lto_priv.142>
}
 8000d76:	bd08      	pop	{r3, pc}
	...

08000d80 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000d80:	b508      	push	{r3, lr}

  port_unlock();
 8000d82:	f7ff ffed 	bl	8000d60 <port_unlock.lto_priv.139>
}
 8000d86:	bd08      	pop	{r3, pc}
	...

08000d90 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000d90:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000d92:	f7ff ffed 	bl	8000d70 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8000d96:	bd08      	pop	{r3, pc}
	...

08000da0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000da0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000da2:	f7ff ffed 	bl	8000d80 <port_unlock_from_isr>
}
 8000da6:	bd08      	pop	{r3, pc}
	...

08000db0 <osalSysHalt>:
 *
 * @param[in] reason    the halt message pointer
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {
 8000db0:	b500      	push	{lr}
 8000db2:	b083      	sub	sp, #12
 8000db4:	9001      	str	r0, [sp, #4]

  chSysHalt(reason);
 8000db6:	9801      	ldr	r0, [sp, #4]
 8000db8:	f004 fbfa 	bl	80055b0 <chSysHalt>
}
 8000dbc:	b003      	add	sp, #12
 8000dbe:	f85d fb04 	ldr.w	pc, [sp], #4
 8000dc2:	bf00      	nop
	...

08000dd0 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8000dd0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8000dd2:	f7ff ffdd 	bl	8000d90 <chSysLockFromISR>
}
 8000dd6:	bd08      	pop	{r3, pc}
	...

08000de0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8000de0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8000de2:	f7ff ffdd 	bl	8000da0 <chSysUnlockFromISR>
}
 8000de6:	bd08      	pop	{r3, pc}
	...

08000df0 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8000df0:	b500      	push	{lr}
 8000df2:	b083      	sub	sp, #12
 8000df4:	9001      	str	r0, [sp, #4]
 8000df6:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 8000df8:	9801      	ldr	r0, [sp, #4]
 8000dfa:	9900      	ldr	r1, [sp, #0]
 8000dfc:	f005 f920 	bl	8006040 <chThdResumeI>
}
 8000e00:	b003      	add	sp, #12
 8000e02:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e06:	bf00      	nop
	...

08000e10 <spi_lld_serve_rx_interrupt>:
 * @brief   Shared end-of-rx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 8000e10:	b500      	push	{lr}
 8000e12:	b083      	sub	sp, #12
 8000e14:	9001      	str	r0, [sp, #4]
 8000e16:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000e18:	9b00      	ldr	r3, [sp, #0]
 8000e1a:	f003 030c 	and.w	r3, r3, #12
 8000e1e:	2b00      	cmp	r3, #0
 8000e20:	d002      	beq.n	8000e28 <spi_lld_serve_rx_interrupt+0x18>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 8000e22:	4830      	ldr	r0, [pc, #192]	; (8000ee4 <spi_lld_serve_rx_interrupt+0xd4>)
 8000e24:	f7ff ffc4 	bl	8000db0 <osalSysHalt>
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 8000e28:	9b01      	ldr	r3, [sp, #4]
 8000e2a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000e2c:	681b      	ldr	r3, [r3, #0]
 8000e2e:	9a01      	ldr	r2, [sp, #4]
 8000e30:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8000e32:	6812      	ldr	r2, [r2, #0]
 8000e34:	6812      	ldr	r2, [r2, #0]
 8000e36:	f022 021f 	bic.w	r2, r2, #31
 8000e3a:	601a      	str	r2, [r3, #0]
 8000e3c:	9b01      	ldr	r3, [sp, #4]
 8000e3e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000e40:	681b      	ldr	r3, [r3, #0]
 8000e42:	681b      	ldr	r3, [r3, #0]
 8000e44:	f003 0301 	and.w	r3, r3, #1
 8000e48:	2b00      	cmp	r3, #0
 8000e4a:	d1f7      	bne.n	8000e3c <spi_lld_serve_rx_interrupt+0x2c>
 8000e4c:	9b01      	ldr	r3, [sp, #4]
 8000e4e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000e50:	685b      	ldr	r3, [r3, #4]
 8000e52:	9a01      	ldr	r2, [sp, #4]
 8000e54:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8000e56:	7a12      	ldrb	r2, [r2, #8]
 8000e58:	4611      	mov	r1, r2
 8000e5a:	223d      	movs	r2, #61	; 0x3d
 8000e5c:	408a      	lsls	r2, r1
 8000e5e:	601a      	str	r2, [r3, #0]
  dmaStreamDisable(spip->dmarx);
 8000e60:	9b01      	ldr	r3, [sp, #4]
 8000e62:	6a1b      	ldr	r3, [r3, #32]
 8000e64:	681b      	ldr	r3, [r3, #0]
 8000e66:	9a01      	ldr	r2, [sp, #4]
 8000e68:	6a12      	ldr	r2, [r2, #32]
 8000e6a:	6812      	ldr	r2, [r2, #0]
 8000e6c:	6812      	ldr	r2, [r2, #0]
 8000e6e:	f022 021f 	bic.w	r2, r2, #31
 8000e72:	601a      	str	r2, [r3, #0]
 8000e74:	9b01      	ldr	r3, [sp, #4]
 8000e76:	6a1b      	ldr	r3, [r3, #32]
 8000e78:	681b      	ldr	r3, [r3, #0]
 8000e7a:	681b      	ldr	r3, [r3, #0]
 8000e7c:	f003 0301 	and.w	r3, r3, #1
 8000e80:	2b00      	cmp	r3, #0
 8000e82:	d1f7      	bne.n	8000e74 <spi_lld_serve_rx_interrupt+0x64>
 8000e84:	9b01      	ldr	r3, [sp, #4]
 8000e86:	6a1b      	ldr	r3, [r3, #32]
 8000e88:	685b      	ldr	r3, [r3, #4]
 8000e8a:	9a01      	ldr	r2, [sp, #4]
 8000e8c:	6a12      	ldr	r2, [r2, #32]
 8000e8e:	7a12      	ldrb	r2, [r2, #8]
 8000e90:	4611      	mov	r1, r2
 8000e92:	223d      	movs	r2, #61	; 0x3d
 8000e94:	408a      	lsls	r2, r1
 8000e96:	601a      	str	r2, [r3, #0]

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 8000e98:	9b01      	ldr	r3, [sp, #4]
 8000e9a:	685b      	ldr	r3, [r3, #4]
 8000e9c:	681b      	ldr	r3, [r3, #0]
 8000e9e:	2b00      	cmp	r3, #0
 8000ea0:	d00f      	beq.n	8000ec2 <spi_lld_serve_rx_interrupt+0xb2>
 8000ea2:	9b01      	ldr	r3, [sp, #4]
 8000ea4:	2204      	movs	r2, #4
 8000ea6:	701a      	strb	r2, [r3, #0]
 8000ea8:	9b01      	ldr	r3, [sp, #4]
 8000eaa:	685b      	ldr	r3, [r3, #4]
 8000eac:	681b      	ldr	r3, [r3, #0]
 8000eae:	9801      	ldr	r0, [sp, #4]
 8000eb0:	4798      	blx	r3
 8000eb2:	9b01      	ldr	r3, [sp, #4]
 8000eb4:	781b      	ldrb	r3, [r3, #0]
 8000eb6:	2b04      	cmp	r3, #4
 8000eb8:	d106      	bne.n	8000ec8 <spi_lld_serve_rx_interrupt+0xb8>
 8000eba:	9b01      	ldr	r3, [sp, #4]
 8000ebc:	2202      	movs	r2, #2
 8000ebe:	701a      	strb	r2, [r3, #0]
 8000ec0:	e002      	b.n	8000ec8 <spi_lld_serve_rx_interrupt+0xb8>
 8000ec2:	9b01      	ldr	r3, [sp, #4]
 8000ec4:	2202      	movs	r2, #2
 8000ec6:	701a      	strb	r2, [r3, #0]
 8000ec8:	f7ff ff82 	bl	8000dd0 <osalSysLockFromISR>
 8000ecc:	9b01      	ldr	r3, [sp, #4]
 8000ece:	3308      	adds	r3, #8
 8000ed0:	4618      	mov	r0, r3
 8000ed2:	2100      	movs	r1, #0
 8000ed4:	f7ff ff8c 	bl	8000df0 <osalThreadResumeI>
 8000ed8:	f7ff ff82 	bl	8000de0 <osalSysUnlockFromISR>
}
 8000edc:	b003      	add	sp, #12
 8000ede:	f85d fb04 	ldr.w	pc, [sp], #4
 8000ee2:	bf00      	nop
 8000ee4:	080062c0 	.word	0x080062c0
	...

08000ef0 <spi_lld_serve_tx_interrupt>:
 * @brief   Shared end-of-tx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
 8000ef0:	b500      	push	{lr}
 8000ef2:	b083      	sub	sp, #12
 8000ef4:	9001      	str	r0, [sp, #4]
 8000ef6:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000ef8:	9b00      	ldr	r3, [sp, #0]
 8000efa:	f003 030c 	and.w	r3, r3, #12
 8000efe:	2b00      	cmp	r3, #0
 8000f00:	d002      	beq.n	8000f08 <spi_lld_serve_tx_interrupt+0x18>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 8000f02:	4803      	ldr	r0, [pc, #12]	; (8000f10 <spi_lld_serve_tx_interrupt+0x20>)
 8000f04:	f7ff ff54 	bl	8000db0 <osalSysHalt>
  }
#else
  (void)spip;
  (void)flags;
#endif
}
 8000f08:	b003      	add	sp, #12
 8000f0a:	f85d fb04 	ldr.w	pc, [sp], #4
 8000f0e:	bf00      	nop
 8000f10:	080062c0 	.word	0x080062c0
	...

08000f20 <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
 8000f20:	b508      	push	{r3, lr}

  dummytx = 0xFFFF;
 8000f22:	4b0b      	ldr	r3, [pc, #44]	; (8000f50 <spi_lld_init+0x30>)
 8000f24:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8000f28:	801a      	strh	r2, [r3, #0]

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
 8000f2a:	480a      	ldr	r0, [pc, #40]	; (8000f54 <spi_lld_init+0x34>)
 8000f2c:	f002 fdb8 	bl	8003aa0 <spiObjectInit>
  SPID1.spi       = SPI1;
 8000f30:	4b08      	ldr	r3, [pc, #32]	; (8000f54 <spi_lld_init+0x34>)
 8000f32:	4a09      	ldr	r2, [pc, #36]	; (8000f58 <spi_lld_init+0x38>)
 8000f34:	61da      	str	r2, [r3, #28]
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 8000f36:	4b07      	ldr	r3, [pc, #28]	; (8000f54 <spi_lld_init+0x34>)
 8000f38:	4a08      	ldr	r2, [pc, #32]	; (8000f5c <spi_lld_init+0x3c>)
 8000f3a:	621a      	str	r2, [r3, #32]
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 8000f3c:	4b05      	ldr	r3, [pc, #20]	; (8000f54 <spi_lld_init+0x34>)
 8000f3e:	4a08      	ldr	r2, [pc, #32]	; (8000f60 <spi_lld_init+0x40>)
 8000f40:	625a      	str	r2, [r3, #36]	; 0x24
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 8000f42:	4b04      	ldr	r3, [pc, #16]	; (8000f54 <spi_lld_init+0x34>)
 8000f44:	4a07      	ldr	r2, [pc, #28]	; (8000f64 <spi_lld_init+0x44>)
 8000f46:	629a      	str	r2, [r3, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 8000f48:	4b02      	ldr	r3, [pc, #8]	; (8000f54 <spi_lld_init+0x34>)
 8000f4a:	4a07      	ldr	r2, [pc, #28]	; (8000f68 <spi_lld_init+0x48>)
 8000f4c:	62da      	str	r2, [r3, #44]	; 0x2c
                    STM32_DMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_M2P |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif
}
 8000f4e:	bd08      	pop	{r3, pc}
 8000f50:	20000c0c 	.word	0x20000c0c
 8000f54:	20000bdc 	.word	0x20000bdc
 8000f58:	40013000 	.word	0x40013000
 8000f5c:	08006b10 	.word	0x08006b10
 8000f60:	08006b34 	.word	0x08006b34
 8000f64:	06010016 	.word	0x06010016
 8000f68:	06010046 	.word	0x06010046
 8000f6c:	00000000 	.word	0x00000000

08000f70 <spi_lld_start>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {
 8000f70:	b500      	push	{lr}
 8000f72:	b085      	sub	sp, #20
 8000f74:	9001      	str	r0, [sp, #4]

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 8000f76:	9b01      	ldr	r3, [sp, #4]
 8000f78:	781b      	ldrb	r3, [r3, #0]
 8000f7a:	2b01      	cmp	r3, #1
 8000f7c:	d12d      	bne.n	8000fda <spi_lld_start+0x6a>
#if STM32_SPI_USE_SPI1
    if (&SPID1 == spip) {
 8000f7e:	9b01      	ldr	r3, [sp, #4]
 8000f80:	4a36      	ldr	r2, [pc, #216]	; (800105c <spi_lld_start+0xec>)
 8000f82:	4293      	cmp	r3, r2
 8000f84:	d11b      	bne.n	8000fbe <spi_lld_start+0x4e>
      bool b;
      b = dmaStreamAllocate(spip->dmarx,
 8000f86:	9b01      	ldr	r3, [sp, #4]
 8000f88:	6a1b      	ldr	r3, [r3, #32]
 8000f8a:	4618      	mov	r0, r3
 8000f8c:	210a      	movs	r1, #10
 8000f8e:	4a34      	ldr	r2, [pc, #208]	; (8001060 <spi_lld_start+0xf0>)
 8000f90:	9b01      	ldr	r3, [sp, #4]
 8000f92:	f001 fdbd 	bl	8002b10 <dmaStreamAllocate>
 8000f96:	4603      	mov	r3, r0
 8000f98:	f88d 300f 	strb.w	r3, [sp, #15]
                            STM32_SPI_SPI1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(spip->dmatx,
 8000f9c:	9b01      	ldr	r3, [sp, #4]
 8000f9e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000fa0:	4618      	mov	r0, r3
 8000fa2:	210a      	movs	r1, #10
 8000fa4:	4a2f      	ldr	r2, [pc, #188]	; (8001064 <spi_lld_start+0xf4>)
 8000fa6:	9b01      	ldr	r3, [sp, #4]
 8000fa8:	f001 fdb2 	bl	8002b10 <dmaStreamAllocate>
 8000fac:	4603      	mov	r3, r0
 8000fae:	f88d 300f 	strb.w	r3, [sp, #15]
                            STM32_SPI_SPI1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI1(FALSE);
 8000fb2:	4a2d      	ldr	r2, [pc, #180]	; (8001068 <spi_lld_start+0xf8>)
 8000fb4:	4b2c      	ldr	r3, [pc, #176]	; (8001068 <spi_lld_start+0xf8>)
 8000fb6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000fb8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8000fbc:	6453      	str	r3, [r2, #68]	; 0x44
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 8000fbe:	9b01      	ldr	r3, [sp, #4]
 8000fc0:	6a1b      	ldr	r3, [r3, #32]
 8000fc2:	681b      	ldr	r3, [r3, #0]
 8000fc4:	9a01      	ldr	r2, [sp, #4]
 8000fc6:	69d2      	ldr	r2, [r2, #28]
 8000fc8:	320c      	adds	r2, #12
 8000fca:	609a      	str	r2, [r3, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 8000fcc:	9b01      	ldr	r3, [sp, #4]
 8000fce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000fd0:	681b      	ldr	r3, [r3, #0]
 8000fd2:	9a01      	ldr	r2, [sp, #4]
 8000fd4:	69d2      	ldr	r2, [r2, #28]
 8000fd6:	320c      	adds	r2, #12
 8000fd8:	609a      	str	r2, [r3, #8]
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 8000fda:	9b01      	ldr	r3, [sp, #4]
 8000fdc:	685b      	ldr	r3, [r3, #4]
 8000fde:	895b      	ldrh	r3, [r3, #10]
 8000fe0:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8000fe4:	2b00      	cmp	r3, #0
 8000fe6:	d10c      	bne.n	8001002 <spi_lld_start+0x92>
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8000fe8:	9b01      	ldr	r3, [sp, #4]
 8000fea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 8000fec:	f423 42f0 	bic.w	r2, r3, #30720	; 0x7800
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8000ff0:	9b01      	ldr	r3, [sp, #4]
 8000ff2:	629a      	str	r2, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8000ff4:	9b01      	ldr	r3, [sp, #4]
 8000ff6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 8000ff8:	f423 42f0 	bic.w	r2, r3, #30720	; 0x7800
  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8000ffc:	9b01      	ldr	r3, [sp, #4]
 8000ffe:	62da      	str	r2, [r3, #44]	; 0x2c
 8001000:	e00f      	b.n	8001022 <spi_lld_start+0xb2>
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8001002:	9b01      	ldr	r3, [sp, #4]
 8001004:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001006:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 800100a:	f443 5220 	orr.w	r2, r3, #10240	; 0x2800
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800100e:	9b01      	ldr	r3, [sp, #4]
 8001010:	629a      	str	r2, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8001012:	9b01      	ldr	r3, [sp, #4]
 8001014:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001016:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 800101a:	f443 5220 	orr.w	r2, r3, #10240	; 0x2800
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800101e:	9b01      	ldr	r3, [sp, #4]
 8001020:	62da      	str	r2, [r3, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
 8001022:	9b01      	ldr	r3, [sp, #4]
 8001024:	69db      	ldr	r3, [r3, #28]
 8001026:	2200      	movs	r2, #0
 8001028:	601a      	str	r2, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 800102a:	9b01      	ldr	r3, [sp, #4]
 800102c:	69db      	ldr	r3, [r3, #28]
 800102e:	9a01      	ldr	r2, [sp, #4]
 8001030:	6852      	ldr	r2, [r2, #4]
 8001032:	8952      	ldrh	r2, [r2, #10]
 8001034:	f442 7241 	orr.w	r2, r2, #772	; 0x304
 8001038:	b292      	uxth	r2, r2
 800103a:	601a      	str	r2, [r3, #0]
                    SPI_CR1_SSI;
  spip->spi->CR2  = SPI_CR2_SSOE | SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
 800103c:	9b01      	ldr	r3, [sp, #4]
 800103e:	69db      	ldr	r3, [r3, #28]
 8001040:	2207      	movs	r2, #7
 8001042:	605a      	str	r2, [r3, #4]
  spip->spi->CR1 |= SPI_CR1_SPE;
 8001044:	9b01      	ldr	r3, [sp, #4]
 8001046:	69db      	ldr	r3, [r3, #28]
 8001048:	9a01      	ldr	r2, [sp, #4]
 800104a:	69d2      	ldr	r2, [r2, #28]
 800104c:	6812      	ldr	r2, [r2, #0]
 800104e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001052:	601a      	str	r2, [r3, #0]
}
 8001054:	b005      	add	sp, #20
 8001056:	f85d fb04 	ldr.w	pc, [sp], #4
 800105a:	bf00      	nop
 800105c:	20000bdc 	.word	0x20000bdc
 8001060:	08000e11 	.word	0x08000e11
 8001064:	08000ef1 	.word	0x08000ef1
 8001068:	40023800 	.word	0x40023800
 800106c:	00000000 	.word	0x00000000

08001070 <spi_lld_select>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_select(SPIDriver *spip) {
 8001070:	b082      	sub	sp, #8
 8001072:	9001      	str	r0, [sp, #4]

  palClearPad(spip->config->ssport, spip->config->sspad);
 8001074:	9b01      	ldr	r3, [sp, #4]
 8001076:	685b      	ldr	r3, [r3, #4]
 8001078:	685b      	ldr	r3, [r3, #4]
 800107a:	9a01      	ldr	r2, [sp, #4]
 800107c:	6852      	ldr	r2, [r2, #4]
 800107e:	8912      	ldrh	r2, [r2, #8]
 8001080:	4611      	mov	r1, r2
 8001082:	2201      	movs	r2, #1
 8001084:	408a      	lsls	r2, r1
 8001086:	b292      	uxth	r2, r2
 8001088:	835a      	strh	r2, [r3, #26]
}
 800108a:	b002      	add	sp, #8
 800108c:	4770      	bx	lr
 800108e:	bf00      	nop

08001090 <spi_lld_unselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver *spip) {
 8001090:	b082      	sub	sp, #8
 8001092:	9001      	str	r0, [sp, #4]

  palSetPad(spip->config->ssport, spip->config->sspad);
 8001094:	9b01      	ldr	r3, [sp, #4]
 8001096:	685b      	ldr	r3, [r3, #4]
 8001098:	685b      	ldr	r3, [r3, #4]
 800109a:	9a01      	ldr	r2, [sp, #4]
 800109c:	6852      	ldr	r2, [r2, #4]
 800109e:	8912      	ldrh	r2, [r2, #8]
 80010a0:	4611      	mov	r1, r2
 80010a2:	2201      	movs	r2, #1
 80010a4:	408a      	lsls	r2, r1
 80010a6:	b292      	uxth	r2, r2
 80010a8:	831a      	strh	r2, [r3, #24]
}
 80010aa:	b002      	add	sp, #8
 80010ac:	4770      	bx	lr
 80010ae:	bf00      	nop

080010b0 <spi_lld_exchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {
 80010b0:	b084      	sub	sp, #16
 80010b2:	9003      	str	r0, [sp, #12]
 80010b4:	9102      	str	r1, [sp, #8]
 80010b6:	9201      	str	r2, [sp, #4]
 80010b8:	9300      	str	r3, [sp, #0]

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 80010ba:	9b03      	ldr	r3, [sp, #12]
 80010bc:	6a1b      	ldr	r3, [r3, #32]
 80010be:	681b      	ldr	r3, [r3, #0]
 80010c0:	9a00      	ldr	r2, [sp, #0]
 80010c2:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 80010c4:	9b03      	ldr	r3, [sp, #12]
 80010c6:	6a1b      	ldr	r3, [r3, #32]
 80010c8:	681b      	ldr	r3, [r3, #0]
 80010ca:	9a02      	ldr	r2, [sp, #8]
 80010cc:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 80010ce:	9b03      	ldr	r3, [sp, #12]
 80010d0:	6a1b      	ldr	r3, [r3, #32]
 80010d2:	681b      	ldr	r3, [r3, #0]
 80010d4:	9a03      	ldr	r2, [sp, #12]
 80010d6:	6a92      	ldr	r2, [r2, #40]	; 0x28
 80010d8:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80010dc:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80010de:	9b03      	ldr	r3, [sp, #12]
 80010e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80010e2:	681b      	ldr	r3, [r3, #0]
 80010e4:	9a01      	ldr	r2, [sp, #4]
 80010e6:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 80010e8:	9b03      	ldr	r3, [sp, #12]
 80010ea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80010ec:	681b      	ldr	r3, [r3, #0]
 80010ee:	9a02      	ldr	r2, [sp, #8]
 80010f0:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80010f2:	9b03      	ldr	r3, [sp, #12]
 80010f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80010f6:	681b      	ldr	r3, [r3, #0]
 80010f8:	9a03      	ldr	r2, [sp, #12]
 80010fa:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80010fc:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8001100:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 8001102:	9b03      	ldr	r3, [sp, #12]
 8001104:	6a1b      	ldr	r3, [r3, #32]
 8001106:	681b      	ldr	r3, [r3, #0]
 8001108:	9a03      	ldr	r2, [sp, #12]
 800110a:	6a12      	ldr	r2, [r2, #32]
 800110c:	6812      	ldr	r2, [r2, #0]
 800110e:	6812      	ldr	r2, [r2, #0]
 8001110:	f042 0201 	orr.w	r2, r2, #1
 8001114:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 8001116:	9b03      	ldr	r3, [sp, #12]
 8001118:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800111a:	681b      	ldr	r3, [r3, #0]
 800111c:	9a03      	ldr	r2, [sp, #12]
 800111e:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8001120:	6812      	ldr	r2, [r2, #0]
 8001122:	6812      	ldr	r2, [r2, #0]
 8001124:	f042 0201 	orr.w	r2, r2, #1
 8001128:	601a      	str	r2, [r3, #0]
}
 800112a:	b004      	add	sp, #16
 800112c:	4770      	bx	lr
 800112e:	bf00      	nop

08001130 <spi_lld_send>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {
 8001130:	b084      	sub	sp, #16
 8001132:	9003      	str	r0, [sp, #12]
 8001134:	9102      	str	r1, [sp, #8]
 8001136:	9201      	str	r2, [sp, #4]

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 8001138:	9b03      	ldr	r3, [sp, #12]
 800113a:	6a1b      	ldr	r3, [r3, #32]
 800113c:	681b      	ldr	r3, [r3, #0]
 800113e:	4a1a      	ldr	r2, [pc, #104]	; (80011a8 <spi_lld_send+0x78>)
 8001140:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8001142:	9b03      	ldr	r3, [sp, #12]
 8001144:	6a1b      	ldr	r3, [r3, #32]
 8001146:	681b      	ldr	r3, [r3, #0]
 8001148:	9a02      	ldr	r2, [sp, #8]
 800114a:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800114c:	9b03      	ldr	r3, [sp, #12]
 800114e:	6a1b      	ldr	r3, [r3, #32]
 8001150:	681b      	ldr	r3, [r3, #0]
 8001152:	9a03      	ldr	r2, [sp, #12]
 8001154:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8001156:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 8001158:	9b03      	ldr	r3, [sp, #12]
 800115a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800115c:	681b      	ldr	r3, [r3, #0]
 800115e:	9a01      	ldr	r2, [sp, #4]
 8001160:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 8001162:	9b03      	ldr	r3, [sp, #12]
 8001164:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001166:	681b      	ldr	r3, [r3, #0]
 8001168:	9a02      	ldr	r2, [sp, #8]
 800116a:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800116c:	9b03      	ldr	r3, [sp, #12]
 800116e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001170:	681b      	ldr	r3, [r3, #0]
 8001172:	9a03      	ldr	r2, [sp, #12]
 8001174:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8001176:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800117a:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800117c:	9b03      	ldr	r3, [sp, #12]
 800117e:	6a1b      	ldr	r3, [r3, #32]
 8001180:	681b      	ldr	r3, [r3, #0]
 8001182:	9a03      	ldr	r2, [sp, #12]
 8001184:	6a12      	ldr	r2, [r2, #32]
 8001186:	6812      	ldr	r2, [r2, #0]
 8001188:	6812      	ldr	r2, [r2, #0]
 800118a:	f042 0201 	orr.w	r2, r2, #1
 800118e:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 8001190:	9b03      	ldr	r3, [sp, #12]
 8001192:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001194:	681b      	ldr	r3, [r3, #0]
 8001196:	9a03      	ldr	r2, [sp, #12]
 8001198:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800119a:	6812      	ldr	r2, [r2, #0]
 800119c:	6812      	ldr	r2, [r2, #0]
 800119e:	f042 0201 	orr.w	r2, r2, #1
 80011a2:	601a      	str	r2, [r3, #0]
}
 80011a4:	b004      	add	sp, #16
 80011a6:	4770      	bx	lr
 80011a8:	20000c0e 	.word	0x20000c0e
 80011ac:	00000000 	.word	0x00000000

080011b0 <VectorB8>:
/**
 * @brief   TIM4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
 80011b0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD4);
 80011b2:	4803      	ldr	r0, [pc, #12]	; (80011c0 <VectorB8+0x10>)
 80011b4:	f000 f8fc 	bl	80013b0 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 80011b8:	f003 fd2a 	bl	8004c10 <_port_irq_epilogue>
}
 80011bc:	bd08      	pop	{r3, pc}
 80011be:	bf00      	nop
 80011c0:	20000c10 	.word	0x20000c10
	...

080011d0 <pwm_lld_init>:
/**
 * @brief   Low level PWM driver initialization.
 *
 * @notapi
 */
void pwm_lld_init(void) {
 80011d0:	b508      	push	{r3, lr}
  PWMD3.tim = STM32_TIM3;
#endif

#if STM32_PWM_USE_TIM4
  /* Driver initialization.*/
  pwmObjectInit(&PWMD4);
 80011d2:	4805      	ldr	r0, [pc, #20]	; (80011e8 <pwm_lld_init+0x18>)
 80011d4:	f003 fe6c 	bl	8004eb0 <pwmObjectInit>
  PWMD4.channels = STM32_TIM4_CHANNELS;
 80011d8:	4b03      	ldr	r3, [pc, #12]	; (80011e8 <pwm_lld_init+0x18>)
 80011da:	2204      	movs	r2, #4
 80011dc:	741a      	strb	r2, [r3, #16]
  PWMD4.tim = STM32_TIM4;
 80011de:	4b02      	ldr	r3, [pc, #8]	; (80011e8 <pwm_lld_init+0x18>)
 80011e0:	4a02      	ldr	r2, [pc, #8]	; (80011ec <pwm_lld_init+0x1c>)
 80011e2:	619a      	str	r2, [r3, #24]
  /* Driver initialization.*/
  pwmObjectInit(&PWMD9);
  PWMD9.channels = STM32_TIM9_CHANNELS;
  PWMD9.tim = STM32_TIM9;
#endif
}
 80011e4:	bd08      	pop	{r3, pc}
 80011e6:	bf00      	nop
 80011e8:	20000c10 	.word	0x20000c10
 80011ec:	40000800 	.word	0x40000800

080011f0 <pwm_lld_start>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_start(PWMDriver *pwmp) {
 80011f0:	b500      	push	{lr}
 80011f2:	b085      	sub	sp, #20
 80011f4:	9001      	str	r0, [sp, #4]
  uint32_t psc;
  uint32_t ccer;

  if (pwmp->state == PWM_STOP) {
 80011f6:	9b01      	ldr	r3, [sp, #4]
 80011f8:	781b      	ldrb	r3, [r3, #0]
 80011fa:	2b01      	cmp	r3, #1
 80011fc:	d124      	bne.n	8001248 <pwm_lld_start+0x58>
#endif
    }
#endif

#if STM32_PWM_USE_TIM4
    if (&PWMD4 == pwmp) {
 80011fe:	9b01      	ldr	r3, [sp, #4]
 8001200:	4a5a      	ldr	r2, [pc, #360]	; (800136c <pwm_lld_start+0x17c>)
 8001202:	4293      	cmp	r3, r2
 8001204:	d115      	bne.n	8001232 <pwm_lld_start+0x42>
      rccEnableTIM4(FALSE);
 8001206:	4a5a      	ldr	r2, [pc, #360]	; (8001370 <pwm_lld_start+0x180>)
 8001208:	4b59      	ldr	r3, [pc, #356]	; (8001370 <pwm_lld_start+0x180>)
 800120a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800120c:	f043 0304 	orr.w	r3, r3, #4
 8001210:	6413      	str	r3, [r2, #64]	; 0x40
      rccResetTIM4();
 8001212:	4a57      	ldr	r2, [pc, #348]	; (8001370 <pwm_lld_start+0x180>)
 8001214:	4b56      	ldr	r3, [pc, #344]	; (8001370 <pwm_lld_start+0x180>)
 8001216:	6a1b      	ldr	r3, [r3, #32]
 8001218:	f043 0304 	orr.w	r3, r3, #4
 800121c:	6213      	str	r3, [r2, #32]
 800121e:	4b54      	ldr	r3, [pc, #336]	; (8001370 <pwm_lld_start+0x180>)
 8001220:	2200      	movs	r2, #0
 8001222:	621a      	str	r2, [r3, #32]
#if !defined(STM32_TIM4_SUPPRESS_ISR)
      nvicEnableVector(STM32_TIM4_NUMBER, STM32_PWM_TIM4_IRQ_PRIORITY);
 8001224:	201e      	movs	r0, #30
 8001226:	2107      	movs	r1, #7
 8001228:	f003 faea 	bl	8004800 <nvicEnableVector>
#endif
#if defined(STM32_TIM4CLK)
      pwmp->clock = STM32_TIM4CLK;
#else
      pwmp->clock = STM32_TIMCLK1;
 800122c:	9b01      	ldr	r3, [sp, #4]
 800122e:	4a51      	ldr	r2, [pc, #324]	; (8001374 <pwm_lld_start+0x184>)
 8001230:	615a      	str	r2, [r3, #20]
    }
#endif

    /* All channels configured in PWM1 mode with preload enabled and will
       stay that way until the driver is stopped.*/
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 8001232:	9b01      	ldr	r3, [sp, #4]
 8001234:	699b      	ldr	r3, [r3, #24]
 8001236:	f646 0268 	movw	r2, #26728	; 0x6868
 800123a:	619a      	str	r2, [r3, #24]
                       STM32_TIM_CCMR1_OC2M(6) | STM32_TIM_CCMR1_OC2PE;
    pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
 800123c:	9b01      	ldr	r3, [sp, #4]
 800123e:	699b      	ldr	r3, [r3, #24]
 8001240:	f646 0268 	movw	r2, #26728	; 0x6868
 8001244:	61da      	str	r2, [r3, #28]
 8001246:	e017      	b.n	8001278 <pwm_lld_start+0x88>
                       STM32_TIM_CCMR3_OC6M(6) | STM32_TIM_CCMR3_OC6PE;
#endif
  }
  else {
    /* Driver re-configuration scenario, it must be stopped first.*/
    pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
 8001248:	9b01      	ldr	r3, [sp, #4]
 800124a:	699b      	ldr	r3, [r3, #24]
 800124c:	2200      	movs	r2, #0
 800124e:	601a      	str	r2, [r3, #0]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 8001250:	9b01      	ldr	r3, [sp, #4]
 8001252:	699b      	ldr	r3, [r3, #24]
 8001254:	2200      	movs	r2, #0
 8001256:	635a      	str	r2, [r3, #52]	; 0x34
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 8001258:	9b01      	ldr	r3, [sp, #4]
 800125a:	699b      	ldr	r3, [r3, #24]
 800125c:	2200      	movs	r2, #0
 800125e:	639a      	str	r2, [r3, #56]	; 0x38
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
 8001260:	9b01      	ldr	r3, [sp, #4]
 8001262:	699b      	ldr	r3, [r3, #24]
 8001264:	2200      	movs	r2, #0
 8001266:	63da      	str	r2, [r3, #60]	; 0x3c
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
 8001268:	9b01      	ldr	r3, [sp, #4]
 800126a:	699b      	ldr	r3, [r3, #24]
 800126c:	2200      	movs	r2, #0
 800126e:	641a      	str	r2, [r3, #64]	; 0x40
    if (pwmp->channels > 4) {
      pwmp->tim->CCXR[0] = 0;               /* Comparator 5 disabled.       */
      pwmp->tim->CCXR[1] = 0;               /* Comparator 6 disabled.       */
    }
#endif
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
 8001270:	9b01      	ldr	r3, [sp, #4]
 8001272:	699b      	ldr	r3, [r3, #24]
 8001274:	2200      	movs	r2, #0
 8001276:	625a      	str	r2, [r3, #36]	; 0x24
  }

  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8001278:	9b01      	ldr	r3, [sp, #4]
 800127a:	695a      	ldr	r2, [r3, #20]
 800127c:	9b01      	ldr	r3, [sp, #4]
 800127e:	685b      	ldr	r3, [r3, #4]
 8001280:	681b      	ldr	r3, [r3, #0]
 8001282:	fbb2 f3f3 	udiv	r3, r2, r3
 8001286:	3b01      	subs	r3, #1
 8001288:	9302      	str	r3, [sp, #8]
  osalDbgAssert((psc <= 0xFFFF) &&
                ((psc + 1) * pwmp->config->frequency) == pwmp->clock,
                "invalid frequency");
  pwmp->tim->PSC  = psc;
 800128a:	9b01      	ldr	r3, [sp, #4]
 800128c:	699b      	ldr	r3, [r3, #24]
 800128e:	9a02      	ldr	r2, [sp, #8]
 8001290:	629a      	str	r2, [r3, #40]	; 0x28
  pwmp->tim->ARR  = pwmp->period - 1;
 8001292:	9b01      	ldr	r3, [sp, #4]
 8001294:	699b      	ldr	r3, [r3, #24]
 8001296:	9a01      	ldr	r2, [sp, #4]
 8001298:	6892      	ldr	r2, [r2, #8]
 800129a:	3a01      	subs	r2, #1
 800129c:	62da      	str	r2, [r3, #44]	; 0x2c
  pwmp->tim->CR2  = pwmp->config->cr2;
 800129e:	9b01      	ldr	r3, [sp, #4]
 80012a0:	699b      	ldr	r3, [r3, #24]
 80012a2:	9a01      	ldr	r2, [sp, #4]
 80012a4:	6852      	ldr	r2, [r2, #4]
 80012a6:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80012a8:	605a      	str	r2, [r3, #4]

  /* Output enables and polarities setup.*/
  ccer = 0;
 80012aa:	2300      	movs	r3, #0
 80012ac:	9303      	str	r3, [sp, #12]
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 80012ae:	9b01      	ldr	r3, [sp, #4]
 80012b0:	685b      	ldr	r3, [r3, #4]
 80012b2:	68db      	ldr	r3, [r3, #12]
 80012b4:	f003 030f 	and.w	r3, r3, #15
 80012b8:	2b01      	cmp	r3, #1
 80012ba:	d005      	beq.n	80012c8 <pwm_lld_start+0xd8>
 80012bc:	2b02      	cmp	r3, #2
 80012be:	d107      	bne.n	80012d0 <pwm_lld_start+0xe0>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC1P;
 80012c0:	9b03      	ldr	r3, [sp, #12]
 80012c2:	f043 0302 	orr.w	r3, r3, #2
 80012c6:	9303      	str	r3, [sp, #12]
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC1E;
 80012c8:	9b03      	ldr	r3, [sp, #12]
 80012ca:	f043 0301 	orr.w	r3, r3, #1
 80012ce:	9303      	str	r3, [sp, #12]
  default:
    ;
  }
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
 80012d0:	9b01      	ldr	r3, [sp, #4]
 80012d2:	685b      	ldr	r3, [r3, #4]
 80012d4:	695b      	ldr	r3, [r3, #20]
 80012d6:	f003 030f 	and.w	r3, r3, #15
 80012da:	2b01      	cmp	r3, #1
 80012dc:	d005      	beq.n	80012ea <pwm_lld_start+0xfa>
 80012de:	2b02      	cmp	r3, #2
 80012e0:	d107      	bne.n	80012f2 <pwm_lld_start+0x102>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC2P;
 80012e2:	9b03      	ldr	r3, [sp, #12]
 80012e4:	f043 0320 	orr.w	r3, r3, #32
 80012e8:	9303      	str	r3, [sp, #12]
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC2E;
 80012ea:	9b03      	ldr	r3, [sp, #12]
 80012ec:	f043 0310 	orr.w	r3, r3, #16
 80012f0:	9303      	str	r3, [sp, #12]
  default:
    ;
  }
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
 80012f2:	9b01      	ldr	r3, [sp, #4]
 80012f4:	685b      	ldr	r3, [r3, #4]
 80012f6:	69db      	ldr	r3, [r3, #28]
 80012f8:	f003 030f 	and.w	r3, r3, #15
 80012fc:	2b01      	cmp	r3, #1
 80012fe:	d005      	beq.n	800130c <pwm_lld_start+0x11c>
 8001300:	2b02      	cmp	r3, #2
 8001302:	d107      	bne.n	8001314 <pwm_lld_start+0x124>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC3P;
 8001304:	9b03      	ldr	r3, [sp, #12]
 8001306:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800130a:	9303      	str	r3, [sp, #12]
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC3E;
 800130c:	9b03      	ldr	r3, [sp, #12]
 800130e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001312:	9303      	str	r3, [sp, #12]
  default:
    ;
  }
  switch (pwmp->config->channels[3].mode & PWM_OUTPUT_MASK) {
 8001314:	9b01      	ldr	r3, [sp, #4]
 8001316:	685b      	ldr	r3, [r3, #4]
 8001318:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800131a:	f003 030f 	and.w	r3, r3, #15
 800131e:	2b01      	cmp	r3, #1
 8001320:	d005      	beq.n	800132e <pwm_lld_start+0x13e>
 8001322:	2b02      	cmp	r3, #2
 8001324:	d107      	bne.n	8001336 <pwm_lld_start+0x146>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC4P;
 8001326:	9b03      	ldr	r3, [sp, #12]
 8001328:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800132c:	9303      	str	r3, [sp, #12]
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC4E;
 800132e:	9b03      	ldr	r3, [sp, #12]
 8001330:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001334:	9303      	str	r3, [sp, #12]
      ;
    }
  }
#endif /* STM32_PWM_USE_ADVANCED*/

  pwmp->tim->CCER  = ccer;
 8001336:	9b01      	ldr	r3, [sp, #4]
 8001338:	699b      	ldr	r3, [r3, #24]
 800133a:	9a03      	ldr	r2, [sp, #12]
 800133c:	621a      	str	r2, [r3, #32]
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 800133e:	9b01      	ldr	r3, [sp, #4]
 8001340:	699b      	ldr	r3, [r3, #24]
 8001342:	2201      	movs	r2, #1
 8001344:	615a      	str	r2, [r3, #20]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 8001346:	9b01      	ldr	r3, [sp, #4]
 8001348:	699b      	ldr	r3, [r3, #24]
 800134a:	2200      	movs	r2, #0
 800134c:	611a      	str	r2, [r3, #16]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 800134e:	9b01      	ldr	r3, [sp, #4]
 8001350:	699b      	ldr	r3, [r3, #24]
 8001352:	9a01      	ldr	r2, [sp, #4]
 8001354:	6852      	ldr	r2, [r2, #4]
 8001356:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8001358:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 800135c:	60da      	str	r2, [r3, #12]
#else
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
#endif
#endif
  /* Timer configured and started.*/
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 800135e:	9b01      	ldr	r3, [sp, #4]
 8001360:	699b      	ldr	r3, [r3, #24]
 8001362:	2285      	movs	r2, #133	; 0x85
 8001364:	601a      	str	r2, [r3, #0]
                     STM32_TIM_CR1_CEN;
}
 8001366:	b005      	add	sp, #20
 8001368:	f85d fb04 	ldr.w	pc, [sp], #4
 800136c:	20000c10 	.word	0x20000c10
 8001370:	40023800 	.word	0x40023800
 8001374:	0501bd00 	.word	0x0501bd00
	...

08001380 <pwm_lld_enable_channel>:
 *
 * @notapi
 */
void pwm_lld_enable_channel(PWMDriver *pwmp,
                            pwmchannel_t channel,
                            pwmcnt_t width) {
 8001380:	b084      	sub	sp, #16
 8001382:	9003      	str	r0, [sp, #12]
 8001384:	460b      	mov	r3, r1
 8001386:	9201      	str	r2, [sp, #4]
 8001388:	f88d 300b 	strb.w	r3, [sp, #11]

  /* Changing channel duty cycle on the fly.*/
#if STM32_TIM_MAX_CHANNELS <= 4
  pwmp->tim->CCR[channel] = width;
 800138c:	9b03      	ldr	r3, [sp, #12]
 800138e:	699a      	ldr	r2, [r3, #24]
 8001390:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8001394:	330c      	adds	r3, #12
 8001396:	009b      	lsls	r3, r3, #2
 8001398:	4413      	add	r3, r2
 800139a:	9a01      	ldr	r2, [sp, #4]
 800139c:	605a      	str	r2, [r3, #4]
  if (channel < 4)
    pwmp->tim->CCR[channel] = width;
  else
    pwmp->tim->CCXR[channel - 4] = width;
#endif
}
 800139e:	b004      	add	sp, #16
 80013a0:	4770      	bx	lr
 80013a2:	bf00      	nop
	...

080013b0 <pwm_lld_serve_interrupt>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 80013b0:	b500      	push	{lr}
 80013b2:	b085      	sub	sp, #20
 80013b4:	9001      	str	r0, [sp, #4]
  uint32_t sr;

  sr  = pwmp->tim->SR;
 80013b6:	9b01      	ldr	r3, [sp, #4]
 80013b8:	699b      	ldr	r3, [r3, #24]
 80013ba:	691b      	ldr	r3, [r3, #16]
 80013bc:	9303      	str	r3, [sp, #12]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 80013be:	9b01      	ldr	r3, [sp, #4]
 80013c0:	699b      	ldr	r3, [r3, #24]
 80013c2:	68db      	ldr	r3, [r3, #12]
 80013c4:	b2db      	uxtb	r3, r3
 80013c6:	9a03      	ldr	r2, [sp, #12]
 80013c8:	4013      	ands	r3, r2
 80013ca:	9303      	str	r3, [sp, #12]
  pwmp->tim->SR = ~sr;
 80013cc:	9b01      	ldr	r3, [sp, #4]
 80013ce:	699b      	ldr	r3, [r3, #24]
 80013d0:	9a03      	ldr	r2, [sp, #12]
 80013d2:	43d2      	mvns	r2, r2
 80013d4:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 80013d6:	9b03      	ldr	r3, [sp, #12]
 80013d8:	f003 0302 	and.w	r3, r3, #2
 80013dc:	2b00      	cmp	r3, #0
 80013de:	d009      	beq.n	80013f4 <pwm_lld_serve_interrupt+0x44>
      (pwmp->config->channels[0].callback != NULL))
 80013e0:	9b01      	ldr	r3, [sp, #4]
 80013e2:	685b      	ldr	r3, [r3, #4]
 80013e4:	691b      	ldr	r3, [r3, #16]
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 80013e6:	2b00      	cmp	r3, #0
 80013e8:	d004      	beq.n	80013f4 <pwm_lld_serve_interrupt+0x44>
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
 80013ea:	9b01      	ldr	r3, [sp, #4]
 80013ec:	685b      	ldr	r3, [r3, #4]
 80013ee:	691b      	ldr	r3, [r3, #16]
 80013f0:	9801      	ldr	r0, [sp, #4]
 80013f2:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 80013f4:	9b03      	ldr	r3, [sp, #12]
 80013f6:	f003 0304 	and.w	r3, r3, #4
 80013fa:	2b00      	cmp	r3, #0
 80013fc:	d009      	beq.n	8001412 <pwm_lld_serve_interrupt+0x62>
      (pwmp->config->channels[1].callback != NULL))
 80013fe:	9b01      	ldr	r3, [sp, #4]
 8001400:	685b      	ldr	r3, [r3, #4]
 8001402:	699b      	ldr	r3, [r3, #24]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8001404:	2b00      	cmp	r3, #0
 8001406:	d004      	beq.n	8001412 <pwm_lld_serve_interrupt+0x62>
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
 8001408:	9b01      	ldr	r3, [sp, #4]
 800140a:	685b      	ldr	r3, [r3, #4]
 800140c:	699b      	ldr	r3, [r3, #24]
 800140e:	9801      	ldr	r0, [sp, #4]
 8001410:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8001412:	9b03      	ldr	r3, [sp, #12]
 8001414:	f003 0308 	and.w	r3, r3, #8
 8001418:	2b00      	cmp	r3, #0
 800141a:	d009      	beq.n	8001430 <pwm_lld_serve_interrupt+0x80>
      (pwmp->config->channels[2].callback != NULL))
 800141c:	9b01      	ldr	r3, [sp, #4]
 800141e:	685b      	ldr	r3, [r3, #4]
 8001420:	6a1b      	ldr	r3, [r3, #32]
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8001422:	2b00      	cmp	r3, #0
 8001424:	d004      	beq.n	8001430 <pwm_lld_serve_interrupt+0x80>
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
 8001426:	9b01      	ldr	r3, [sp, #4]
 8001428:	685b      	ldr	r3, [r3, #4]
 800142a:	6a1b      	ldr	r3, [r3, #32]
 800142c:	9801      	ldr	r0, [sp, #4]
 800142e:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8001430:	9b03      	ldr	r3, [sp, #12]
 8001432:	f003 0310 	and.w	r3, r3, #16
 8001436:	2b00      	cmp	r3, #0
 8001438:	d009      	beq.n	800144e <pwm_lld_serve_interrupt+0x9e>
      (pwmp->config->channels[3].callback != NULL))
 800143a:	9b01      	ldr	r3, [sp, #4]
 800143c:	685b      	ldr	r3, [r3, #4]
 800143e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8001440:	2b00      	cmp	r3, #0
 8001442:	d004      	beq.n	800144e <pwm_lld_serve_interrupt+0x9e>
      (pwmp->config->channels[3].callback != NULL))
    pwmp->config->channels[3].callback(pwmp);
 8001444:	9b01      	ldr	r3, [sp, #4]
 8001446:	685b      	ldr	r3, [r3, #4]
 8001448:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800144a:	9801      	ldr	r0, [sp, #4]
 800144c:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 800144e:	9b03      	ldr	r3, [sp, #12]
 8001450:	f003 0301 	and.w	r3, r3, #1
 8001454:	2b00      	cmp	r3, #0
 8001456:	d009      	beq.n	800146c <pwm_lld_serve_interrupt+0xbc>
 8001458:	9b01      	ldr	r3, [sp, #4]
 800145a:	685b      	ldr	r3, [r3, #4]
 800145c:	689b      	ldr	r3, [r3, #8]
 800145e:	2b00      	cmp	r3, #0
 8001460:	d004      	beq.n	800146c <pwm_lld_serve_interrupt+0xbc>
    pwmp->config->callback(pwmp);
 8001462:	9b01      	ldr	r3, [sp, #4]
 8001464:	685b      	ldr	r3, [r3, #4]
 8001466:	689b      	ldr	r3, [r3, #8]
 8001468:	9801      	ldr	r0, [sp, #4]
 800146a:	4798      	blx	r3
}
 800146c:	b005      	add	sp, #20
 800146e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001472:	bf00      	nop
	...

08001480 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 8001480:	b508      	push	{r3, lr}

  stm32_clock_init();
 8001482:	f003 fa45 	bl	8004910 <stm32_clock_init>
}
 8001486:	bd08      	pop	{r3, pc}
	...

08001490 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 8001490:	4770      	bx	lr
 8001492:	bf00      	nop
	...

080014a0 <otg_rxfifo_handler.lto_priv.157>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_rxfifo_handler(USBDriver *usbp) {
 80014a0:	b510      	push	{r4, lr}
 80014a2:	b086      	sub	sp, #24
 80014a4:	9001      	str	r0, [sp, #4]
  uint32_t sts, cnt, ep;

  sts = usbp->otg->GRXSTSP;
 80014a6:	9b01      	ldr	r3, [sp, #4]
 80014a8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80014aa:	6a1b      	ldr	r3, [r3, #32]
 80014ac:	9305      	str	r3, [sp, #20]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 80014ae:	9b05      	ldr	r3, [sp, #20]
 80014b0:	f403 13f0 	and.w	r3, r3, #1966080	; 0x1e0000
 80014b4:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 80014b8:	d071      	beq.n	800159e <otg_rxfifo_handler.lto_priv.157+0xfe>
 80014ba:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 80014be:	d003      	beq.n	80014c8 <otg_rxfifo_handler.lto_priv.157+0x28>
 80014c0:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 80014c4:	d01c      	beq.n	8001500 <otg_rxfifo_handler.lto_priv.157+0x60>
 80014c6:	e06a      	b.n	800159e <otg_rxfifo_handler.lto_priv.157+0xfe>
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 80014c8:	9a05      	ldr	r2, [sp, #20]
 80014ca:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 80014ce:	4013      	ands	r3, r2
 80014d0:	091b      	lsrs	r3, r3, #4
 80014d2:	9304      	str	r3, [sp, #16]
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 80014d4:	9b05      	ldr	r3, [sp, #20]
 80014d6:	f003 030f 	and.w	r3, r3, #15
 80014da:	9303      	str	r3, [sp, #12]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 80014dc:	9b01      	ldr	r3, [sp, #4]
 80014de:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80014e0:	f503 5180 	add.w	r1, r3, #4096	; 0x1000
 80014e4:	9a01      	ldr	r2, [sp, #4]
 80014e6:	9b03      	ldr	r3, [sp, #12]
 80014e8:	3302      	adds	r3, #2
 80014ea:	009b      	lsls	r3, r3, #2
 80014ec:	4413      	add	r3, r2
 80014ee:	685b      	ldr	r3, [r3, #4]
 80014f0:	6a1b      	ldr	r3, [r3, #32]
 80014f2:	4608      	mov	r0, r1
 80014f4:	4619      	mov	r1, r3
 80014f6:	9a04      	ldr	r2, [sp, #16]
 80014f8:	2308      	movs	r3, #8
 80014fa:	f002 faa1 	bl	8003a40 <otg_fifo_read_to_buffer.lto_priv.175>
 80014fe:	e04e      	b.n	800159e <otg_rxfifo_handler.lto_priv.157+0xfe>
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8001500:	9a05      	ldr	r2, [sp, #20]
 8001502:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8001506:	4013      	ands	r3, r2
 8001508:	091b      	lsrs	r3, r3, #4
 800150a:	9304      	str	r3, [sp, #16]
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 800150c:	9b05      	ldr	r3, [sp, #20]
 800150e:	f003 030f 	and.w	r3, r3, #15
 8001512:	9303      	str	r3, [sp, #12]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8001514:	9b01      	ldr	r3, [sp, #4]
 8001516:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001518:	f503 5080 	add.w	r0, r3, #4096	; 0x1000
                            usbp->epc[ep]->out_state->rxbuf,
 800151c:	9a01      	ldr	r2, [sp, #4]
 800151e:	9b03      	ldr	r3, [sp, #12]
 8001520:	3302      	adds	r3, #2
 8001522:	009b      	lsls	r3, r3, #2
 8001524:	4413      	add	r3, r2
 8001526:	685b      	ldr	r3, [r3, #4]
 8001528:	699b      	ldr	r3, [r3, #24]
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 800152a:	689c      	ldr	r4, [r3, #8]
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
 800152c:	9a01      	ldr	r2, [sp, #4]
 800152e:	9b03      	ldr	r3, [sp, #12]
 8001530:	3302      	adds	r3, #2
 8001532:	009b      	lsls	r3, r3, #2
 8001534:	4413      	add	r3, r2
 8001536:	685b      	ldr	r3, [r3, #4]
 8001538:	699b      	ldr	r3, [r3, #24]
 800153a:	681a      	ldr	r2, [r3, #0]
                            usbp->epc[ep]->out_state->rxcnt);
 800153c:	9901      	ldr	r1, [sp, #4]
 800153e:	9b03      	ldr	r3, [sp, #12]
 8001540:	3302      	adds	r3, #2
 8001542:	009b      	lsls	r3, r3, #2
 8001544:	440b      	add	r3, r1
 8001546:	685b      	ldr	r3, [r3, #4]
 8001548:	699b      	ldr	r3, [r3, #24]
 800154a:	685b      	ldr	r3, [r3, #4]
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 800154c:	1ad3      	subs	r3, r2, r3
 800154e:	4621      	mov	r1, r4
 8001550:	9a04      	ldr	r2, [sp, #16]
 8001552:	f002 fa75 	bl	8003a40 <otg_fifo_read_to_buffer.lto_priv.175>
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
                            usbp->epc[ep]->out_state->rxcnt);
    usbp->epc[ep]->out_state->rxbuf += cnt;
 8001556:	9a01      	ldr	r2, [sp, #4]
 8001558:	9b03      	ldr	r3, [sp, #12]
 800155a:	3302      	adds	r3, #2
 800155c:	009b      	lsls	r3, r3, #2
 800155e:	4413      	add	r3, r2
 8001560:	685b      	ldr	r3, [r3, #4]
 8001562:	699a      	ldr	r2, [r3, #24]
 8001564:	9901      	ldr	r1, [sp, #4]
 8001566:	9b03      	ldr	r3, [sp, #12]
 8001568:	3302      	adds	r3, #2
 800156a:	009b      	lsls	r3, r3, #2
 800156c:	440b      	add	r3, r1
 800156e:	685b      	ldr	r3, [r3, #4]
 8001570:	699b      	ldr	r3, [r3, #24]
 8001572:	6899      	ldr	r1, [r3, #8]
 8001574:	9b04      	ldr	r3, [sp, #16]
 8001576:	440b      	add	r3, r1
 8001578:	6093      	str	r3, [r2, #8]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 800157a:	9a01      	ldr	r2, [sp, #4]
 800157c:	9b03      	ldr	r3, [sp, #12]
 800157e:	3302      	adds	r3, #2
 8001580:	009b      	lsls	r3, r3, #2
 8001582:	4413      	add	r3, r2
 8001584:	685b      	ldr	r3, [r3, #4]
 8001586:	699a      	ldr	r2, [r3, #24]
 8001588:	9901      	ldr	r1, [sp, #4]
 800158a:	9b03      	ldr	r3, [sp, #12]
 800158c:	3302      	adds	r3, #2
 800158e:	009b      	lsls	r3, r3, #2
 8001590:	440b      	add	r3, r1
 8001592:	685b      	ldr	r3, [r3, #4]
 8001594:	699b      	ldr	r3, [r3, #24]
 8001596:	6859      	ldr	r1, [r3, #4]
 8001598:	9b04      	ldr	r3, [sp, #16]
 800159a:	440b      	add	r3, r1
 800159c:	6053      	str	r3, [r2, #4]
  case GRXSTSP_OUT_GLOBAL_NAK:
  case GRXSTSP_OUT_COMP:
  default:
    ;
  }
}
 800159e:	b006      	add	sp, #24
 80015a0:	bd10      	pop	{r4, pc}
 80015a2:	bf00      	nop
	...

080015b0 <otg_txfifo_handler.lto_priv.156>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
 80015b0:	b500      	push	{lr}
 80015b2:	b085      	sub	sp, #20
 80015b4:	9001      	str	r0, [sp, #4]
 80015b6:	460b      	mov	r3, r1
 80015b8:	f88d 3003 	strb.w	r3, [sp, #3]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 80015bc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80015c0:	9a01      	ldr	r2, [sp, #4]
 80015c2:	3302      	adds	r3, #2
 80015c4:	009b      	lsls	r3, r3, #2
 80015c6:	4413      	add	r3, r2
 80015c8:	685b      	ldr	r3, [r3, #4]
 80015ca:	695b      	ldr	r3, [r3, #20]
 80015cc:	685a      	ldr	r2, [r3, #4]
 80015ce:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80015d2:	9901      	ldr	r1, [sp, #4]
 80015d4:	3302      	adds	r3, #2
 80015d6:	009b      	lsls	r3, r3, #2
 80015d8:	440b      	add	r3, r1
 80015da:	685b      	ldr	r3, [r3, #4]
 80015dc:	695b      	ldr	r3, [r3, #20]
 80015de:	681b      	ldr	r3, [r3, #0]
 80015e0:	429a      	cmp	r2, r3
 80015e2:	d301      	bcc.n	80015e8 <otg_txfifo_handler.lto_priv.156+0x38>
      return true;
 80015e4:	2301      	movs	r3, #1
 80015e6:	e076      	b.n	80016d6 <otg_txfifo_handler.lto_priv.156+0x126>

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 80015e8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80015ec:	9a01      	ldr	r2, [sp, #4]
 80015ee:	3302      	adds	r3, #2
 80015f0:	009b      	lsls	r3, r3, #2
 80015f2:	4413      	add	r3, r2
 80015f4:	685b      	ldr	r3, [r3, #4]
 80015f6:	695b      	ldr	r3, [r3, #20]
 80015f8:	681a      	ldr	r2, [r3, #0]
 80015fa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80015fe:	9901      	ldr	r1, [sp, #4]
 8001600:	3302      	adds	r3, #2
 8001602:	009b      	lsls	r3, r3, #2
 8001604:	440b      	add	r3, r1
 8001606:	685b      	ldr	r3, [r3, #4]
 8001608:	695b      	ldr	r3, [r3, #20]
 800160a:	685b      	ldr	r3, [r3, #4]
 800160c:	1ad3      	subs	r3, r2, r3
 800160e:	9303      	str	r3, [sp, #12]
    if (n > usbp->epc[ep]->in_maxsize)
 8001610:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001614:	9a01      	ldr	r2, [sp, #4]
 8001616:	3302      	adds	r3, #2
 8001618:	009b      	lsls	r3, r3, #2
 800161a:	4413      	add	r3, r2
 800161c:	685b      	ldr	r3, [r3, #4]
 800161e:	8a1b      	ldrh	r3, [r3, #16]
 8001620:	461a      	mov	r2, r3
 8001622:	9b03      	ldr	r3, [sp, #12]
 8001624:	429a      	cmp	r2, r3
 8001626:	d208      	bcs.n	800163a <otg_txfifo_handler.lto_priv.156+0x8a>
      n = usbp->epc[ep]->in_maxsize;
 8001628:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800162c:	9a01      	ldr	r2, [sp, #4]
 800162e:	3302      	adds	r3, #2
 8001630:	009b      	lsls	r3, r3, #2
 8001632:	4413      	add	r3, r2
 8001634:	685b      	ldr	r3, [r3, #4]
 8001636:	8a1b      	ldrh	r3, [r3, #16]
 8001638:	9303      	str	r3, [sp, #12]

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800163a:	9b01      	ldr	r3, [sp, #4]
 800163c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800163e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001642:	015b      	lsls	r3, r3, #5
 8001644:	4413      	add	r3, r2
 8001646:	f603 1318 	addw	r3, r3, #2328	; 0x918
 800164a:	681b      	ldr	r3, [r3, #0]
 800164c:	b29b      	uxth	r3, r3
 800164e:	009a      	lsls	r2, r3, #2
 8001650:	9b03      	ldr	r3, [sp, #12]
 8001652:	429a      	cmp	r2, r3
 8001654:	d201      	bcs.n	800165a <otg_txfifo_handler.lto_priv.156+0xaa>
      return false;
 8001656:	2300      	movs	r3, #0
 8001658:	e03d      	b.n	80016d6 <otg_txfifo_handler.lto_priv.156+0x126>

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 800165a:	9b01      	ldr	r3, [sp, #4]
 800165c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800165e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001662:	3301      	adds	r3, #1
 8001664:	031b      	lsls	r3, r3, #12
 8001666:	18d1      	adds	r1, r2, r3
                               usbp->epc[ep]->in_state->txbuf,
 8001668:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800166c:	9a01      	ldr	r2, [sp, #4]
 800166e:	3302      	adds	r3, #2
 8001670:	009b      	lsls	r3, r3, #2
 8001672:	4413      	add	r3, r2
 8001674:	685b      	ldr	r3, [r3, #4]
 8001676:	695b      	ldr	r3, [r3, #20]
      return false;

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8001678:	689b      	ldr	r3, [r3, #8]
 800167a:	4608      	mov	r0, r1
 800167c:	4619      	mov	r1, r3
 800167e:	9a03      	ldr	r2, [sp, #12]
 8001680:	f002 f9c6 	bl	8003a10 <otg_fifo_write_from_buffer.lto_priv.174>
                               usbp->epc[ep]->in_state->txbuf,
                               n);
    usbp->epc[ep]->in_state->txbuf += n;
 8001684:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001688:	9a01      	ldr	r2, [sp, #4]
 800168a:	3302      	adds	r3, #2
 800168c:	009b      	lsls	r3, r3, #2
 800168e:	4413      	add	r3, r2
 8001690:	685b      	ldr	r3, [r3, #4]
 8001692:	695a      	ldr	r2, [r3, #20]
 8001694:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001698:	9901      	ldr	r1, [sp, #4]
 800169a:	3302      	adds	r3, #2
 800169c:	009b      	lsls	r3, r3, #2
 800169e:	440b      	add	r3, r1
 80016a0:	685b      	ldr	r3, [r3, #4]
 80016a2:	695b      	ldr	r3, [r3, #20]
 80016a4:	6899      	ldr	r1, [r3, #8]
 80016a6:	9b03      	ldr	r3, [sp, #12]
 80016a8:	440b      	add	r3, r1
 80016aa:	6093      	str	r3, [r2, #8]
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 80016ac:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80016b0:	9a01      	ldr	r2, [sp, #4]
 80016b2:	3302      	adds	r3, #2
 80016b4:	009b      	lsls	r3, r3, #2
 80016b6:	4413      	add	r3, r2
 80016b8:	685b      	ldr	r3, [r3, #4]
 80016ba:	695a      	ldr	r2, [r3, #20]
 80016bc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80016c0:	9901      	ldr	r1, [sp, #4]
 80016c2:	3302      	adds	r3, #2
 80016c4:	009b      	lsls	r3, r3, #2
 80016c6:	440b      	add	r3, r1
 80016c8:	685b      	ldr	r3, [r3, #4]
 80016ca:	695b      	ldr	r3, [r3, #20]
 80016cc:	6859      	ldr	r1, [r3, #4]
 80016ce:	9b03      	ldr	r3, [sp, #12]
 80016d0:	440b      	add	r3, r1
 80016d2:	6053      	str	r3, [r2, #4]
 80016d4:	e772      	b.n	80015bc <otg_txfifo_handler.lto_priv.156+0xc>
  }
}
 80016d6:	4618      	mov	r0, r3
 80016d8:	b005      	add	sp, #20
 80016da:	f85d fb04 	ldr.w	pc, [sp], #4
 80016de:	bf00      	nop

080016e0 <otg_epin_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 80016e0:	b500      	push	{lr}
 80016e2:	b087      	sub	sp, #28
 80016e4:	9001      	str	r0, [sp, #4]
 80016e6:	460b      	mov	r3, r1
 80016e8:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 80016ec:	9b01      	ldr	r3, [sp, #4]
 80016ee:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80016f0:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->ie[ep].DIEPINT;
 80016f2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80016f6:	9a05      	ldr	r2, [sp, #20]
 80016f8:	015b      	lsls	r3, r3, #5
 80016fa:	4413      	add	r3, r2
 80016fc:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8001700:	681b      	ldr	r3, [r3, #0]
 8001702:	9304      	str	r3, [sp, #16]

  otgp->ie[ep].DIEPINT = epint;
 8001704:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001708:	9a05      	ldr	r2, [sp, #20]
 800170a:	015b      	lsls	r3, r3, #5
 800170c:	4413      	add	r3, r2
 800170e:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8001712:	9a04      	ldr	r2, [sp, #16]
 8001714:	601a      	str	r2, [r3, #0]

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8001716:	9b04      	ldr	r3, [sp, #16]
 8001718:	f003 0301 	and.w	r3, r3, #1
 800171c:	2b00      	cmp	r3, #0
 800171e:	d063      	beq.n	80017e8 <otg_epin_handler+0x108>
 8001720:	9b05      	ldr	r3, [sp, #20]
 8001722:	f8d3 3810 	ldr.w	r3, [r3, #2064]	; 0x810
 8001726:	f003 0301 	and.w	r3, r3, #1
 800172a:	2b00      	cmp	r3, #0
 800172c:	d05c      	beq.n	80017e8 <otg_epin_handler+0x108>
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800172e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001732:	9a01      	ldr	r2, [sp, #4]
 8001734:	3302      	adds	r3, #2
 8001736:	009b      	lsls	r3, r3, #2
 8001738:	4413      	add	r3, r2
 800173a:	685b      	ldr	r3, [r3, #4]
 800173c:	695b      	ldr	r3, [r3, #20]
 800173e:	9303      	str	r3, [sp, #12]

    if (isp->txsize < isp->totsize) {
 8001740:	9b03      	ldr	r3, [sp, #12]
 8001742:	681a      	ldr	r2, [r3, #0]
 8001744:	9b03      	ldr	r3, [sp, #12]
 8001746:	691b      	ldr	r3, [r3, #16]
 8001748:	429a      	cmp	r2, r3
 800174a:	d214      	bcs.n	8001776 <otg_epin_handler+0x96>
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 800174c:	9b03      	ldr	r3, [sp, #12]
 800174e:	691a      	ldr	r2, [r3, #16]
 8001750:	9b03      	ldr	r3, [sp, #12]
 8001752:	681b      	ldr	r3, [r3, #0]
 8001754:	1ad2      	subs	r2, r2, r3
 8001756:	9b03      	ldr	r3, [sp, #12]
 8001758:	601a      	str	r2, [r3, #0]
      isp->txcnt  = 0;
 800175a:	9b03      	ldr	r3, [sp, #12]
 800175c:	2200      	movs	r2, #0
 800175e:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 8001760:	f002 f856 	bl	8003810 <osalSysLockFromISR.lto_priv.173>
      usb_lld_start_in(usbp, ep);
 8001764:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001768:	9801      	ldr	r0, [sp, #4]
 800176a:	4619      	mov	r1, r3
 800176c:	f000 fee8 	bl	8002540 <usb_lld_start_in>
      osalSysUnlockFromISR();
 8001770:	f002 f856 	bl	8003820 <osalSysUnlockFromISR.lto_priv.171>
 8001774:	e038      	b.n	80017e8 <otg_epin_handler+0x108>
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 8001776:	9b01      	ldr	r3, [sp, #4]
 8001778:	891b      	ldrh	r3, [r3, #8]
 800177a:	b299      	uxth	r1, r3
 800177c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001780:	2201      	movs	r2, #1
 8001782:	fa02 f303 	lsl.w	r3, r2, r3
 8001786:	b29b      	uxth	r3, r3
 8001788:	43db      	mvns	r3, r3
 800178a:	b29b      	uxth	r3, r3
 800178c:	460a      	mov	r2, r1
 800178e:	4013      	ands	r3, r2
 8001790:	b29b      	uxth	r3, r3
 8001792:	b29a      	uxth	r2, r3
 8001794:	9b01      	ldr	r3, [sp, #4]
 8001796:	811a      	strh	r2, [r3, #8]
 8001798:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800179c:	9a01      	ldr	r2, [sp, #4]
 800179e:	3302      	adds	r3, #2
 80017a0:	009b      	lsls	r3, r3, #2
 80017a2:	4413      	add	r3, r2
 80017a4:	685b      	ldr	r3, [r3, #4]
 80017a6:	689b      	ldr	r3, [r3, #8]
 80017a8:	2b00      	cmp	r3, #0
 80017aa:	d00c      	beq.n	80017c6 <otg_epin_handler+0xe6>
 80017ac:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80017b0:	9a01      	ldr	r2, [sp, #4]
 80017b2:	3302      	adds	r3, #2
 80017b4:	009b      	lsls	r3, r3, #2
 80017b6:	4413      	add	r3, r2
 80017b8:	685b      	ldr	r3, [r3, #4]
 80017ba:	689b      	ldr	r3, [r3, #8]
 80017bc:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80017c0:	9801      	ldr	r0, [sp, #4]
 80017c2:	4611      	mov	r1, r2
 80017c4:	4798      	blx	r3
 80017c6:	f002 f823 	bl	8003810 <osalSysLockFromISR.lto_priv.173>
 80017ca:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80017ce:	9a01      	ldr	r2, [sp, #4]
 80017d0:	3302      	adds	r3, #2
 80017d2:	009b      	lsls	r3, r3, #2
 80017d4:	4413      	add	r3, r2
 80017d6:	685b      	ldr	r3, [r3, #4]
 80017d8:	695b      	ldr	r3, [r3, #20]
 80017da:	330c      	adds	r3, #12
 80017dc:	4618      	mov	r0, r3
 80017de:	2100      	movs	r1, #0
 80017e0:	f002 f846 	bl	8003870 <osalThreadResumeI.lto_priv.172>
 80017e4:	f002 f81c 	bl	8003820 <osalSysUnlockFromISR.lto_priv.171>
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 80017e8:	9b04      	ldr	r3, [sp, #16]
 80017ea:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80017ee:	2b00      	cmp	r3, #0
 80017f0:	d02b      	beq.n	800184a <otg_epin_handler+0x16a>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 80017f2:	9b05      	ldr	r3, [sp, #20]
 80017f4:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 80017f8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80017fc:	2101      	movs	r1, #1
 80017fe:	fa01 f303 	lsl.w	r3, r1, r3
 8001802:	4013      	ands	r3, r2
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8001804:	2b00      	cmp	r3, #0
 8001806:	d020      	beq.n	800184a <otg_epin_handler+0x16a>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
 8001808:	f002 f802 	bl	8003810 <osalSysLockFromISR.lto_priv.173>
    usbp->txpending |= (1 << ep);
 800180c:	9b01      	ldr	r3, [sp, #4]
 800180e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8001810:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8001814:	2101      	movs	r1, #1
 8001816:	fa01 f202 	lsl.w	r2, r1, r2
 800181a:	431a      	orrs	r2, r3
 800181c:	9b01      	ldr	r3, [sp, #4]
 800181e:	65da      	str	r2, [r3, #92]	; 0x5c
    otgp->DIEPEMPMSK &= ~(1 << ep);
 8001820:	9b05      	ldr	r3, [sp, #20]
 8001822:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
 8001826:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800182a:	2101      	movs	r1, #1
 800182c:	fa01 f202 	lsl.w	r2, r1, r2
 8001830:	43d2      	mvns	r2, r2
 8001832:	401a      	ands	r2, r3
 8001834:	9b05      	ldr	r3, [sp, #20]
 8001836:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
    osalThreadResumeI(&usbp->wait, MSG_OK);
 800183a:	9b01      	ldr	r3, [sp, #4]
 800183c:	3360      	adds	r3, #96	; 0x60
 800183e:	4618      	mov	r0, r3
 8001840:	2100      	movs	r1, #0
 8001842:	f002 f815 	bl	8003870 <osalThreadResumeI.lto_priv.172>
    osalSysUnlockFromISR();
 8001846:	f001 ffeb 	bl	8003820 <osalSysUnlockFromISR.lto_priv.171>
  }
}
 800184a:	b007      	add	sp, #28
 800184c:	f85d fb04 	ldr.w	pc, [sp], #4

08001850 <otg_epout_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8001850:	b500      	push	{lr}
 8001852:	b087      	sub	sp, #28
 8001854:	9001      	str	r0, [sp, #4]
 8001856:	460b      	mov	r3, r1
 8001858:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 800185c:	9b01      	ldr	r3, [sp, #4]
 800185e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001860:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8001862:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001866:	9a05      	ldr	r2, [sp, #20]
 8001868:	015b      	lsls	r3, r3, #5
 800186a:	4413      	add	r3, r2
 800186c:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 8001870:	681b      	ldr	r3, [r3, #0]
 8001872:	9304      	str	r3, [sp, #16]

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 8001874:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001878:	9a05      	ldr	r2, [sp, #20]
 800187a:	015b      	lsls	r3, r3, #5
 800187c:	4413      	add	r3, r2
 800187e:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 8001882:	9a04      	ldr	r2, [sp, #16]
 8001884:	601a      	str	r2, [r3, #0]

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8001886:	9b04      	ldr	r3, [sp, #16]
 8001888:	f003 0308 	and.w	r3, r3, #8
 800188c:	2b00      	cmp	r3, #0
 800188e:	d013      	beq.n	80018b8 <otg_epout_handler+0x68>
 8001890:	9b05      	ldr	r3, [sp, #20]
 8001892:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 8001896:	f003 0308 	and.w	r3, r3, #8
 800189a:	2b00      	cmp	r3, #0
 800189c:	d00c      	beq.n	80018b8 <otg_epout_handler+0x68>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 800189e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80018a2:	9a01      	ldr	r2, [sp, #4]
 80018a4:	3302      	adds	r3, #2
 80018a6:	009b      	lsls	r3, r3, #2
 80018a8:	4413      	add	r3, r2
 80018aa:	685b      	ldr	r3, [r3, #4]
 80018ac:	685b      	ldr	r3, [r3, #4]
 80018ae:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80018b2:	9801      	ldr	r0, [sp, #4]
 80018b4:	4611      	mov	r1, r2
 80018b6:	4798      	blx	r3

  }
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 80018b8:	9b04      	ldr	r3, [sp, #16]
 80018ba:	f003 0301 	and.w	r3, r3, #1
 80018be:	2b00      	cmp	r3, #0
 80018c0:	d07e      	beq.n	80019c0 <otg_epout_handler+0x170>
 80018c2:	9b05      	ldr	r3, [sp, #20]
 80018c4:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 80018c8:	f003 0301 	and.w	r3, r3, #1
 80018cc:	2b00      	cmp	r3, #0
 80018ce:	d077      	beq.n	80019c0 <otg_epout_handler+0x170>
    /* Receive transfer complete.*/
    USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80018d0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80018d4:	9a01      	ldr	r2, [sp, #4]
 80018d6:	3302      	adds	r3, #2
 80018d8:	009b      	lsls	r3, r3, #2
 80018da:	4413      	add	r3, r2
 80018dc:	685b      	ldr	r3, [r3, #4]
 80018de:	699b      	ldr	r3, [r3, #24]
 80018e0:	9303      	str	r3, [sp, #12]

    /* A short packet always terminates a transaction.*/
    if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 80018e2:	9b03      	ldr	r3, [sp, #12]
 80018e4:	685a      	ldr	r2, [r3, #4]
 80018e6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80018ea:	9901      	ldr	r1, [sp, #4]
 80018ec:	3302      	adds	r3, #2
 80018ee:	009b      	lsls	r3, r3, #2
 80018f0:	440b      	add	r3, r1
 80018f2:	685b      	ldr	r3, [r3, #4]
 80018f4:	8a5b      	ldrh	r3, [r3, #18]
 80018f6:	fbb2 f1f3 	udiv	r1, r2, r3
 80018fa:	fb03 f301 	mul.w	r3, r3, r1
 80018fe:	1ad3      	subs	r3, r2, r3
 8001900:	2b00      	cmp	r3, #0
 8001902:	d11a      	bne.n	800193a <otg_epout_handler+0xea>
        (osp->rxsize < osp->totsize)) {
 8001904:	9b03      	ldr	r3, [sp, #12]
 8001906:	681a      	ldr	r2, [r3, #0]
 8001908:	9b03      	ldr	r3, [sp, #12]
 800190a:	691b      	ldr	r3, [r3, #16]
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
    /* Receive transfer complete.*/
    USBOutEndpointState *osp = usbp->epc[ep]->out_state;

    /* A short packet always terminates a transaction.*/
    if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 800190c:	429a      	cmp	r2, r3
 800190e:	d214      	bcs.n	800193a <otg_epout_handler+0xea>
        (osp->rxsize < osp->totsize)) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 8001910:	9b03      	ldr	r3, [sp, #12]
 8001912:	691a      	ldr	r2, [r3, #16]
 8001914:	9b03      	ldr	r3, [sp, #12]
 8001916:	681b      	ldr	r3, [r3, #0]
 8001918:	1ad2      	subs	r2, r2, r3
 800191a:	9b03      	ldr	r3, [sp, #12]
 800191c:	601a      	str	r2, [r3, #0]
      osp->rxcnt  = 0;
 800191e:	9b03      	ldr	r3, [sp, #12]
 8001920:	2200      	movs	r2, #0
 8001922:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 8001924:	f001 ff74 	bl	8003810 <osalSysLockFromISR.lto_priv.173>
      usb_lld_start_out(usbp, ep);
 8001928:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800192c:	9801      	ldr	r0, [sp, #4]
 800192e:	4619      	mov	r1, r3
 8001930:	f000 fd66 	bl	8002400 <usb_lld_start_out>
      osalSysUnlockFromISR();
 8001934:	f001 ff74 	bl	8003820 <osalSysUnlockFromISR.lto_priv.171>
 8001938:	e042      	b.n	80019c0 <otg_epout_handler+0x170>
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 800193a:	9b01      	ldr	r3, [sp, #4]
 800193c:	895b      	ldrh	r3, [r3, #10]
 800193e:	b299      	uxth	r1, r3
 8001940:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001944:	2201      	movs	r2, #1
 8001946:	fa02 f303 	lsl.w	r3, r2, r3
 800194a:	b29b      	uxth	r3, r3
 800194c:	43db      	mvns	r3, r3
 800194e:	b29b      	uxth	r3, r3
 8001950:	460a      	mov	r2, r1
 8001952:	4013      	ands	r3, r2
 8001954:	b29b      	uxth	r3, r3
 8001956:	b29a      	uxth	r2, r3
 8001958:	9b01      	ldr	r3, [sp, #4]
 800195a:	815a      	strh	r2, [r3, #10]
 800195c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001960:	9a01      	ldr	r2, [sp, #4]
 8001962:	3302      	adds	r3, #2
 8001964:	009b      	lsls	r3, r3, #2
 8001966:	4413      	add	r3, r2
 8001968:	685b      	ldr	r3, [r3, #4]
 800196a:	68db      	ldr	r3, [r3, #12]
 800196c:	2b00      	cmp	r3, #0
 800196e:	d00c      	beq.n	800198a <otg_epout_handler+0x13a>
 8001970:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001974:	9a01      	ldr	r2, [sp, #4]
 8001976:	3302      	adds	r3, #2
 8001978:	009b      	lsls	r3, r3, #2
 800197a:	4413      	add	r3, r2
 800197c:	685b      	ldr	r3, [r3, #4]
 800197e:	68db      	ldr	r3, [r3, #12]
 8001980:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8001984:	9801      	ldr	r0, [sp, #4]
 8001986:	4611      	mov	r1, r2
 8001988:	4798      	blx	r3
 800198a:	f001 ff41 	bl	8003810 <osalSysLockFromISR.lto_priv.173>
 800198e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001992:	9a01      	ldr	r2, [sp, #4]
 8001994:	3302      	adds	r3, #2
 8001996:	009b      	lsls	r3, r3, #2
 8001998:	4413      	add	r3, r2
 800199a:	685b      	ldr	r3, [r3, #4]
 800199c:	699b      	ldr	r3, [r3, #24]
 800199e:	f103 010c 	add.w	r1, r3, #12
 80019a2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80019a6:	9a01      	ldr	r2, [sp, #4]
 80019a8:	3302      	adds	r3, #2
 80019aa:	009b      	lsls	r3, r3, #2
 80019ac:	4413      	add	r3, r2
 80019ae:	685b      	ldr	r3, [r3, #4]
 80019b0:	699b      	ldr	r3, [r3, #24]
 80019b2:	685b      	ldr	r3, [r3, #4]
 80019b4:	4608      	mov	r0, r1
 80019b6:	4619      	mov	r1, r3
 80019b8:	f001 ff5a 	bl	8003870 <osalThreadResumeI.lto_priv.172>
 80019bc:	f001 ff30 	bl	8003820 <osalSysUnlockFromISR.lto_priv.171>
    }
  }
}
 80019c0:	b007      	add	sp, #28
 80019c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80019c6:	bf00      	nop
	...

080019d0 <otg_isoc_in_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
 80019d0:	b500      	push	{lr}
 80019d2:	b085      	sub	sp, #20
 80019d4:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 80019d6:	9b01      	ldr	r3, [sp, #4]
 80019d8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80019da:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80019dc:	2300      	movs	r3, #0
 80019de:	f88d 300f 	strb.w	r3, [sp, #15]
 80019e2:	e093      	b.n	8001b0c <otg_isoc_in_failed_handler+0x13c>
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 80019e4:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80019e8:	9a02      	ldr	r2, [sp, #8]
 80019ea:	3348      	adds	r3, #72	; 0x48
 80019ec:	015b      	lsls	r3, r3, #5
 80019ee:	4413      	add	r3, r2
 80019f0:	681b      	ldr	r3, [r3, #0]
 80019f2:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 80019f6:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 80019fa:	f040 8082 	bne.w	8001b02 <otg_isoc_in_failed_handler+0x132>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 80019fe:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001a02:	9a02      	ldr	r2, [sp, #8]
 8001a04:	3348      	adds	r3, #72	; 0x48
 8001a06:	015b      	lsls	r3, r3, #5
 8001a08:	4413      	add	r3, r2
 8001a0a:	681b      	ldr	r3, [r3, #0]
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8001a0c:	2b00      	cmp	r3, #0
 8001a0e:	da78      	bge.n	8001b02 <otg_isoc_in_failed_handler+0x132>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
      /* Endpoint enabled -> ISOC IN transfer failed */
      /* Disable endpoint */
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 8001a10:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001a14:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8001a18:	9902      	ldr	r1, [sp, #8]
 8001a1a:	3248      	adds	r2, #72	; 0x48
 8001a1c:	0152      	lsls	r2, r2, #5
 8001a1e:	440a      	add	r2, r1
 8001a20:	6812      	ldr	r2, [r2, #0]
 8001a22:	f042 4290 	orr.w	r2, r2, #1207959552	; 0x48000000
 8001a26:	9902      	ldr	r1, [sp, #8]
 8001a28:	3348      	adds	r3, #72	; 0x48
 8001a2a:	015b      	lsls	r3, r3, #5
 8001a2c:	440b      	add	r3, r1
 8001a2e:	601a      	str	r2, [r3, #0]
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 8001a30:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001a34:	9a02      	ldr	r2, [sp, #8]
 8001a36:	3348      	adds	r3, #72	; 0x48
 8001a38:	015b      	lsls	r3, r3, #5
 8001a3a:	4413      	add	r3, r2
 8001a3c:	681b      	ldr	r3, [r3, #0]
 8001a3e:	2b00      	cmp	r3, #0
 8001a40:	dbf6      	blt.n	8001a30 <otg_isoc_in_failed_handler+0x60>
        ;

      /* Flush FIFO */
      otg_txfifo_flush(usbp, ep);
 8001a42:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001a46:	9801      	ldr	r0, [sp, #4]
 8001a48:	4619      	mov	r1, r3
 8001a4a:	f001 ffa1 	bl	8003990 <otg_txfifo_flush.lto_priv.166>

      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);
 8001a4e:	9b01      	ldr	r3, [sp, #4]
 8001a50:	891b      	ldrh	r3, [r3, #8]
 8001a52:	b299      	uxth	r1, r3
 8001a54:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001a58:	2201      	movs	r2, #1
 8001a5a:	fa02 f303 	lsl.w	r3, r2, r3
 8001a5e:	b29b      	uxth	r3, r3
 8001a60:	43db      	mvns	r3, r3
 8001a62:	b29b      	uxth	r3, r3
 8001a64:	460a      	mov	r2, r1
 8001a66:	4013      	ands	r3, r2
 8001a68:	b29b      	uxth	r3, r3
 8001a6a:	b29a      	uxth	r2, r3
 8001a6c:	9b01      	ldr	r3, [sp, #4]
 8001a6e:	811a      	strh	r2, [r3, #8]
 8001a70:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001a74:	9a01      	ldr	r2, [sp, #4]
 8001a76:	3302      	adds	r3, #2
 8001a78:	009b      	lsls	r3, r3, #2
 8001a7a:	4413      	add	r3, r2
 8001a7c:	685b      	ldr	r3, [r3, #4]
 8001a7e:	689b      	ldr	r3, [r3, #8]
 8001a80:	2b00      	cmp	r3, #0
 8001a82:	d00c      	beq.n	8001a9e <otg_isoc_in_failed_handler+0xce>
 8001a84:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001a88:	9a01      	ldr	r2, [sp, #4]
 8001a8a:	3302      	adds	r3, #2
 8001a8c:	009b      	lsls	r3, r3, #2
 8001a8e:	4413      	add	r3, r2
 8001a90:	685b      	ldr	r3, [r3, #4]
 8001a92:	689b      	ldr	r3, [r3, #8]
 8001a94:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8001a98:	9801      	ldr	r0, [sp, #4]
 8001a9a:	4611      	mov	r1, r2
 8001a9c:	4798      	blx	r3
 8001a9e:	f001 feb7 	bl	8003810 <osalSysLockFromISR.lto_priv.173>
 8001aa2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001aa6:	9a01      	ldr	r2, [sp, #4]
 8001aa8:	3302      	adds	r3, #2
 8001aaa:	009b      	lsls	r3, r3, #2
 8001aac:	4413      	add	r3, r2
 8001aae:	685b      	ldr	r3, [r3, #4]
 8001ab0:	695b      	ldr	r3, [r3, #20]
 8001ab2:	330c      	adds	r3, #12
 8001ab4:	4618      	mov	r0, r3
 8001ab6:	2100      	movs	r1, #0
 8001ab8:	f001 feda 	bl	8003870 <osalThreadResumeI.lto_priv.172>
 8001abc:	f001 feb0 	bl	8003820 <osalSysUnlockFromISR.lto_priv.171>

      /* Pump out data for next frame */
      osalSysLockFromISR();
 8001ac0:	f001 fea6 	bl	8003810 <osalSysLockFromISR.lto_priv.173>
      otgp->DIEPEMPMSK &= ~(1 << ep);
 8001ac4:	9b02      	ldr	r3, [sp, #8]
 8001ac6:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
 8001aca:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8001ace:	2101      	movs	r1, #1
 8001ad0:	fa01 f202 	lsl.w	r2, r1, r2
 8001ad4:	43d2      	mvns	r2, r2
 8001ad6:	401a      	ands	r2, r3
 8001ad8:	9b02      	ldr	r3, [sp, #8]
 8001ada:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
      usbp->txpending |= (1 << ep);
 8001ade:	9b01      	ldr	r3, [sp, #4]
 8001ae0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8001ae2:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8001ae6:	2101      	movs	r1, #1
 8001ae8:	fa01 f202 	lsl.w	r2, r1, r2
 8001aec:	431a      	orrs	r2, r3
 8001aee:	9b01      	ldr	r3, [sp, #4]
 8001af0:	65da      	str	r2, [r3, #92]	; 0x5c
      osalThreadResumeI(&usbp->wait, MSG_OK);
 8001af2:	9b01      	ldr	r3, [sp, #4]
 8001af4:	3360      	adds	r3, #96	; 0x60
 8001af6:	4618      	mov	r0, r3
 8001af8:	2100      	movs	r1, #0
 8001afa:	f001 feb9 	bl	8003870 <osalThreadResumeI.lto_priv.172>
      osalSysUnlockFromISR();
 8001afe:	f001 fe8f 	bl	8003820 <osalSysUnlockFromISR.lto_priv.171>
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8001b02:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001b06:	3301      	adds	r3, #1
 8001b08:	f88d 300f 	strb.w	r3, [sp, #15]
 8001b0c:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8001b10:	9b01      	ldr	r3, [sp, #4]
 8001b12:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8001b14:	689b      	ldr	r3, [r3, #8]
 8001b16:	429a      	cmp	r2, r3
 8001b18:	f67f af64 	bls.w	80019e4 <otg_isoc_in_failed_handler+0x14>
      usbp->txpending |= (1 << ep);
      osalThreadResumeI(&usbp->wait, MSG_OK);
      osalSysUnlockFromISR();
    }
  }
}
 8001b1c:	b005      	add	sp, #20
 8001b1e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001b22:	bf00      	nop
	...

08001b30 <otg_isoc_out_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
 8001b30:	b500      	push	{lr}
 8001b32:	b085      	sub	sp, #20
 8001b34:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8001b36:	9b01      	ldr	r3, [sp, #4]
 8001b38:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001b3a:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8001b3c:	2300      	movs	r3, #0
 8001b3e:	f88d 300f 	strb.w	r3, [sp, #15]
 8001b42:	e05c      	b.n	8001bfe <otg_isoc_out_failed_handler+0xce>
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8001b44:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001b48:	9a02      	ldr	r2, [sp, #8]
 8001b4a:	3358      	adds	r3, #88	; 0x58
 8001b4c:	015b      	lsls	r3, r3, #5
 8001b4e:	4413      	add	r3, r2
 8001b50:	681b      	ldr	r3, [r3, #0]
 8001b52:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8001b56:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8001b5a:	d14b      	bne.n	8001bf4 <otg_isoc_out_failed_handler+0xc4>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 8001b5c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001b60:	9a02      	ldr	r2, [sp, #8]
 8001b62:	3358      	adds	r3, #88	; 0x58
 8001b64:	015b      	lsls	r3, r3, #5
 8001b66:	4413      	add	r3, r2
 8001b68:	681b      	ldr	r3, [r3, #0]
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8001b6a:	2b00      	cmp	r3, #0
 8001b6c:	da42      	bge.n	8001bf4 <otg_isoc_out_failed_handler+0xc4>
      /* FIXME: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
 8001b6e:	9b01      	ldr	r3, [sp, #4]
 8001b70:	895b      	ldrh	r3, [r3, #10]
 8001b72:	b299      	uxth	r1, r3
 8001b74:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001b78:	2201      	movs	r2, #1
 8001b7a:	fa02 f303 	lsl.w	r3, r2, r3
 8001b7e:	b29b      	uxth	r3, r3
 8001b80:	43db      	mvns	r3, r3
 8001b82:	b29b      	uxth	r3, r3
 8001b84:	460a      	mov	r2, r1
 8001b86:	4013      	ands	r3, r2
 8001b88:	b29b      	uxth	r3, r3
 8001b8a:	b29a      	uxth	r2, r3
 8001b8c:	9b01      	ldr	r3, [sp, #4]
 8001b8e:	815a      	strh	r2, [r3, #10]
 8001b90:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001b94:	9a01      	ldr	r2, [sp, #4]
 8001b96:	3302      	adds	r3, #2
 8001b98:	009b      	lsls	r3, r3, #2
 8001b9a:	4413      	add	r3, r2
 8001b9c:	685b      	ldr	r3, [r3, #4]
 8001b9e:	68db      	ldr	r3, [r3, #12]
 8001ba0:	2b00      	cmp	r3, #0
 8001ba2:	d00c      	beq.n	8001bbe <otg_isoc_out_failed_handler+0x8e>
 8001ba4:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001ba8:	9a01      	ldr	r2, [sp, #4]
 8001baa:	3302      	adds	r3, #2
 8001bac:	009b      	lsls	r3, r3, #2
 8001bae:	4413      	add	r3, r2
 8001bb0:	685b      	ldr	r3, [r3, #4]
 8001bb2:	68db      	ldr	r3, [r3, #12]
 8001bb4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8001bb8:	9801      	ldr	r0, [sp, #4]
 8001bba:	4611      	mov	r1, r2
 8001bbc:	4798      	blx	r3
 8001bbe:	f001 fe27 	bl	8003810 <osalSysLockFromISR.lto_priv.173>
 8001bc2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001bc6:	9a01      	ldr	r2, [sp, #4]
 8001bc8:	3302      	adds	r3, #2
 8001bca:	009b      	lsls	r3, r3, #2
 8001bcc:	4413      	add	r3, r2
 8001bce:	685b      	ldr	r3, [r3, #4]
 8001bd0:	699b      	ldr	r3, [r3, #24]
 8001bd2:	f103 010c 	add.w	r1, r3, #12
 8001bd6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001bda:	9a01      	ldr	r2, [sp, #4]
 8001bdc:	3302      	adds	r3, #2
 8001bde:	009b      	lsls	r3, r3, #2
 8001be0:	4413      	add	r3, r2
 8001be2:	685b      	ldr	r3, [r3, #4]
 8001be4:	699b      	ldr	r3, [r3, #24]
 8001be6:	685b      	ldr	r3, [r3, #4]
 8001be8:	4608      	mov	r0, r1
 8001bea:	4619      	mov	r1, r3
 8001bec:	f001 fe40 	bl	8003870 <osalThreadResumeI.lto_priv.172>
 8001bf0:	f001 fe16 	bl	8003820 <osalSysUnlockFromISR.lto_priv.171>
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8001bf4:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001bf8:	3301      	adds	r3, #1
 8001bfa:	f88d 300f 	strb.w	r3, [sp, #15]
 8001bfe:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8001c02:	9b01      	ldr	r3, [sp, #4]
 8001c04:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8001c06:	689b      	ldr	r3, [r3, #8]
 8001c08:	429a      	cmp	r2, r3
 8001c0a:	d99b      	bls.n	8001b44 <otg_isoc_out_failed_handler+0x14>
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
    }
  }
}
 8001c0c:	b005      	add	sp, #20
 8001c0e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001c12:	bf00      	nop
	...

08001c20 <usb_lld_serve_interrupt>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 8001c20:	b500      	push	{lr}
 8001c22:	b087      	sub	sp, #28
 8001c24:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8001c26:	9b01      	ldr	r3, [sp, #4]
 8001c28:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001c2a:	9305      	str	r3, [sp, #20]
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 8001c2c:	9b05      	ldr	r3, [sp, #20]
 8001c2e:	695b      	ldr	r3, [r3, #20]
 8001c30:	9304      	str	r3, [sp, #16]
  sts &= otgp->GINTMSK;
 8001c32:	9b05      	ldr	r3, [sp, #20]
 8001c34:	699b      	ldr	r3, [r3, #24]
 8001c36:	9a04      	ldr	r2, [sp, #16]
 8001c38:	4013      	ands	r3, r2
 8001c3a:	9304      	str	r3, [sp, #16]
  otgp->GINTSTS = sts;
 8001c3c:	9b05      	ldr	r3, [sp, #20]
 8001c3e:	9a04      	ldr	r2, [sp, #16]
 8001c40:	615a      	str	r2, [r3, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 8001c42:	9b04      	ldr	r3, [sp, #16]
 8001c44:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8001c48:	2b00      	cmp	r3, #0
 8001c4a:	d006      	beq.n	8001c5a <usb_lld_serve_interrupt+0x3a>

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 8001c4c:	9b01      	ldr	r3, [sp, #4]
 8001c4e:	2200      	movs	r2, #0
 8001c50:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Default reset action.*/
    _usb_reset(usbp);
 8001c52:	9801      	ldr	r0, [sp, #4]
 8001c54:	f002 fb64 	bl	8004320 <_usb_reset>
 8001c58:	e0ce      	b.n	8001df8 <usb_lld_serve_interrupt+0x1d8>
    /* Preventing execution of more handlers, the core has been reset.*/
    return;
  }

  /* Wake-up handling.*/
  if (sts & GINTSTS_WKUPINT) {
 8001c5a:	9b04      	ldr	r3, [sp, #16]
 8001c5c:	2b00      	cmp	r3, #0
 8001c5e:	da19      	bge.n	8001c94 <usb_lld_serve_interrupt+0x74>
    /* If clocks are gated off, turn them back on (may be the case if
       coming out of suspend mode).*/
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8001c60:	9b05      	ldr	r3, [sp, #20]
 8001c62:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8001c66:	f003 0303 	and.w	r3, r3, #3
 8001c6a:	2b00      	cmp	r3, #0
 8001c6c:	d007      	beq.n	8001c7e <usb_lld_serve_interrupt+0x5e>
      /* Set to zero to un-gate the USB core clocks.*/
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 8001c6e:	9b05      	ldr	r3, [sp, #20]
 8001c70:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8001c74:	f023 0203 	bic.w	r2, r3, #3
 8001c78:	9b05      	ldr	r3, [sp, #20]
 8001c7a:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
    }

    /* Clear the Remote Wake-up Signaling.*/
    otgp->DCTL |= DCTL_RWUSIG;
 8001c7e:	9b05      	ldr	r3, [sp, #20]
 8001c80:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
 8001c84:	f043 0201 	orr.w	r2, r3, #1
 8001c88:	9b05      	ldr	r3, [sp, #20]
 8001c8a:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804

    _usb_wakeup(usbp);
 8001c8e:	9801      	ldr	r0, [sp, #4]
 8001c90:	f002 fc16 	bl	80044c0 <_usb_wakeup>
  }

  /* Suspend handling.*/
  if (sts & GINTSTS_USBSUSP) {
 8001c94:	9b04      	ldr	r3, [sp, #16]
 8001c96:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8001c9a:	2b00      	cmp	r3, #0
 8001c9c:	d005      	beq.n	8001caa <usb_lld_serve_interrupt+0x8a>

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 8001c9e:	9b01      	ldr	r3, [sp, #4]
 8001ca0:	2200      	movs	r2, #0
 8001ca2:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Default suspend action.*/
    _usb_suspend(usbp);
 8001ca4:	9801      	ldr	r0, [sp, #4]
 8001ca6:	f002 fbb3 	bl	8004410 <_usb_suspend>
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 8001caa:	9b04      	ldr	r3, [sp, #16]
 8001cac:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8001cb0:	2b00      	cmp	r3, #0
 8001cb2:	d017      	beq.n	8001ce4 <usb_lld_serve_interrupt+0xc4>
    /* Full or High speed timing selection.*/
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8001cb4:	9b05      	ldr	r3, [sp, #20]
 8001cb6:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 8001cba:	f003 0306 	and.w	r3, r3, #6
 8001cbe:	2b00      	cmp	r3, #0
 8001cc0:	d108      	bne.n	8001cd4 <usb_lld_serve_interrupt+0xb4>
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8001cc2:	9b05      	ldr	r3, [sp, #20]
 8001cc4:	68db      	ldr	r3, [r3, #12]
 8001cc6:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8001cca:	f443 5210 	orr.w	r2, r3, #9216	; 0x2400
 8001cce:	9b05      	ldr	r3, [sp, #20]
 8001cd0:	60da      	str	r2, [r3, #12]
 8001cd2:	e007      	b.n	8001ce4 <usb_lld_serve_interrupt+0xc4>
                      GUSBCFG_TRDT(TRDT_VALUE_HS);
    }
    else {
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8001cd4:	9b05      	ldr	r3, [sp, #20]
 8001cd6:	68db      	ldr	r3, [r3, #12]
 8001cd8:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8001cdc:	f443 52a0 	orr.w	r2, r3, #5120	; 0x1400
 8001ce0:	9b05      	ldr	r3, [sp, #20]
 8001ce2:	60da      	str	r2, [r3, #12]
                      GUSBCFG_TRDT(TRDT_VALUE_FS);
    }
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 8001ce4:	9b04      	ldr	r3, [sp, #16]
 8001ce6:	f003 0308 	and.w	r3, r3, #8
 8001cea:	2b00      	cmp	r3, #0
 8001cec:	d009      	beq.n	8001d02 <usb_lld_serve_interrupt+0xe2>
    _usb_isr_invoke_sof_cb(usbp);
 8001cee:	9b01      	ldr	r3, [sp, #4]
 8001cf0:	685b      	ldr	r3, [r3, #4]
 8001cf2:	68db      	ldr	r3, [r3, #12]
 8001cf4:	2b00      	cmp	r3, #0
 8001cf6:	d004      	beq.n	8001d02 <usb_lld_serve_interrupt+0xe2>
 8001cf8:	9b01      	ldr	r3, [sp, #4]
 8001cfa:	685b      	ldr	r3, [r3, #4]
 8001cfc:	68db      	ldr	r3, [r3, #12]
 8001cfe:	9801      	ldr	r0, [sp, #4]
 8001d00:	4798      	blx	r3
  }

  /* Isochronous IN failed handling */
  if (sts & GINTSTS_IISOIXFR) {
 8001d02:	9b04      	ldr	r3, [sp, #16]
 8001d04:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8001d08:	2b00      	cmp	r3, #0
 8001d0a:	d002      	beq.n	8001d12 <usb_lld_serve_interrupt+0xf2>
    otg_isoc_in_failed_handler(usbp);
 8001d0c:	9801      	ldr	r0, [sp, #4]
 8001d0e:	f7ff fe5f 	bl	80019d0 <otg_isoc_in_failed_handler>
  }

  /* Isochronous OUT failed handling */
  if (sts & GINTSTS_IISOOXFR) {
 8001d12:	9b04      	ldr	r3, [sp, #16]
 8001d14:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8001d18:	2b00      	cmp	r3, #0
 8001d1a:	d002      	beq.n	8001d22 <usb_lld_serve_interrupt+0x102>
    otg_isoc_out_failed_handler(usbp);
 8001d1c:	9801      	ldr	r0, [sp, #4]
 8001d1e:	f7ff ff07 	bl	8001b30 <otg_isoc_out_failed_handler>
  }

  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
 8001d22:	9b04      	ldr	r3, [sp, #16]
 8001d24:	f003 0310 	and.w	r3, r3, #16
 8001d28:	2b00      	cmp	r3, #0
 8001d2a:	d00f      	beq.n	8001d4c <usb_lld_serve_interrupt+0x12c>
    /* The interrupt is masked while the thread has control or it would
       be triggered again.*/
    osalSysLockFromISR();
 8001d2c:	f001 fd70 	bl	8003810 <osalSysLockFromISR.lto_priv.173>
    otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
 8001d30:	9b05      	ldr	r3, [sp, #20]
 8001d32:	699b      	ldr	r3, [r3, #24]
 8001d34:	f023 0210 	bic.w	r2, r3, #16
 8001d38:	9b05      	ldr	r3, [sp, #20]
 8001d3a:	619a      	str	r2, [r3, #24]
    osalThreadResumeI(&usbp->wait, MSG_OK);
 8001d3c:	9b01      	ldr	r3, [sp, #4]
 8001d3e:	3360      	adds	r3, #96	; 0x60
 8001d40:	4618      	mov	r0, r3
 8001d42:	2100      	movs	r1, #0
 8001d44:	f001 fd94 	bl	8003870 <osalThreadResumeI.lto_priv.172>
    osalSysUnlockFromISR();
 8001d48:	f001 fd6a 	bl	8003820 <osalSysUnlockFromISR.lto_priv.171>
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 8001d4c:	9b05      	ldr	r3, [sp, #20]
 8001d4e:	f8d3 3818 	ldr.w	r3, [r3, #2072]	; 0x818
 8001d52:	9303      	str	r3, [sp, #12]
  if (sts & GINTSTS_IEPINT) {
 8001d54:	9b04      	ldr	r3, [sp, #16]
 8001d56:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8001d5a:	2b00      	cmp	r3, #0
 8001d5c:	d023      	beq.n	8001da6 <usb_lld_serve_interrupt+0x186>
    if (src & (1 << 0))
 8001d5e:	9b03      	ldr	r3, [sp, #12]
 8001d60:	f003 0301 	and.w	r3, r3, #1
 8001d64:	2b00      	cmp	r3, #0
 8001d66:	d003      	beq.n	8001d70 <usb_lld_serve_interrupt+0x150>
      otg_epin_handler(usbp, 0);
 8001d68:	9801      	ldr	r0, [sp, #4]
 8001d6a:	2100      	movs	r1, #0
 8001d6c:	f7ff fcb8 	bl	80016e0 <otg_epin_handler>
    if (src & (1 << 1))
 8001d70:	9b03      	ldr	r3, [sp, #12]
 8001d72:	f003 0302 	and.w	r3, r3, #2
 8001d76:	2b00      	cmp	r3, #0
 8001d78:	d003      	beq.n	8001d82 <usb_lld_serve_interrupt+0x162>
      otg_epin_handler(usbp, 1);
 8001d7a:	9801      	ldr	r0, [sp, #4]
 8001d7c:	2101      	movs	r1, #1
 8001d7e:	f7ff fcaf 	bl	80016e0 <otg_epin_handler>
    if (src & (1 << 2))
 8001d82:	9b03      	ldr	r3, [sp, #12]
 8001d84:	f003 0304 	and.w	r3, r3, #4
 8001d88:	2b00      	cmp	r3, #0
 8001d8a:	d003      	beq.n	8001d94 <usb_lld_serve_interrupt+0x174>
      otg_epin_handler(usbp, 2);
 8001d8c:	9801      	ldr	r0, [sp, #4]
 8001d8e:	2102      	movs	r1, #2
 8001d90:	f7ff fca6 	bl	80016e0 <otg_epin_handler>
    if (src & (1 << 3))
 8001d94:	9b03      	ldr	r3, [sp, #12]
 8001d96:	f003 0308 	and.w	r3, r3, #8
 8001d9a:	2b00      	cmp	r3, #0
 8001d9c:	d003      	beq.n	8001da6 <usb_lld_serve_interrupt+0x186>
      otg_epin_handler(usbp, 3);
 8001d9e:	9801      	ldr	r0, [sp, #4]
 8001da0:	2103      	movs	r1, #3
 8001da2:	f7ff fc9d 	bl	80016e0 <otg_epin_handler>
      otg_epin_handler(usbp, 4);
    if (src & (1 << 5))
      otg_epin_handler(usbp, 5);
#endif
  }
  if (sts & GINTSTS_OEPINT) {
 8001da6:	9b04      	ldr	r3, [sp, #16]
 8001da8:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8001dac:	2b00      	cmp	r3, #0
 8001dae:	d023      	beq.n	8001df8 <usb_lld_serve_interrupt+0x1d8>
    if (src & (1 << 16))
 8001db0:	9b03      	ldr	r3, [sp, #12]
 8001db2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8001db6:	2b00      	cmp	r3, #0
 8001db8:	d003      	beq.n	8001dc2 <usb_lld_serve_interrupt+0x1a2>
      otg_epout_handler(usbp, 0);
 8001dba:	9801      	ldr	r0, [sp, #4]
 8001dbc:	2100      	movs	r1, #0
 8001dbe:	f7ff fd47 	bl	8001850 <otg_epout_handler>
    if (src & (1 << 17))
 8001dc2:	9b03      	ldr	r3, [sp, #12]
 8001dc4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001dc8:	2b00      	cmp	r3, #0
 8001dca:	d003      	beq.n	8001dd4 <usb_lld_serve_interrupt+0x1b4>
      otg_epout_handler(usbp, 1);
 8001dcc:	9801      	ldr	r0, [sp, #4]
 8001dce:	2101      	movs	r1, #1
 8001dd0:	f7ff fd3e 	bl	8001850 <otg_epout_handler>
    if (src & (1 << 18))
 8001dd4:	9b03      	ldr	r3, [sp, #12]
 8001dd6:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8001dda:	2b00      	cmp	r3, #0
 8001ddc:	d003      	beq.n	8001de6 <usb_lld_serve_interrupt+0x1c6>
      otg_epout_handler(usbp, 2);
 8001dde:	9801      	ldr	r0, [sp, #4]
 8001de0:	2102      	movs	r1, #2
 8001de2:	f7ff fd35 	bl	8001850 <otg_epout_handler>
    if (src & (1 << 19))
 8001de6:	9b03      	ldr	r3, [sp, #12]
 8001de8:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8001dec:	2b00      	cmp	r3, #0
 8001dee:	d003      	beq.n	8001df8 <usb_lld_serve_interrupt+0x1d8>
      otg_epout_handler(usbp, 3);
 8001df0:	9801      	ldr	r0, [sp, #4]
 8001df2:	2103      	movs	r1, #3
 8001df4:	f7ff fd2c 	bl	8001850 <otg_epout_handler>
      otg_epout_handler(usbp, 4);
    if (src & (1 << 21))
      otg_epout_handler(usbp, 5);
#endif
  }
}
 8001df8:	b007      	add	sp, #28
 8001dfa:	f85d fb04 	ldr.w	pc, [sp], #4
 8001dfe:	bf00      	nop

08001e00 <Vector14C>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8001e00:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);
 8001e02:	4803      	ldr	r0, [pc, #12]	; (8001e10 <Vector14C+0x10>)
 8001e04:	f7ff ff0c 	bl	8001c20 <usb_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8001e08:	f002 ff02 	bl	8004c10 <_port_irq_epilogue>
}
 8001e0c:	bd08      	pop	{r3, pc}
 8001e0e:	bf00      	nop
 8001e10:	20000a10 	.word	0x20000a10
	...

08001e20 <usb_lld_init>:
/**
 * @brief   Low level USB driver initialization.
 *
 * @notapi
 */
void usb_lld_init(void) {
 8001e20:	b500      	push	{lr}
 8001e22:	b083      	sub	sp, #12

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
 8001e24:	4813      	ldr	r0, [pc, #76]	; (8001e74 <usb_lld_init+0x54>)
 8001e26:	f002 f95b 	bl	80040e0 <usbObjectInit>
  USBD1.wait      = NULL;
 8001e2a:	4b12      	ldr	r3, [pc, #72]	; (8001e74 <usb_lld_init+0x54>)
 8001e2c:	2200      	movs	r2, #0
 8001e2e:	661a      	str	r2, [r3, #96]	; 0x60
  USBD1.otg       = OTG_FS;
 8001e30:	4b10      	ldr	r3, [pc, #64]	; (8001e74 <usb_lld_init+0x54>)
 8001e32:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 8001e36:	651a      	str	r2, [r3, #80]	; 0x50
  USBD1.otgparams = &fsparams;
 8001e38:	4b0e      	ldr	r3, [pc, #56]	; (8001e74 <usb_lld_init+0x54>)
 8001e3a:	4a0f      	ldr	r2, [pc, #60]	; (8001e78 <usb_lld_init+0x58>)
 8001e3c:	655a      	str	r2, [r3, #84]	; 0x54

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 8001e3e:	4b0d      	ldr	r3, [pc, #52]	; (8001e74 <usb_lld_init+0x54>)
 8001e40:	2200      	movs	r2, #0
 8001e42:	665a      	str	r2, [r3, #100]	; 0x64
  /* Filling the thread working area here because the function
     @p chThdCreateI() does not do it.*/
#if CH_DBG_FILL_THREADS
  {
    void *wsp = USBD1.wa_pump;
 8001e44:	4b0d      	ldr	r3, [pc, #52]	; (8001e7c <usb_lld_init+0x5c>)
 8001e46:	9301      	str	r3, [sp, #4]
    _thread_memfill((uint8_t *)wsp,
 8001e48:	9b01      	ldr	r3, [sp, #4]
 8001e4a:	3344      	adds	r3, #68	; 0x44
 8001e4c:	9801      	ldr	r0, [sp, #4]
 8001e4e:	4619      	mov	r1, r3
 8001e50:	22ff      	movs	r2, #255	; 0xff
 8001e52:	f003 fffd 	bl	8005e50 <_thread_memfill>
                    (uint8_t *)wsp + sizeof(thread_t),
                    CH_DBG_THREAD_FILL_VALUE);
    _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 8001e56:	9b01      	ldr	r3, [sp, #4]
 8001e58:	f103 0244 	add.w	r2, r3, #68	; 0x44
 8001e5c:	9b01      	ldr	r3, [sp, #4]
 8001e5e:	f503 73a4 	add.w	r3, r3, #328	; 0x148
 8001e62:	4610      	mov	r0, r2
 8001e64:	4619      	mov	r1, r3
 8001e66:	2255      	movs	r2, #85	; 0x55
 8001e68:	f003 fff2 	bl	8005e50 <_thread_memfill>
                    CH_DBG_STACK_FILL_VALUE);
  }
#endif /* CH_DBG_FILL_THREADS */
#endif /* defined(_CHIBIOS_RT_) */
#endif
}
 8001e6c:	b003      	add	sp, #12
 8001e6e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001e72:	bf00      	nop
 8001e74:	20000a10 	.word	0x20000a10
 8001e78:	08006ba0 	.word	0x08006ba0
 8001e7c:	20000a78 	.word	0x20000a78

08001e80 <usb_lld_start>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 8001e80:	b500      	push	{lr}
 8001e82:	b087      	sub	sp, #28
 8001e84:	9003      	str	r0, [sp, #12]
  stm32_otg_t *otgp = usbp->otg;
 8001e86:	9b03      	ldr	r3, [sp, #12]
 8001e88:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001e8a:	9305      	str	r3, [sp, #20]

  if (usbp->state == USB_STOP) {
 8001e8c:	9b03      	ldr	r3, [sp, #12]
 8001e8e:	781b      	ldrb	r3, [r3, #0]
 8001e90:	2b01      	cmp	r3, #1
 8001e92:	d170      	bne.n	8001f76 <usb_lld_start+0xf6>
    /* Clock activation.*/

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 8001e94:	9b03      	ldr	r3, [sp, #12]
 8001e96:	4a39      	ldr	r2, [pc, #228]	; (8001f7c <usb_lld_start+0xfc>)
 8001e98:	4293      	cmp	r3, r2
 8001e9a:	d119      	bne.n	8001ed0 <usb_lld_start+0x50>
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(false);
 8001e9c:	4a38      	ldr	r2, [pc, #224]	; (8001f80 <usb_lld_start+0x100>)
 8001e9e:	4b38      	ldr	r3, [pc, #224]	; (8001f80 <usb_lld_start+0x100>)
 8001ea0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001ea2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001ea6:	6353      	str	r3, [r2, #52]	; 0x34
      rccResetOTG_FS();
 8001ea8:	4a35      	ldr	r2, [pc, #212]	; (8001f80 <usb_lld_start+0x100>)
 8001eaa:	4b35      	ldr	r3, [pc, #212]	; (8001f80 <usb_lld_start+0x100>)
 8001eac:	695b      	ldr	r3, [r3, #20]
 8001eae:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001eb2:	6153      	str	r3, [r2, #20]
 8001eb4:	4b32      	ldr	r3, [pc, #200]	; (8001f80 <usb_lld_start+0x100>)
 8001eb6:	2200      	movs	r2, #0
 8001eb8:	615a      	str	r2, [r3, #20]

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 8001eba:	2043      	movs	r0, #67	; 0x43
 8001ebc:	210e      	movs	r1, #14
 8001ebe:	f002 fc9f 	bl	8004800 <nvicEnableVector>

      /* - Forced device mode.
         - USB turn-around time = TRDT_VALUE_FS.
         - Full Speed 1.1 PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8001ec2:	9b05      	ldr	r3, [sp, #20]
 8001ec4:	4a2f      	ldr	r2, [pc, #188]	; (8001f84 <usb_lld_start+0x104>)
 8001ec6:	60da      	str	r2, [r3, #12]
                      GUSBCFG_PHYSEL;

      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8001ec8:	9b05      	ldr	r3, [sp, #20]
 8001eca:	4a2f      	ldr	r2, [pc, #188]	; (8001f88 <usb_lld_start+0x108>)
 8001ecc:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
#endif
    }
#endif

    /* Clearing mask of TXFIFOs to be filled.*/
    usbp->txpending = 0;
 8001ed0:	9b03      	ldr	r3, [sp, #12]
 8001ed2:	2200      	movs	r2, #0
 8001ed4:	65da      	str	r2, [r3, #92]	; 0x5c

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;
 8001ed6:	9b05      	ldr	r3, [sp, #20]
 8001ed8:	2200      	movs	r2, #0
 8001eda:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00

    /* VBUS sensing and transceiver enabled.*/
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8001ede:	9b05      	ldr	r3, [sp, #20]
 8001ee0:	22c0      	movs	r2, #192	; 0xc0
 8001ee2:	601a      	str	r2, [r3, #0]
    if (&USBD2 == usbp) {
      otgp->GCCFG = 0;
    }
#endif
#else
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8001ee4:	9b05      	ldr	r3, [sp, #20]
 8001ee6:	f44f 2250 	mov.w	r2, #851968	; 0xd0000
 8001eea:	639a      	str	r2, [r3, #56]	; 0x38
#endif

    /* Soft core reset.*/
    otg_core_reset(usbp);
 8001eec:	9803      	ldr	r0, [sp, #12]
 8001eee:	f001 fccf 	bl	8003890 <otg_core_reset.lto_priv.170>

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 8001ef2:	9b05      	ldr	r3, [sp, #20]
 8001ef4:	2200      	movs	r2, #0
 8001ef6:	609a      	str	r2, [r3, #8]

    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);
 8001ef8:	9803      	ldr	r0, [sp, #12]
 8001efa:	f001 fce9 	bl	80038d0 <otg_disable_ep.lto_priv.164>

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 8001efe:	9b05      	ldr	r3, [sp, #20]
 8001f00:	2200      	movs	r2, #0
 8001f02:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 8001f06:	9b05      	ldr	r3, [sp, #20]
 8001f08:	2200      	movs	r2, #0
 8001f0a:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 8001f0e:	9b05      	ldr	r3, [sp, #20]
 8001f10:	2200      	movs	r2, #0
 8001f12:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 8001f16:	9b03      	ldr	r3, [sp, #12]
 8001f18:	685b      	ldr	r3, [r3, #4]
 8001f1a:	68db      	ldr	r3, [r3, #12]
 8001f1c:	2b00      	cmp	r3, #0
 8001f1e:	d103      	bne.n	8001f28 <usb_lld_start+0xa8>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8001f20:	9b05      	ldr	r3, [sp, #20]
 8001f22:	4a1a      	ldr	r2, [pc, #104]	; (8001f8c <usb_lld_start+0x10c>)
 8001f24:	619a      	str	r2, [r3, #24]
 8001f26:	e002      	b.n	8001f2e <usb_lld_start+0xae>
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8001f28:	9b05      	ldr	r3, [sp, #20]
 8001f2a:	4a19      	ldr	r2, [pc, #100]	; (8001f90 <usb_lld_start+0x110>)
 8001f2c:	619a      	str	r2, [r3, #24]
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM |
                       GINTMSK_SOFM;

    /* Clears all pending IRQs, if any. */
    otgp->GINTSTS  = 0xFFFFFFFF;
 8001f2e:	9b05      	ldr	r3, [sp, #20]
 8001f30:	f04f 32ff 	mov.w	r2, #4294967295
 8001f34:	615a      	str	r2, [r3, #20]

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 8001f36:	9b03      	ldr	r3, [sp, #12]
 8001f38:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8001f3a:	2b00      	cmp	r3, #0
 8001f3c:	d115      	bne.n	8001f6a <usb_lld_start+0xea>
      usbp->tr = chThdCreateI(usbp->wa_pump, sizeof usbp->wa_pump,
 8001f3e:	9b03      	ldr	r3, [sp, #12]
 8001f40:	f103 0268 	add.w	r2, r3, #104	; 0x68
 8001f44:	9b03      	ldr	r3, [sp, #12]
 8001f46:	9300      	str	r3, [sp, #0]
 8001f48:	4610      	mov	r0, r2
 8001f4a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001f4e:	2202      	movs	r2, #2
 8001f50:	4b10      	ldr	r3, [pc, #64]	; (8001f94 <usb_lld_start+0x114>)
 8001f52:	f003 ff95 	bl	8005e80 <chThdCreateI>
 8001f56:	4602      	mov	r2, r0
 8001f58:	9b03      	ldr	r3, [sp, #12]
 8001f5a:	665a      	str	r2, [r3, #100]	; 0x64
                              STM32_USB_OTG_THREAD_PRIO,
                              usb_lld_pump, usbp);
      chThdStartI(usbp->tr);
 8001f5c:	9b03      	ldr	r3, [sp, #12]
 8001f5e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8001f60:	4618      	mov	r0, r3
 8001f62:	f001 fc25 	bl	80037b0 <chThdStartI.lto_priv.169>
      chSchRescheduleS();
 8001f66:	f003 fe43 	bl	8005bf0 <chSchRescheduleS>
  }
#endif

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8001f6a:	9b05      	ldr	r3, [sp, #20]
 8001f6c:	689b      	ldr	r3, [r3, #8]
 8001f6e:	f043 0201 	orr.w	r2, r3, #1
 8001f72:	9b05      	ldr	r3, [sp, #20]
 8001f74:	609a      	str	r2, [r3, #8]
  }
}
 8001f76:	b007      	add	sp, #28
 8001f78:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f7c:	20000a10 	.word	0x20000a10
 8001f80:	40023800 	.word	0x40023800
 8001f84:	40001440 	.word	0x40001440
 8001f88:	02200003 	.word	0x02200003
 8001f8c:	c0303c00 	.word	0xc0303c00
 8001f90:	c0303c08 	.word	0xc0303c08
 8001f94:	08000c41 	.word	0x08000c41
	...

08001fa0 <usb_lld_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 8001fa0:	b510      	push	{r4, lr}
 8001fa2:	b084      	sub	sp, #16
 8001fa4:	9001      	str	r0, [sp, #4]
  unsigned i;
  stm32_otg_t *otgp = usbp->otg;
 8001fa6:	9b01      	ldr	r3, [sp, #4]
 8001fa8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001faa:	9302      	str	r3, [sp, #8]

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);
 8001fac:	9801      	ldr	r0, [sp, #4]
 8001fae:	2100      	movs	r1, #0
 8001fb0:	f001 fcee 	bl	8003990 <otg_txfifo_flush.lto_priv.166>

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
 8001fb4:	9b02      	ldr	r3, [sp, #8]
 8001fb6:	2200      	movs	r2, #0
 8001fb8:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8001fbc:	9b02      	ldr	r3, [sp, #8]
 8001fbe:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8001fc2:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8001fc6:	2300      	movs	r3, #0
 8001fc8:	9303      	str	r3, [sp, #12]
 8001fca:	e024      	b.n	8002016 <usb_lld_reset+0x76>
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8001fcc:	9a02      	ldr	r2, [sp, #8]
 8001fce:	9b03      	ldr	r3, [sp, #12]
 8001fd0:	3348      	adds	r3, #72	; 0x48
 8001fd2:	015b      	lsls	r3, r3, #5
 8001fd4:	4413      	add	r3, r2
 8001fd6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001fda:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 8001fdc:	9a02      	ldr	r2, [sp, #8]
 8001fde:	9b03      	ldr	r3, [sp, #12]
 8001fe0:	3358      	adds	r3, #88	; 0x58
 8001fe2:	015b      	lsls	r3, r3, #5
 8001fe4:	4413      	add	r3, r2
 8001fe6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001fea:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8001fec:	9a02      	ldr	r2, [sp, #8]
 8001fee:	9b03      	ldr	r3, [sp, #12]
 8001ff0:	015b      	lsls	r3, r3, #5
 8001ff2:	4413      	add	r3, r2
 8001ff4:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8001ff8:	f04f 32ff 	mov.w	r2, #4294967295
 8001ffc:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8001ffe:	9a02      	ldr	r2, [sp, #8]
 8002000:	9b03      	ldr	r3, [sp, #12]
 8002002:	015b      	lsls	r3, r3, #5
 8002004:	4413      	add	r3, r2
 8002006:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 800200a:	f04f 32ff 	mov.w	r2, #4294967295
 800200e:	601a      	str	r2, [r3, #0]
  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8002010:	9b03      	ldr	r3, [sp, #12]
 8002012:	3301      	adds	r3, #1
 8002014:	9303      	str	r3, [sp, #12]
 8002016:	9b01      	ldr	r3, [sp, #4]
 8002018:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800201a:	689a      	ldr	r2, [r3, #8]
 800201c:	9b03      	ldr	r3, [sp, #12]
 800201e:	429a      	cmp	r2, r3
 8002020:	d2d4      	bcs.n	8001fcc <usb_lld_reset+0x2c>
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 8002022:	9801      	ldr	r0, [sp, #4]
 8002024:	f001 fcd4 	bl	80039d0 <otg_ram_reset.lto_priv.165>

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 8002028:	9b01      	ldr	r3, [sp, #4]
 800202a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800202c:	681a      	ldr	r2, [r3, #0]
 800202e:	9b02      	ldr	r3, [sp, #8]
 8002030:	625a      	str	r2, [r3, #36]	; 0x24
  otg_rxfifo_flush(usbp);
 8002032:	9801      	ldr	r0, [sp, #4]
 8002034:	f001 fc94 	bl	8003960 <otg_rxfifo_flush.lto_priv.168>

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8002038:	9b02      	ldr	r3, [sp, #8]
 800203a:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 800203e:	f423 62fe 	bic.w	r2, r3, #2032	; 0x7f0
 8002042:	9b02      	ldr	r3, [sp, #8]
 8002044:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8002048:	9b02      	ldr	r3, [sp, #8]
 800204a:	699b      	ldr	r3, [r3, #24]
 800204c:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 8002050:	f043 0310 	orr.w	r3, r3, #16
 8002054:	9a02      	ldr	r2, [sp, #8]
 8002056:	6193      	str	r3, [r2, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8002058:	9b02      	ldr	r3, [sp, #8]
 800205a:	2209      	movs	r2, #9
 800205c:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8002060:	9b02      	ldr	r3, [sp, #8]
 8002062:	2209      	movs	r2, #9
 8002064:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8002068:	9b01      	ldr	r3, [sp, #4]
 800206a:	4a16      	ldr	r2, [pc, #88]	; (80020c4 <usb_lld_reset+0x124>)
 800206c:	60da      	str	r2, [r3, #12]
  otgp->oe[0].DOEPTSIZ = 0;
 800206e:	9b02      	ldr	r3, [sp, #8]
 8002070:	2200      	movs	r2, #0
 8002072:	f8c3 2b10 	str.w	r2, [r3, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
 8002076:	2340      	movs	r3, #64	; 0x40
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8002078:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800207c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002080:	9a02      	ldr	r2, [sp, #8]
 8002082:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
 8002086:	9b02      	ldr	r3, [sp, #8]
 8002088:	2200      	movs	r2, #0
 800208a:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
 800208e:	2340      	movs	r3, #64	; 0x40
 8002090:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002094:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 8002098:	9a02      	ldr	r2, [sp, #8]
 800209a:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 800209e:	2340      	movs	r3, #64	; 0x40
 80020a0:	089b      	lsrs	r3, r3, #2
 80020a2:	b29b      	uxth	r3, r3
 80020a4:	041b      	lsls	r3, r3, #16
 80020a6:	461c      	mov	r4, r3
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
 80020a8:	2340      	movs	r3, #64	; 0x40
 80020aa:	089b      	lsrs	r3, r3, #2
 80020ac:	b29b      	uxth	r3, r3
 80020ae:	9801      	ldr	r0, [sp, #4]
 80020b0:	4619      	mov	r1, r3
 80020b2:	f001 fc9d 	bl	80039f0 <otg_ram_alloc.lto_priv.167>
 80020b6:	4603      	mov	r3, r0
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 80020b8:	ea44 0203 	orr.w	r2, r4, r3
 80020bc:	9b02      	ldr	r3, [sp, #8]
 80020be:	629a      	str	r2, [r3, #40]	; 0x28
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
                                                  ep0config.in_maxsize / 4));
}
 80020c0:	b004      	add	sp, #16
 80020c2:	bd10      	pop	{r4, pc}
 80020c4:	08006b70 	.word	0x08006b70
	...

080020d0 <usb_lld_set_address>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
 80020d0:	b084      	sub	sp, #16
 80020d2:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 80020d4:	9b01      	ldr	r3, [sp, #4]
 80020d6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80020d8:	9303      	str	r3, [sp, #12]

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 80020da:	9b03      	ldr	r3, [sp, #12]
 80020dc:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 80020e0:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80020e4:	9a01      	ldr	r2, [sp, #4]
 80020e6:	f892 204e 	ldrb.w	r2, [r2, #78]	; 0x4e
 80020ea:	0112      	lsls	r2, r2, #4
 80020ec:	431a      	orrs	r2, r3
 80020ee:	9b03      	ldr	r3, [sp, #12]
 80020f0:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
}
 80020f4:	b004      	add	sp, #16
 80020f6:	4770      	bx	lr
	...

08002100 <usb_lld_init_endpoint>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8002100:	b530      	push	{r4, r5, lr}
 8002102:	b087      	sub	sp, #28
 8002104:	9001      	str	r0, [sp, #4]
 8002106:	460b      	mov	r3, r1
 8002108:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;
 800210c:	9b01      	ldr	r3, [sp, #4]
 800210e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8002110:	9303      	str	r3, [sp, #12]

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8002112:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002116:	9a01      	ldr	r2, [sp, #4]
 8002118:	3302      	adds	r3, #2
 800211a:	009b      	lsls	r3, r3, #2
 800211c:	4413      	add	r3, r2
 800211e:	685b      	ldr	r3, [r3, #4]
 8002120:	681b      	ldr	r3, [r3, #0]
 8002122:	f003 0303 	and.w	r3, r3, #3
 8002126:	2b03      	cmp	r3, #3
 8002128:	f200 8106 	bhi.w	8002338 <usb_lld_init_endpoint+0x238>
 800212c:	a201      	add	r2, pc, #4	; (adr r2, 8002134 <usb_lld_init_endpoint+0x34>)
 800212e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002132:	bf00      	nop
 8002134:	08002145 	.word	0x08002145
 8002138:	0800214b 	.word	0x0800214b
 800213c:	08002151 	.word	0x08002151
 8002140:	08002157 	.word	0x08002157
  case USB_EP_MODE_TYPE_CTRL:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 8002144:	4b7d      	ldr	r3, [pc, #500]	; (800233c <usb_lld_init_endpoint+0x23c>)
 8002146:	9305      	str	r3, [sp, #20]
 8002148:	e007      	b.n	800215a <usb_lld_init_endpoint+0x5a>
    break;
  case USB_EP_MODE_TYPE_ISOC:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
 800214a:	4b7d      	ldr	r3, [pc, #500]	; (8002340 <usb_lld_init_endpoint+0x240>)
 800214c:	9305      	str	r3, [sp, #20]
 800214e:	e004      	b.n	800215a <usb_lld_init_endpoint+0x5a>
    break;
  case USB_EP_MODE_TYPE_BULK:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 8002150:	4b7c      	ldr	r3, [pc, #496]	; (8002344 <usb_lld_init_endpoint+0x244>)
 8002152:	9305      	str	r3, [sp, #20]
 8002154:	e001      	b.n	800215a <usb_lld_init_endpoint+0x5a>
    break;
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 8002156:	4b7c      	ldr	r3, [pc, #496]	; (8002348 <usb_lld_init_endpoint+0x248>)
 8002158:	9305      	str	r3, [sp, #20]
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 800215a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800215e:	9a03      	ldr	r2, [sp, #12]
 8002160:	015b      	lsls	r3, r3, #5
 8002162:	4413      	add	r3, r2
 8002164:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 8002168:	2200      	movs	r2, #0
 800216a:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->out_state != NULL) {
 800216c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002170:	9a01      	ldr	r2, [sp, #4]
 8002172:	3302      	adds	r3, #2
 8002174:	009b      	lsls	r3, r3, #2
 8002176:	4413      	add	r3, r2
 8002178:	685b      	ldr	r3, [r3, #4]
 800217a:	699b      	ldr	r3, [r3, #24]
 800217c:	2b00      	cmp	r3, #0
 800217e:	d020      	beq.n	80021c2 <usb_lld_init_endpoint+0xc2>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8002180:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8002184:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002188:	9a01      	ldr	r2, [sp, #4]
 800218a:	3302      	adds	r3, #2
 800218c:	009b      	lsls	r3, r3, #2
 800218e:	4413      	add	r3, r2
 8002190:	685b      	ldr	r3, [r3, #4]
 8002192:	8a5b      	ldrh	r3, [r3, #18]
 8002194:	461a      	mov	r2, r3
 8002196:	9b05      	ldr	r3, [sp, #20]
 8002198:	431a      	orrs	r2, r3
 800219a:	9903      	ldr	r1, [sp, #12]
 800219c:	f100 0358 	add.w	r3, r0, #88	; 0x58
 80021a0:	015b      	lsls	r3, r3, #5
 80021a2:	440b      	add	r3, r1
 80021a4:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 80021a6:	9b03      	ldr	r3, [sp, #12]
 80021a8:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 80021ac:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80021b0:	3310      	adds	r3, #16
 80021b2:	2101      	movs	r1, #1
 80021b4:	fa01 f303 	lsl.w	r3, r1, r3
 80021b8:	431a      	orrs	r2, r3
 80021ba:	9b03      	ldr	r3, [sp, #12]
 80021bc:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 80021c0:	e01d      	b.n	80021fe <usb_lld_init_endpoint+0xfe>
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 80021c2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80021c6:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80021ca:	9903      	ldr	r1, [sp, #12]
 80021cc:	3258      	adds	r2, #88	; 0x58
 80021ce:	0152      	lsls	r2, r2, #5
 80021d0:	440a      	add	r2, r1
 80021d2:	6812      	ldr	r2, [r2, #0]
 80021d4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80021d8:	9903      	ldr	r1, [sp, #12]
 80021da:	3358      	adds	r3, #88	; 0x58
 80021dc:	015b      	lsls	r3, r3, #5
 80021de:	440b      	add	r3, r1
 80021e0:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 80021e2:	9b03      	ldr	r3, [sp, #12]
 80021e4:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 80021e8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80021ec:	3310      	adds	r3, #16
 80021ee:	2101      	movs	r1, #1
 80021f0:	fa01 f303 	lsl.w	r3, r1, r3
 80021f4:	43db      	mvns	r3, r3
 80021f6:	401a      	ands	r2, r3
 80021f8:	9b03      	ldr	r3, [sp, #12]
 80021fa:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 80021fe:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002202:	9a03      	ldr	r2, [sp, #12]
 8002204:	015b      	lsls	r3, r3, #5
 8002206:	4413      	add	r3, r2
 8002208:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800220c:	2200      	movs	r2, #0
 800220e:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->in_state != NULL) {
 8002210:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002214:	9a01      	ldr	r2, [sp, #4]
 8002216:	3302      	adds	r3, #2
 8002218:	009b      	lsls	r3, r3, #2
 800221a:	4413      	add	r3, r2
 800221c:	685b      	ldr	r3, [r3, #4]
 800221e:	695b      	ldr	r3, [r3, #20]
 8002220:	2b00      	cmp	r3, #0
 8002222:	d05d      	beq.n	80022e0 <usb_lld_init_endpoint+0x1e0>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8002224:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002228:	9a01      	ldr	r2, [sp, #4]
 800222a:	3302      	adds	r3, #2
 800222c:	009b      	lsls	r3, r3, #2
 800222e:	4413      	add	r3, r2
 8002230:	685b      	ldr	r3, [r3, #4]
 8002232:	8a1b      	ldrh	r3, [r3, #16]
 8002234:	089b      	lsrs	r3, r3, #2
 8002236:	b29b      	uxth	r3, r3
 8002238:	9304      	str	r3, [sp, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 800223a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800223e:	9a01      	ldr	r2, [sp, #4]
 8002240:	3302      	adds	r3, #2
 8002242:	009b      	lsls	r3, r3, #2
 8002244:	4413      	add	r3, r2
 8002246:	685b      	ldr	r3, [r3, #4]
 8002248:	8b9b      	ldrh	r3, [r3, #28]
 800224a:	2b01      	cmp	r3, #1
 800224c:	d90c      	bls.n	8002268 <usb_lld_init_endpoint+0x168>
      fsize *= usbp->epc[ep]->in_multiplier;
 800224e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002252:	9a01      	ldr	r2, [sp, #4]
 8002254:	3302      	adds	r3, #2
 8002256:	009b      	lsls	r3, r3, #2
 8002258:	4413      	add	r3, r2
 800225a:	685b      	ldr	r3, [r3, #4]
 800225c:	8b9b      	ldrh	r3, [r3, #28]
 800225e:	461a      	mov	r2, r3
 8002260:	9b04      	ldr	r3, [sp, #16]
 8002262:	fb02 f303 	mul.w	r3, r2, r3
 8002266:	9304      	str	r3, [sp, #16]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8002268:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800226c:	1e5c      	subs	r4, r3, #1
 800226e:	9b04      	ldr	r3, [sp, #16]
 8002270:	041d      	lsls	r5, r3, #16
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
 8002272:	9801      	ldr	r0, [sp, #4]
 8002274:	9904      	ldr	r1, [sp, #16]
 8002276:	f001 fbbb 	bl	80039f0 <otg_ram_alloc.lto_priv.167>
 800227a:	4603      	mov	r3, r0
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800227c:	ea45 0203 	orr.w	r2, r5, r3
 8002280:	9903      	ldr	r1, [sp, #12]
 8002282:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8002286:	009b      	lsls	r3, r3, #2
 8002288:	440b      	add	r3, r1
 800228a:	605a      	str	r2, [r3, #4]
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);
 800228c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002290:	9801      	ldr	r0, [sp, #4]
 8002292:	4619      	mov	r1, r3
 8002294:	f001 fb7c 	bl	8003990 <otg_txfifo_flush.lto_priv.166>

    otgp->ie[ep].DIEPCTL = ctl |
 8002298:	f89d 0003 	ldrb.w	r0, [sp, #3]
                           DIEPCTL_TXFNUM(ep) |
 800229c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80022a0:	059b      	lsls	r3, r3, #22
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 80022a2:	461a      	mov	r2, r3
 80022a4:	9b05      	ldr	r3, [sp, #20]
 80022a6:	431a      	orrs	r2, r3
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 80022a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80022ac:	9901      	ldr	r1, [sp, #4]
 80022ae:	3302      	adds	r3, #2
 80022b0:	009b      	lsls	r3, r3, #2
 80022b2:	440b      	add	r3, r1
 80022b4:	685b      	ldr	r3, [r3, #4]
 80022b6:	8a1b      	ldrh	r3, [r3, #16]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
 80022b8:	431a      	orrs	r2, r3
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 80022ba:	9903      	ldr	r1, [sp, #12]
 80022bc:	f100 0348 	add.w	r3, r0, #72	; 0x48
 80022c0:	015b      	lsls	r3, r3, #5
 80022c2:	440b      	add	r3, r1
 80022c4:	601a      	str	r2, [r3, #0]
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 80022c6:	9b03      	ldr	r3, [sp, #12]
 80022c8:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 80022cc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80022d0:	2101      	movs	r1, #1
 80022d2:	fa01 f303 	lsl.w	r3, r1, r3
 80022d6:	431a      	orrs	r2, r3
 80022d8:	9b03      	ldr	r3, [sp, #12]
 80022da:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 80022de:	e02b      	b.n	8002338 <usb_lld_init_endpoint+0x238>
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 80022e0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80022e4:	3b01      	subs	r3, #1
 80022e6:	9a03      	ldr	r2, [sp, #12]
 80022e8:	3340      	adds	r3, #64	; 0x40
 80022ea:	009b      	lsls	r3, r3, #2
 80022ec:	4413      	add	r3, r2
 80022ee:	4a17      	ldr	r2, [pc, #92]	; (800234c <usb_lld_init_endpoint+0x24c>)
 80022f0:	605a      	str	r2, [r3, #4]
    otg_txfifo_flush(usbp, ep);
 80022f2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80022f6:	9801      	ldr	r0, [sp, #4]
 80022f8:	4619      	mov	r1, r3
 80022fa:	f001 fb49 	bl	8003990 <otg_txfifo_flush.lto_priv.166>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 80022fe:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002302:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8002306:	9903      	ldr	r1, [sp, #12]
 8002308:	3248      	adds	r2, #72	; 0x48
 800230a:	0152      	lsls	r2, r2, #5
 800230c:	440a      	add	r2, r1
 800230e:	6812      	ldr	r2, [r2, #0]
 8002310:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8002314:	9903      	ldr	r1, [sp, #12]
 8002316:	3348      	adds	r3, #72	; 0x48
 8002318:	015b      	lsls	r3, r3, #5
 800231a:	440b      	add	r3, r1
 800231c:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 800231e:	9b03      	ldr	r3, [sp, #12]
 8002320:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8002324:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002328:	2101      	movs	r1, #1
 800232a:	fa01 f303 	lsl.w	r3, r1, r3
 800232e:	43db      	mvns	r3, r3
 8002330:	401a      	ands	r2, r3
 8002332:	9b03      	ldr	r3, [sp, #12]
 8002334:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
  }
}
 8002338:	b007      	add	sp, #28
 800233a:	bd30      	pop	{r4, r5, pc}
 800233c:	10008000 	.word	0x10008000
 8002340:	10048000 	.word	0x10048000
 8002344:	10088000 	.word	0x10088000
 8002348:	100c8000 	.word	0x100c8000
 800234c:	02000400 	.word	0x02000400

08002350 <usb_lld_get_status_out>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
 8002350:	b084      	sub	sp, #16
 8002352:	9001      	str	r0, [sp, #4]
 8002354:	460b      	mov	r3, r1
 8002356:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 800235a:	9b01      	ldr	r3, [sp, #4]
 800235c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800235e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002362:	3358      	adds	r3, #88	; 0x58
 8002364:	015b      	lsls	r3, r3, #5
 8002366:	4413      	add	r3, r2
 8002368:	681b      	ldr	r3, [r3, #0]
 800236a:	9303      	str	r3, [sp, #12]
  if (!(ctl & DOEPCTL_USBAEP))
 800236c:	9b03      	ldr	r3, [sp, #12]
 800236e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8002372:	2b00      	cmp	r3, #0
 8002374:	d101      	bne.n	800237a <usb_lld_get_status_out+0x2a>
    return EP_STATUS_DISABLED;
 8002376:	2300      	movs	r3, #0
 8002378:	e007      	b.n	800238a <usb_lld_get_status_out+0x3a>
  if (ctl & DOEPCTL_STALL)
 800237a:	9b03      	ldr	r3, [sp, #12]
 800237c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8002380:	2b00      	cmp	r3, #0
 8002382:	d001      	beq.n	8002388 <usb_lld_get_status_out+0x38>
    return EP_STATUS_STALLED;
 8002384:	2301      	movs	r3, #1
 8002386:	e000      	b.n	800238a <usb_lld_get_status_out+0x3a>
  return EP_STATUS_ACTIVE;
 8002388:	2302      	movs	r3, #2
}
 800238a:	4618      	mov	r0, r3
 800238c:	b004      	add	sp, #16
 800238e:	4770      	bx	lr

08002390 <usb_lld_get_status_in>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
 8002390:	b084      	sub	sp, #16
 8002392:	9001      	str	r0, [sp, #4]
 8002394:	460b      	mov	r3, r1
 8002396:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 800239a:	9b01      	ldr	r3, [sp, #4]
 800239c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800239e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80023a2:	3348      	adds	r3, #72	; 0x48
 80023a4:	015b      	lsls	r3, r3, #5
 80023a6:	4413      	add	r3, r2
 80023a8:	681b      	ldr	r3, [r3, #0]
 80023aa:	9303      	str	r3, [sp, #12]
  if (!(ctl & DIEPCTL_USBAEP))
 80023ac:	9b03      	ldr	r3, [sp, #12]
 80023ae:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80023b2:	2b00      	cmp	r3, #0
 80023b4:	d101      	bne.n	80023ba <usb_lld_get_status_in+0x2a>
    return EP_STATUS_DISABLED;
 80023b6:	2300      	movs	r3, #0
 80023b8:	e007      	b.n	80023ca <usb_lld_get_status_in+0x3a>
  if (ctl & DIEPCTL_STALL)
 80023ba:	9b03      	ldr	r3, [sp, #12]
 80023bc:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80023c0:	2b00      	cmp	r3, #0
 80023c2:	d001      	beq.n	80023c8 <usb_lld_get_status_in+0x38>
    return EP_STATUS_STALLED;
 80023c4:	2301      	movs	r3, #1
 80023c6:	e000      	b.n	80023ca <usb_lld_get_status_in+0x3a>
  return EP_STATUS_ACTIVE;
 80023c8:	2302      	movs	r3, #2
}
 80023ca:	4618      	mov	r0, r3
 80023cc:	b004      	add	sp, #16
 80023ce:	4770      	bx	lr

080023d0 <usb_lld_read_setup>:
 * @param[in] ep        endpoint number
 * @param[out] buf      buffer where to copy the packet data
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
 80023d0:	b500      	push	{lr}
 80023d2:	b085      	sub	sp, #20
 80023d4:	9003      	str	r0, [sp, #12]
 80023d6:	460b      	mov	r3, r1
 80023d8:	9201      	str	r2, [sp, #4]
 80023da:	f88d 300b 	strb.w	r3, [sp, #11]

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 80023de:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80023e2:	9a03      	ldr	r2, [sp, #12]
 80023e4:	3302      	adds	r3, #2
 80023e6:	009b      	lsls	r3, r3, #2
 80023e8:	4413      	add	r3, r2
 80023ea:	685b      	ldr	r3, [r3, #4]
 80023ec:	6a1b      	ldr	r3, [r3, #32]
 80023ee:	9801      	ldr	r0, [sp, #4]
 80023f0:	4619      	mov	r1, r3
 80023f2:	2208      	movs	r2, #8
 80023f4:	f7fd ff64 	bl	80002c0 <memcpy>
}
 80023f8:	b005      	add	sp, #20
 80023fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80023fe:	bf00      	nop

08002400 <usb_lld_start_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8002400:	b086      	sub	sp, #24
 8002402:	9001      	str	r0, [sp, #4]
 8002404:	460b      	mov	r3, r1
 8002406:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800240a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800240e:	9a01      	ldr	r2, [sp, #4]
 8002410:	3302      	adds	r3, #2
 8002412:	009b      	lsls	r3, r3, #2
 8002414:	4413      	add	r3, r2
 8002416:	685b      	ldr	r3, [r3, #4]
 8002418:	699b      	ldr	r3, [r3, #24]
 800241a:	9305      	str	r3, [sp, #20]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 800241c:	9b05      	ldr	r3, [sp, #20]
 800241e:	681a      	ldr	r2, [r3, #0]
 8002420:	9b05      	ldr	r3, [sp, #20]
 8002422:	611a      	str	r2, [r3, #16]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 8002424:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002428:	2b00      	cmp	r3, #0
 800242a:	d106      	bne.n	800243a <usb_lld_start_out+0x3a>
 800242c:	9b05      	ldr	r3, [sp, #20]
 800242e:	681b      	ldr	r3, [r3, #0]
 8002430:	2b40      	cmp	r3, #64	; 0x40
 8002432:	d902      	bls.n	800243a <usb_lld_start_out+0x3a>
      osp->rxsize = EP0_MAX_OUTSIZE;
 8002434:	9b05      	ldr	r3, [sp, #20]
 8002436:	2240      	movs	r2, #64	; 0x40
 8002438:	601a      	str	r2, [r3, #0]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 800243a:	9b05      	ldr	r3, [sp, #20]
 800243c:	681a      	ldr	r2, [r3, #0]
 800243e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002442:	9901      	ldr	r1, [sp, #4]
 8002444:	3302      	adds	r3, #2
 8002446:	009b      	lsls	r3, r3, #2
 8002448:	440b      	add	r3, r1
 800244a:	685b      	ldr	r3, [r3, #4]
 800244c:	8a5b      	ldrh	r3, [r3, #18]
 800244e:	4413      	add	r3, r2
 8002450:	1e5a      	subs	r2, r3, #1
           usbp->epc[ep]->out_maxsize;
 8002452:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002456:	9901      	ldr	r1, [sp, #4]
 8002458:	3302      	adds	r3, #2
 800245a:	009b      	lsls	r3, r3, #2
 800245c:	440b      	add	r3, r1
 800245e:	685b      	ldr	r3, [r3, #4]
 8002460:	8a5b      	ldrh	r3, [r3, #18]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8002462:	fbb2 f3f3 	udiv	r3, r2, r3
 8002466:	9304      	str	r3, [sp, #16]
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 8002468:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800246c:	9a01      	ldr	r2, [sp, #4]
 800246e:	3302      	adds	r3, #2
 8002470:	009b      	lsls	r3, r3, #2
 8002472:	4413      	add	r3, r2
 8002474:	685b      	ldr	r3, [r3, #4]
 8002476:	8a5b      	ldrh	r3, [r3, #18]
 8002478:	461a      	mov	r2, r3
 800247a:	9b04      	ldr	r3, [sp, #16]
 800247c:	fb03 f302 	mul.w	r3, r3, r2
 8002480:	3303      	adds	r3, #3
 8002482:	f023 0303 	bic.w	r3, r3, #3
 8002486:	9303      	str	r3, [sp, #12]

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8002488:	9b01      	ldr	r3, [sp, #4]
 800248a:	6d19      	ldr	r1, [r3, #80]	; 0x50
 800248c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002490:	9a04      	ldr	r2, [sp, #16]
 8002492:	04d0      	lsls	r0, r2, #19
 8002494:	9a03      	ldr	r2, [sp, #12]
 8002496:	4302      	orrs	r2, r0
 8002498:	f042 42c0 	orr.w	r2, r2, #1610612736	; 0x60000000
 800249c:	015b      	lsls	r3, r3, #5
 800249e:	440b      	add	r3, r1
 80024a0:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 80024a4:	601a      	str	r2, [r3, #0]
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80024a6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80024aa:	9a01      	ldr	r2, [sp, #4]
 80024ac:	3302      	adds	r3, #2
 80024ae:	009b      	lsls	r3, r3, #2
 80024b0:	4413      	add	r3, r2
 80024b2:	685b      	ldr	r3, [r3, #4]
 80024b4:	681b      	ldr	r3, [r3, #0]
 80024b6:	f003 0303 	and.w	r3, r3, #3
 80024ba:	2b01      	cmp	r3, #1
 80024bc:	d12c      	bne.n	8002518 <usb_lld_start_out+0x118>
    /* Odd/even bit toggling for isochronous endpoint.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 80024be:	9b01      	ldr	r3, [sp, #4]
 80024c0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80024c2:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 80024c6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80024ca:	2b00      	cmp	r3, #0
 80024cc:	d012      	beq.n	80024f4 <usb_lld_start_out+0xf4>
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 80024ce:	9b01      	ldr	r3, [sp, #4]
 80024d0:	6d19      	ldr	r1, [r3, #80]	; 0x50
 80024d2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80024d6:	9a01      	ldr	r2, [sp, #4]
 80024d8:	6d10      	ldr	r0, [r2, #80]	; 0x50
 80024da:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80024de:	3258      	adds	r2, #88	; 0x58
 80024e0:	0152      	lsls	r2, r2, #5
 80024e2:	4402      	add	r2, r0
 80024e4:	6812      	ldr	r2, [r2, #0]
 80024e6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80024ea:	3358      	adds	r3, #88	; 0x58
 80024ec:	015b      	lsls	r3, r3, #5
 80024ee:	440b      	add	r3, r1
 80024f0:	601a      	str	r2, [r3, #0]
 80024f2:	e011      	b.n	8002518 <usb_lld_start_out+0x118>
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 80024f4:	9b01      	ldr	r3, [sp, #4]
 80024f6:	6d19      	ldr	r1, [r3, #80]	; 0x50
 80024f8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80024fc:	9a01      	ldr	r2, [sp, #4]
 80024fe:	6d10      	ldr	r0, [r2, #80]	; 0x50
 8002500:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8002504:	3258      	adds	r2, #88	; 0x58
 8002506:	0152      	lsls	r2, r2, #5
 8002508:	4402      	add	r2, r0
 800250a:	6812      	ldr	r2, [r2, #0]
 800250c:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8002510:	3358      	adds	r3, #88	; 0x58
 8002512:	015b      	lsls	r3, r3, #5
 8002514:	440b      	add	r3, r1
 8002516:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8002518:	9b01      	ldr	r3, [sp, #4]
 800251a:	6d19      	ldr	r1, [r3, #80]	; 0x50
 800251c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002520:	9a01      	ldr	r2, [sp, #4]
 8002522:	6d10      	ldr	r0, [r2, #80]	; 0x50
 8002524:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8002528:	3258      	adds	r2, #88	; 0x58
 800252a:	0152      	lsls	r2, r2, #5
 800252c:	4402      	add	r2, r0
 800252e:	6812      	ldr	r2, [r2, #0]
 8002530:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8002534:	3358      	adds	r3, #88	; 0x58
 8002536:	015b      	lsls	r3, r3, #5
 8002538:	440b      	add	r3, r1
 800253a:	601a      	str	r2, [r3, #0]
}
 800253c:	b006      	add	sp, #24
 800253e:	4770      	bx	lr

08002540 <usb_lld_start_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8002540:	b084      	sub	sp, #16
 8002542:	9001      	str	r0, [sp, #4]
 8002544:	460b      	mov	r3, r1
 8002546:	f88d 3003 	strb.w	r3, [sp, #3]
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800254a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800254e:	9a01      	ldr	r2, [sp, #4]
 8002550:	3302      	adds	r3, #2
 8002552:	009b      	lsls	r3, r3, #2
 8002554:	4413      	add	r3, r2
 8002556:	685b      	ldr	r3, [r3, #4]
 8002558:	695b      	ldr	r3, [r3, #20]
 800255a:	9303      	str	r3, [sp, #12]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 800255c:	9b03      	ldr	r3, [sp, #12]
 800255e:	681a      	ldr	r2, [r3, #0]
 8002560:	9b03      	ldr	r3, [sp, #12]
 8002562:	611a      	str	r2, [r3, #16]
  if (isp->txsize == 0) {
 8002564:	9b03      	ldr	r3, [sp, #12]
 8002566:	681b      	ldr	r3, [r3, #0]
 8002568:	2b00      	cmp	r3, #0
 800256a:	d10b      	bne.n	8002584 <usb_lld_start_in+0x44>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 800256c:	9b01      	ldr	r3, [sp, #4]
 800256e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8002570:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002574:	015b      	lsls	r3, r3, #5
 8002576:	4413      	add	r3, r2
 8002578:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800257c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8002580:	601a      	str	r2, [r3, #0]
 8002582:	e031      	b.n	80025e8 <usb_lld_start_in+0xa8>
  }
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 8002584:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002588:	2b00      	cmp	r3, #0
 800258a:	d106      	bne.n	800259a <usb_lld_start_in+0x5a>
 800258c:	9b03      	ldr	r3, [sp, #12]
 800258e:	681b      	ldr	r3, [r3, #0]
 8002590:	2b40      	cmp	r3, #64	; 0x40
 8002592:	d902      	bls.n	800259a <usb_lld_start_in+0x5a>
      isp->txsize = EP0_MAX_INSIZE;
 8002594:	9b03      	ldr	r3, [sp, #12]
 8002596:	2240      	movs	r2, #64	; 0x40
 8002598:	601a      	str	r2, [r3, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 800259a:	9b03      	ldr	r3, [sp, #12]
 800259c:	681a      	ldr	r2, [r3, #0]
 800259e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80025a2:	9901      	ldr	r1, [sp, #4]
 80025a4:	3302      	adds	r3, #2
 80025a6:	009b      	lsls	r3, r3, #2
 80025a8:	440b      	add	r3, r1
 80025aa:	685b      	ldr	r3, [r3, #4]
 80025ac:	8a1b      	ldrh	r3, [r3, #16]
 80025ae:	4413      	add	r3, r2
 80025b0:	1e5a      	subs	r2, r3, #1
                    usbp->epc[ep]->in_maxsize;
 80025b2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80025b6:	9901      	ldr	r1, [sp, #4]
 80025b8:	3302      	adds	r3, #2
 80025ba:	009b      	lsls	r3, r3, #2
 80025bc:	440b      	add	r3, r1
 80025be:	685b      	ldr	r3, [r3, #4]
 80025c0:	8a1b      	ldrh	r3, [r3, #16]
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 80025c2:	fbb2 f3f3 	udiv	r3, r2, r3
 80025c6:	9302      	str	r3, [sp, #8]
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80025c8:	9b01      	ldr	r3, [sp, #4]
 80025ca:	6d19      	ldr	r1, [r3, #80]	; 0x50
 80025cc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80025d0:	9a02      	ldr	r2, [sp, #8]
 80025d2:	04d0      	lsls	r0, r2, #19
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
 80025d4:	9a03      	ldr	r2, [sp, #12]
 80025d6:	6812      	ldr	r2, [r2, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80025d8:	4302      	orrs	r2, r0
 80025da:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 80025de:	015b      	lsls	r3, r3, #5
 80025e0:	440b      	add	r3, r1
 80025e2:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 80025e6:	601a      	str	r2, [r3, #0]
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80025e8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80025ec:	9a01      	ldr	r2, [sp, #4]
 80025ee:	3302      	adds	r3, #2
 80025f0:	009b      	lsls	r3, r3, #2
 80025f2:	4413      	add	r3, r2
 80025f4:	685b      	ldr	r3, [r3, #4]
 80025f6:	681b      	ldr	r3, [r3, #0]
 80025f8:	f003 0303 	and.w	r3, r3, #3
 80025fc:	2b01      	cmp	r3, #1
 80025fe:	d12c      	bne.n	800265a <usb_lld_start_in+0x11a>
    /* Odd/even bit toggling.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8002600:	9b01      	ldr	r3, [sp, #4]
 8002602:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8002604:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 8002608:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800260c:	2b00      	cmp	r3, #0
 800260e:	d012      	beq.n	8002636 <usb_lld_start_in+0xf6>
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 8002610:	9b01      	ldr	r3, [sp, #4]
 8002612:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8002614:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002618:	9a01      	ldr	r2, [sp, #4]
 800261a:	6d10      	ldr	r0, [r2, #80]	; 0x50
 800261c:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8002620:	3248      	adds	r2, #72	; 0x48
 8002622:	0152      	lsls	r2, r2, #5
 8002624:	4402      	add	r2, r0
 8002626:	6812      	ldr	r2, [r2, #0]
 8002628:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800262c:	3348      	adds	r3, #72	; 0x48
 800262e:	015b      	lsls	r3, r3, #5
 8002630:	440b      	add	r3, r1
 8002632:	601a      	str	r2, [r3, #0]
 8002634:	e011      	b.n	800265a <usb_lld_start_in+0x11a>
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 8002636:	9b01      	ldr	r3, [sp, #4]
 8002638:	6d19      	ldr	r1, [r3, #80]	; 0x50
 800263a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800263e:	9a01      	ldr	r2, [sp, #4]
 8002640:	6d10      	ldr	r0, [r2, #80]	; 0x50
 8002642:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8002646:	3248      	adds	r2, #72	; 0x48
 8002648:	0152      	lsls	r2, r2, #5
 800264a:	4402      	add	r2, r0
 800264c:	6812      	ldr	r2, [r2, #0]
 800264e:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8002652:	3348      	adds	r3, #72	; 0x48
 8002654:	015b      	lsls	r3, r3, #5
 8002656:	440b      	add	r3, r1
 8002658:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 800265a:	9b01      	ldr	r3, [sp, #4]
 800265c:	6d19      	ldr	r1, [r3, #80]	; 0x50
 800265e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002662:	9a01      	ldr	r2, [sp, #4]
 8002664:	6d10      	ldr	r0, [r2, #80]	; 0x50
 8002666:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800266a:	3248      	adds	r2, #72	; 0x48
 800266c:	0152      	lsls	r2, r2, #5
 800266e:	4402      	add	r2, r0
 8002670:	6812      	ldr	r2, [r2, #0]
 8002672:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8002676:	3348      	adds	r3, #72	; 0x48
 8002678:	015b      	lsls	r3, r3, #5
 800267a:	440b      	add	r3, r1
 800267c:	601a      	str	r2, [r3, #0]
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800267e:	9b01      	ldr	r3, [sp, #4]
 8002680:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8002682:	9a01      	ldr	r2, [sp, #4]
 8002684:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8002686:	f8d2 1834 	ldr.w	r1, [r2, #2100]	; 0x834
 800268a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800268e:	2001      	movs	r0, #1
 8002690:	fa00 f202 	lsl.w	r2, r0, r2
 8002694:	430a      	orrs	r2, r1
 8002696:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
}
 800269a:	b004      	add	sp, #16
 800269c:	4770      	bx	lr
 800269e:	bf00      	nop

080026a0 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 80026a0:	b082      	sub	sp, #8
 80026a2:	9001      	str	r0, [sp, #4]
 80026a4:	460b      	mov	r3, r1
 80026a6:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 80026aa:	9b01      	ldr	r3, [sp, #4]
 80026ac:	6d19      	ldr	r1, [r3, #80]	; 0x50
 80026ae:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80026b2:	9a01      	ldr	r2, [sp, #4]
 80026b4:	6d10      	ldr	r0, [r2, #80]	; 0x50
 80026b6:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80026ba:	3258      	adds	r2, #88	; 0x58
 80026bc:	0152      	lsls	r2, r2, #5
 80026be:	4402      	add	r2, r0
 80026c0:	6812      	ldr	r2, [r2, #0]
 80026c2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80026c6:	3358      	adds	r3, #88	; 0x58
 80026c8:	015b      	lsls	r3, r3, #5
 80026ca:	440b      	add	r3, r1
 80026cc:	601a      	str	r2, [r3, #0]
}
 80026ce:	b002      	add	sp, #8
 80026d0:	4770      	bx	lr
 80026d2:	bf00      	nop
	...

080026e0 <usb_lld_stall_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 80026e0:	b082      	sub	sp, #8
 80026e2:	9001      	str	r0, [sp, #4]
 80026e4:	460b      	mov	r3, r1
 80026e6:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 80026ea:	9b01      	ldr	r3, [sp, #4]
 80026ec:	6d19      	ldr	r1, [r3, #80]	; 0x50
 80026ee:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80026f2:	9a01      	ldr	r2, [sp, #4]
 80026f4:	6d10      	ldr	r0, [r2, #80]	; 0x50
 80026f6:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80026fa:	3248      	adds	r2, #72	; 0x48
 80026fc:	0152      	lsls	r2, r2, #5
 80026fe:	4402      	add	r2, r0
 8002700:	6812      	ldr	r2, [r2, #0]
 8002702:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8002706:	3348      	adds	r3, #72	; 0x48
 8002708:	015b      	lsls	r3, r3, #5
 800270a:	440b      	add	r3, r1
 800270c:	601a      	str	r2, [r3, #0]
}
 800270e:	b002      	add	sp, #8
 8002710:	4770      	bx	lr
 8002712:	bf00      	nop
	...

08002720 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 8002720:	b082      	sub	sp, #8
 8002722:	9001      	str	r0, [sp, #4]
 8002724:	460b      	mov	r3, r1
 8002726:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 800272a:	9b01      	ldr	r3, [sp, #4]
 800272c:	6d19      	ldr	r1, [r3, #80]	; 0x50
 800272e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002732:	9a01      	ldr	r2, [sp, #4]
 8002734:	6d10      	ldr	r0, [r2, #80]	; 0x50
 8002736:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800273a:	3258      	adds	r2, #88	; 0x58
 800273c:	0152      	lsls	r2, r2, #5
 800273e:	4402      	add	r2, r0
 8002740:	6812      	ldr	r2, [r2, #0]
 8002742:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8002746:	3358      	adds	r3, #88	; 0x58
 8002748:	015b      	lsls	r3, r3, #5
 800274a:	440b      	add	r3, r1
 800274c:	601a      	str	r2, [r3, #0]
}
 800274e:	b002      	add	sp, #8
 8002750:	4770      	bx	lr
 8002752:	bf00      	nop
	...

08002760 <usb_lld_clear_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 8002760:	b082      	sub	sp, #8
 8002762:	9001      	str	r0, [sp, #4]
 8002764:	460b      	mov	r3, r1
 8002766:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 800276a:	9b01      	ldr	r3, [sp, #4]
 800276c:	6d19      	ldr	r1, [r3, #80]	; 0x50
 800276e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002772:	9a01      	ldr	r2, [sp, #4]
 8002774:	6d10      	ldr	r0, [r2, #80]	; 0x50
 8002776:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800277a:	3248      	adds	r2, #72	; 0x48
 800277c:	0152      	lsls	r2, r2, #5
 800277e:	4402      	add	r2, r0
 8002780:	6812      	ldr	r2, [r2, #0]
 8002782:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8002786:	3348      	adds	r3, #72	; 0x48
 8002788:	015b      	lsls	r3, r3, #5
 800278a:	440b      	add	r3, r1
 800278c:	601a      	str	r2, [r3, #0]
}
 800278e:	b002      	add	sp, #8
 8002790:	4770      	bx	lr
 8002792:	bf00      	nop
	...

080027a0 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 80027a0:	b500      	push	{lr}
 80027a2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 80027a4:	4b0b      	ldr	r3, [pc, #44]	; (80027d4 <Vector7C+0x34>)
 80027a6:	685b      	ldr	r3, [r3, #4]
 80027a8:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80027ac:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 0U;
 80027ae:	4a09      	ldr	r2, [pc, #36]	; (80027d4 <Vector7C+0x34>)
 80027b0:	9b01      	ldr	r3, [sp, #4]
 80027b2:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[4].dma_func)
 80027b4:	4b08      	ldr	r3, [pc, #32]	; (80027d8 <Vector7C+0x38>)
 80027b6:	6a1b      	ldr	r3, [r3, #32]
 80027b8:	2b00      	cmp	r3, #0
 80027ba:	d006      	beq.n	80027ca <Vector7C+0x2a>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 80027bc:	4b06      	ldr	r3, [pc, #24]	; (80027d8 <Vector7C+0x38>)
 80027be:	6a1b      	ldr	r3, [r3, #32]
 80027c0:	4a05      	ldr	r2, [pc, #20]	; (80027d8 <Vector7C+0x38>)
 80027c2:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80027c4:	4610      	mov	r0, r2
 80027c6:	9901      	ldr	r1, [sp, #4]
 80027c8:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80027ca:	f002 fa21 	bl	8004c10 <_port_irq_epilogue>
}
 80027ce:	b003      	add	sp, #12
 80027d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80027d4:	40026000 	.word	0x40026000
 80027d8:	20000984 	.word	0x20000984
 80027dc:	00000000 	.word	0x00000000

080027e0 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 80027e0:	b500      	push	{lr}
 80027e2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 80027e4:	4b0c      	ldr	r3, [pc, #48]	; (8002818 <Vector80+0x38>)
 80027e6:	685b      	ldr	r3, [r3, #4]
 80027e8:	099b      	lsrs	r3, r3, #6
 80027ea:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80027ee:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 6U;
 80027f0:	4a09      	ldr	r2, [pc, #36]	; (8002818 <Vector80+0x38>)
 80027f2:	9b01      	ldr	r3, [sp, #4]
 80027f4:	019b      	lsls	r3, r3, #6
 80027f6:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[5].dma_func)
 80027f8:	4b08      	ldr	r3, [pc, #32]	; (800281c <Vector80+0x3c>)
 80027fa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80027fc:	2b00      	cmp	r3, #0
 80027fe:	d006      	beq.n	800280e <Vector80+0x2e>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 8002800:	4b06      	ldr	r3, [pc, #24]	; (800281c <Vector80+0x3c>)
 8002802:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002804:	4a05      	ldr	r2, [pc, #20]	; (800281c <Vector80+0x3c>)
 8002806:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8002808:	4610      	mov	r0, r2
 800280a:	9901      	ldr	r1, [sp, #4]
 800280c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800280e:	f002 f9ff 	bl	8004c10 <_port_irq_epilogue>
}
 8002812:	b003      	add	sp, #12
 8002814:	f85d fb04 	ldr.w	pc, [sp], #4
 8002818:	40026000 	.word	0x40026000
 800281c:	20000984 	.word	0x20000984

08002820 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8002820:	b500      	push	{lr}
 8002822:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002824:	4b0c      	ldr	r3, [pc, #48]	; (8002858 <Vector84+0x38>)
 8002826:	685b      	ldr	r3, [r3, #4]
 8002828:	0c1b      	lsrs	r3, r3, #16
 800282a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800282e:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 16U;
 8002830:	4a09      	ldr	r2, [pc, #36]	; (8002858 <Vector84+0x38>)
 8002832:	9b01      	ldr	r3, [sp, #4]
 8002834:	041b      	lsls	r3, r3, #16
 8002836:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[6].dma_func)
 8002838:	4b08      	ldr	r3, [pc, #32]	; (800285c <Vector84+0x3c>)
 800283a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800283c:	2b00      	cmp	r3, #0
 800283e:	d006      	beq.n	800284e <Vector84+0x2e>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 8002840:	4b06      	ldr	r3, [pc, #24]	; (800285c <Vector84+0x3c>)
 8002842:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002844:	4a05      	ldr	r2, [pc, #20]	; (800285c <Vector84+0x3c>)
 8002846:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8002848:	4610      	mov	r0, r2
 800284a:	9901      	ldr	r1, [sp, #4]
 800284c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800284e:	f002 f9df 	bl	8004c10 <_port_irq_epilogue>
}
 8002852:	b003      	add	sp, #12
 8002854:	f85d fb04 	ldr.w	pc, [sp], #4
 8002858:	40026000 	.word	0x40026000
 800285c:	20000984 	.word	0x20000984

08002860 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8002860:	b500      	push	{lr}
 8002862:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002864:	4b0c      	ldr	r3, [pc, #48]	; (8002898 <VectorFC+0x38>)
 8002866:	685b      	ldr	r3, [r3, #4]
 8002868:	0d9b      	lsrs	r3, r3, #22
 800286a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800286e:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 22U;
 8002870:	4a09      	ldr	r2, [pc, #36]	; (8002898 <VectorFC+0x38>)
 8002872:	9b01      	ldr	r3, [sp, #4]
 8002874:	059b      	lsls	r3, r3, #22
 8002876:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[7].dma_func)
 8002878:	4b08      	ldr	r3, [pc, #32]	; (800289c <VectorFC+0x3c>)
 800287a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800287c:	2b00      	cmp	r3, #0
 800287e:	d006      	beq.n	800288e <VectorFC+0x2e>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 8002880:	4b06      	ldr	r3, [pc, #24]	; (800289c <VectorFC+0x3c>)
 8002882:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002884:	4a05      	ldr	r2, [pc, #20]	; (800289c <VectorFC+0x3c>)
 8002886:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8002888:	4610      	mov	r0, r2
 800288a:	9901      	ldr	r1, [sp, #4]
 800288c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800288e:	f002 f9bf 	bl	8004c10 <_port_irq_epilogue>
}
 8002892:	b003      	add	sp, #12
 8002894:	f85d fb04 	ldr.w	pc, [sp], #4
 8002898:	40026000 	.word	0x40026000
 800289c:	20000984 	.word	0x20000984

080028a0 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 80028a0:	b500      	push	{lr}
 80028a2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 80028a4:	4b0b      	ldr	r3, [pc, #44]	; (80028d4 <Vector120+0x34>)
 80028a6:	681b      	ldr	r3, [r3, #0]
 80028a8:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80028ac:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 0U;
 80028ae:	4a09      	ldr	r2, [pc, #36]	; (80028d4 <Vector120+0x34>)
 80028b0:	9b01      	ldr	r3, [sp, #4]
 80028b2:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[8].dma_func)
 80028b4:	4b08      	ldr	r3, [pc, #32]	; (80028d8 <Vector120+0x38>)
 80028b6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80028b8:	2b00      	cmp	r3, #0
 80028ba:	d006      	beq.n	80028ca <Vector120+0x2a>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 80028bc:	4b06      	ldr	r3, [pc, #24]	; (80028d8 <Vector120+0x38>)
 80028be:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80028c0:	4a05      	ldr	r2, [pc, #20]	; (80028d8 <Vector120+0x38>)
 80028c2:	6c52      	ldr	r2, [r2, #68]	; 0x44
 80028c4:	4610      	mov	r0, r2
 80028c6:	9901      	ldr	r1, [sp, #4]
 80028c8:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80028ca:	f002 f9a1 	bl	8004c10 <_port_irq_epilogue>
}
 80028ce:	b003      	add	sp, #12
 80028d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80028d4:	40026400 	.word	0x40026400
 80028d8:	20000984 	.word	0x20000984
 80028dc:	00000000 	.word	0x00000000

080028e0 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 80028e0:	b500      	push	{lr}
 80028e2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 80028e4:	4b0c      	ldr	r3, [pc, #48]	; (8002918 <Vector124+0x38>)
 80028e6:	681b      	ldr	r3, [r3, #0]
 80028e8:	099b      	lsrs	r3, r3, #6
 80028ea:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80028ee:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 6U;
 80028f0:	4a09      	ldr	r2, [pc, #36]	; (8002918 <Vector124+0x38>)
 80028f2:	9b01      	ldr	r3, [sp, #4]
 80028f4:	019b      	lsls	r3, r3, #6
 80028f6:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[9].dma_func)
 80028f8:	4b08      	ldr	r3, [pc, #32]	; (800291c <Vector124+0x3c>)
 80028fa:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80028fc:	2b00      	cmp	r3, #0
 80028fe:	d006      	beq.n	800290e <Vector124+0x2e>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 8002900:	4b06      	ldr	r3, [pc, #24]	; (800291c <Vector124+0x3c>)
 8002902:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8002904:	4a05      	ldr	r2, [pc, #20]	; (800291c <Vector124+0x3c>)
 8002906:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8002908:	4610      	mov	r0, r2
 800290a:	9901      	ldr	r1, [sp, #4]
 800290c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800290e:	f002 f97f 	bl	8004c10 <_port_irq_epilogue>
}
 8002912:	b003      	add	sp, #12
 8002914:	f85d fb04 	ldr.w	pc, [sp], #4
 8002918:	40026400 	.word	0x40026400
 800291c:	20000984 	.word	0x20000984

08002920 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8002920:	b500      	push	{lr}
 8002922:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002924:	4b0c      	ldr	r3, [pc, #48]	; (8002958 <Vector128+0x38>)
 8002926:	681b      	ldr	r3, [r3, #0]
 8002928:	0c1b      	lsrs	r3, r3, #16
 800292a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800292e:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 16U;
 8002930:	4a09      	ldr	r2, [pc, #36]	; (8002958 <Vector128+0x38>)
 8002932:	9b01      	ldr	r3, [sp, #4]
 8002934:	041b      	lsls	r3, r3, #16
 8002936:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[10].dma_func)
 8002938:	4b08      	ldr	r3, [pc, #32]	; (800295c <Vector128+0x3c>)
 800293a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800293c:	2b00      	cmp	r3, #0
 800293e:	d006      	beq.n	800294e <Vector128+0x2e>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 8002940:	4b06      	ldr	r3, [pc, #24]	; (800295c <Vector128+0x3c>)
 8002942:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8002944:	4a05      	ldr	r2, [pc, #20]	; (800295c <Vector128+0x3c>)
 8002946:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8002948:	4610      	mov	r0, r2
 800294a:	9901      	ldr	r1, [sp, #4]
 800294c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800294e:	f002 f95f 	bl	8004c10 <_port_irq_epilogue>
}
 8002952:	b003      	add	sp, #12
 8002954:	f85d fb04 	ldr.w	pc, [sp], #4
 8002958:	40026400 	.word	0x40026400
 800295c:	20000984 	.word	0x20000984

08002960 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8002960:	b500      	push	{lr}
 8002962:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002964:	4b0c      	ldr	r3, [pc, #48]	; (8002998 <Vector12C+0x38>)
 8002966:	681b      	ldr	r3, [r3, #0]
 8002968:	0d9b      	lsrs	r3, r3, #22
 800296a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800296e:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 22U;
 8002970:	4a09      	ldr	r2, [pc, #36]	; (8002998 <Vector12C+0x38>)
 8002972:	9b01      	ldr	r3, [sp, #4]
 8002974:	059b      	lsls	r3, r3, #22
 8002976:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[11].dma_func)
 8002978:	4b08      	ldr	r3, [pc, #32]	; (800299c <Vector12C+0x3c>)
 800297a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800297c:	2b00      	cmp	r3, #0
 800297e:	d006      	beq.n	800298e <Vector12C+0x2e>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 8002980:	4b06      	ldr	r3, [pc, #24]	; (800299c <Vector12C+0x3c>)
 8002982:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8002984:	4a05      	ldr	r2, [pc, #20]	; (800299c <Vector12C+0x3c>)
 8002986:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8002988:	4610      	mov	r0, r2
 800298a:	9901      	ldr	r1, [sp, #4]
 800298c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800298e:	f002 f93f 	bl	8004c10 <_port_irq_epilogue>
}
 8002992:	b003      	add	sp, #12
 8002994:	f85d fb04 	ldr.w	pc, [sp], #4
 8002998:	40026400 	.word	0x40026400
 800299c:	20000984 	.word	0x20000984

080029a0 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 80029a0:	b500      	push	{lr}
 80029a2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 80029a4:	4b0b      	ldr	r3, [pc, #44]	; (80029d4 <Vector130+0x34>)
 80029a6:	685b      	ldr	r3, [r3, #4]
 80029a8:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80029ac:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 0U;
 80029ae:	4a09      	ldr	r2, [pc, #36]	; (80029d4 <Vector130+0x34>)
 80029b0:	9b01      	ldr	r3, [sp, #4]
 80029b2:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[12].dma_func)
 80029b4:	4b08      	ldr	r3, [pc, #32]	; (80029d8 <Vector130+0x38>)
 80029b6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80029b8:	2b00      	cmp	r3, #0
 80029ba:	d006      	beq.n	80029ca <Vector130+0x2a>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 80029bc:	4b06      	ldr	r3, [pc, #24]	; (80029d8 <Vector130+0x38>)
 80029be:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80029c0:	4a05      	ldr	r2, [pc, #20]	; (80029d8 <Vector130+0x38>)
 80029c2:	6e52      	ldr	r2, [r2, #100]	; 0x64
 80029c4:	4610      	mov	r0, r2
 80029c6:	9901      	ldr	r1, [sp, #4]
 80029c8:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80029ca:	f002 f921 	bl	8004c10 <_port_irq_epilogue>
}
 80029ce:	b003      	add	sp, #12
 80029d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80029d4:	40026400 	.word	0x40026400
 80029d8:	20000984 	.word	0x20000984
 80029dc:	00000000 	.word	0x00000000

080029e0 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 80029e0:	b500      	push	{lr}
 80029e2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 80029e4:	4b0c      	ldr	r3, [pc, #48]	; (8002a18 <Vector150+0x38>)
 80029e6:	685b      	ldr	r3, [r3, #4]
 80029e8:	099b      	lsrs	r3, r3, #6
 80029ea:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80029ee:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 6U;
 80029f0:	4a09      	ldr	r2, [pc, #36]	; (8002a18 <Vector150+0x38>)
 80029f2:	9b01      	ldr	r3, [sp, #4]
 80029f4:	019b      	lsls	r3, r3, #6
 80029f6:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[13].dma_func)
 80029f8:	4b08      	ldr	r3, [pc, #32]	; (8002a1c <Vector150+0x3c>)
 80029fa:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80029fc:	2b00      	cmp	r3, #0
 80029fe:	d006      	beq.n	8002a0e <Vector150+0x2e>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 8002a00:	4b06      	ldr	r3, [pc, #24]	; (8002a1c <Vector150+0x3c>)
 8002a02:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8002a04:	4a05      	ldr	r2, [pc, #20]	; (8002a1c <Vector150+0x3c>)
 8002a06:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
 8002a08:	4610      	mov	r0, r2
 8002a0a:	9901      	ldr	r1, [sp, #4]
 8002a0c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002a0e:	f002 f8ff 	bl	8004c10 <_port_irq_epilogue>
}
 8002a12:	b003      	add	sp, #12
 8002a14:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a18:	40026400 	.word	0x40026400
 8002a1c:	20000984 	.word	0x20000984

08002a20 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8002a20:	b500      	push	{lr}
 8002a22:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002a24:	4b0c      	ldr	r3, [pc, #48]	; (8002a58 <Vector154+0x38>)
 8002a26:	685b      	ldr	r3, [r3, #4]
 8002a28:	0c1b      	lsrs	r3, r3, #16
 8002a2a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8002a2e:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 16U;
 8002a30:	4a09      	ldr	r2, [pc, #36]	; (8002a58 <Vector154+0x38>)
 8002a32:	9b01      	ldr	r3, [sp, #4]
 8002a34:	041b      	lsls	r3, r3, #16
 8002a36:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[14].dma_func)
 8002a38:	4b08      	ldr	r3, [pc, #32]	; (8002a5c <Vector154+0x3c>)
 8002a3a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8002a3c:	2b00      	cmp	r3, #0
 8002a3e:	d006      	beq.n	8002a4e <Vector154+0x2e>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 8002a40:	4b06      	ldr	r3, [pc, #24]	; (8002a5c <Vector154+0x3c>)
 8002a42:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8002a44:	4a05      	ldr	r2, [pc, #20]	; (8002a5c <Vector154+0x3c>)
 8002a46:	6f52      	ldr	r2, [r2, #116]	; 0x74
 8002a48:	4610      	mov	r0, r2
 8002a4a:	9901      	ldr	r1, [sp, #4]
 8002a4c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002a4e:	f002 f8df 	bl	8004c10 <_port_irq_epilogue>
}
 8002a52:	b003      	add	sp, #12
 8002a54:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a58:	40026400 	.word	0x40026400
 8002a5c:	20000984 	.word	0x20000984

08002a60 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8002a60:	b500      	push	{lr}
 8002a62:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002a64:	4b0c      	ldr	r3, [pc, #48]	; (8002a98 <Vector158+0x38>)
 8002a66:	685b      	ldr	r3, [r3, #4]
 8002a68:	0d9b      	lsrs	r3, r3, #22
 8002a6a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8002a6e:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 22U;
 8002a70:	4a09      	ldr	r2, [pc, #36]	; (8002a98 <Vector158+0x38>)
 8002a72:	9b01      	ldr	r3, [sp, #4]
 8002a74:	059b      	lsls	r3, r3, #22
 8002a76:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[15].dma_func)
 8002a78:	4b08      	ldr	r3, [pc, #32]	; (8002a9c <Vector158+0x3c>)
 8002a7a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8002a7c:	2b00      	cmp	r3, #0
 8002a7e:	d006      	beq.n	8002a8e <Vector158+0x2e>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 8002a80:	4b06      	ldr	r3, [pc, #24]	; (8002a9c <Vector158+0x3c>)
 8002a82:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8002a84:	4a05      	ldr	r2, [pc, #20]	; (8002a9c <Vector158+0x3c>)
 8002a86:	6fd2      	ldr	r2, [r2, #124]	; 0x7c
 8002a88:	4610      	mov	r0, r2
 8002a8a:	9901      	ldr	r1, [sp, #4]
 8002a8c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002a8e:	f002 f8bf 	bl	8004c10 <_port_irq_epilogue>
}
 8002a92:	b003      	add	sp, #12
 8002a94:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a98:	40026400 	.word	0x40026400
 8002a9c:	20000984 	.word	0x20000984

08002aa0 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8002aa0:	b082      	sub	sp, #8
  unsigned i;

  dma_streams_mask = 0U;
 8002aa2:	4b16      	ldr	r3, [pc, #88]	; (8002afc <dmaInit+0x5c>)
 8002aa4:	2200      	movs	r2, #0
 8002aa6:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8002aa8:	2300      	movs	r3, #0
 8002aaa:	9301      	str	r3, [sp, #4]
 8002aac:	e011      	b.n	8002ad2 <dmaInit+0x32>
    _stm32_dma_streams[i].stream->CR = 0U;
 8002aae:	4914      	ldr	r1, [pc, #80]	; (8002b00 <dmaInit+0x60>)
 8002ab0:	9a01      	ldr	r2, [sp, #4]
 8002ab2:	4613      	mov	r3, r2
 8002ab4:	005b      	lsls	r3, r3, #1
 8002ab6:	4413      	add	r3, r2
 8002ab8:	009b      	lsls	r3, r3, #2
 8002aba:	440b      	add	r3, r1
 8002abc:	681b      	ldr	r3, [r3, #0]
 8002abe:	2200      	movs	r2, #0
 8002ac0:	601a      	str	r2, [r3, #0]
    dma_isr_redir[i].dma_func = NULL;
 8002ac2:	4a10      	ldr	r2, [pc, #64]	; (8002b04 <dmaInit+0x64>)
 8002ac4:	9b01      	ldr	r3, [sp, #4]
 8002ac6:	2100      	movs	r1, #0
 8002ac8:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8002acc:	9b01      	ldr	r3, [sp, #4]
 8002ace:	3301      	adds	r3, #1
 8002ad0:	9301      	str	r3, [sp, #4]
 8002ad2:	9b01      	ldr	r3, [sp, #4]
 8002ad4:	2b0f      	cmp	r3, #15
 8002ad6:	d9ea      	bls.n	8002aae <dmaInit+0xe>
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8002ad8:	4b0b      	ldr	r3, [pc, #44]	; (8002b08 <dmaInit+0x68>)
 8002ada:	f04f 32ff 	mov.w	r2, #4294967295
 8002ade:	609a      	str	r2, [r3, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
 8002ae0:	4b09      	ldr	r3, [pc, #36]	; (8002b08 <dmaInit+0x68>)
 8002ae2:	f04f 32ff 	mov.w	r2, #4294967295
 8002ae6:	60da      	str	r2, [r3, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 8002ae8:	4b08      	ldr	r3, [pc, #32]	; (8002b0c <dmaInit+0x6c>)
 8002aea:	f04f 32ff 	mov.w	r2, #4294967295
 8002aee:	609a      	str	r2, [r3, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 8002af0:	4b06      	ldr	r3, [pc, #24]	; (8002b0c <dmaInit+0x6c>)
 8002af2:	f04f 32ff 	mov.w	r2, #4294967295
 8002af6:	60da      	str	r2, [r3, #12]
}
 8002af8:	b002      	add	sp, #8
 8002afa:	4770      	bx	lr
 8002afc:	20000980 	.word	0x20000980
 8002b00:	08006ab0 	.word	0x08006ab0
 8002b04:	20000984 	.word	0x20000984
 8002b08:	40026000 	.word	0x40026000
 8002b0c:	40026400 	.word	0x40026400

08002b10 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 8002b10:	b500      	push	{lr}
 8002b12:	b085      	sub	sp, #20
 8002b14:	9003      	str	r0, [sp, #12]
 8002b16:	9102      	str	r1, [sp, #8]
 8002b18:	9201      	str	r2, [sp, #4]
 8002b1a:	9300      	str	r3, [sp, #0]

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8002b1c:	9b03      	ldr	r3, [sp, #12]
 8002b1e:	7a5b      	ldrb	r3, [r3, #9]
 8002b20:	461a      	mov	r2, r3
 8002b22:	2301      	movs	r3, #1
 8002b24:	fa03 f202 	lsl.w	r2, r3, r2
 8002b28:	4b31      	ldr	r3, [pc, #196]	; (8002bf0 <dmaStreamAllocate+0xe0>)
 8002b2a:	681b      	ldr	r3, [r3, #0]
 8002b2c:	4013      	ands	r3, r2
 8002b2e:	2b00      	cmp	r3, #0
 8002b30:	d001      	beq.n	8002b36 <dmaStreamAllocate+0x26>
    return true;
 8002b32:	2301      	movs	r3, #1
 8002b34:	e058      	b.n	8002be8 <dmaStreamAllocate+0xd8>

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8002b36:	9b03      	ldr	r3, [sp, #12]
 8002b38:	7a5b      	ldrb	r3, [r3, #9]
 8002b3a:	4619      	mov	r1, r3
 8002b3c:	4a2d      	ldr	r2, [pc, #180]	; (8002bf4 <dmaStreamAllocate+0xe4>)
 8002b3e:	9b01      	ldr	r3, [sp, #4]
 8002b40:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8002b44:	9b03      	ldr	r3, [sp, #12]
 8002b46:	7a5b      	ldrb	r3, [r3, #9]
 8002b48:	4a2a      	ldr	r2, [pc, #168]	; (8002bf4 <dmaStreamAllocate+0xe4>)
 8002b4a:	00db      	lsls	r3, r3, #3
 8002b4c:	4413      	add	r3, r2
 8002b4e:	9a00      	ldr	r2, [sp, #0]
 8002b50:	605a      	str	r2, [r3, #4]
  dma_streams_mask |= (1U << dmastp->selfindex);
 8002b52:	9b03      	ldr	r3, [sp, #12]
 8002b54:	7a5b      	ldrb	r3, [r3, #9]
 8002b56:	461a      	mov	r2, r3
 8002b58:	2301      	movs	r3, #1
 8002b5a:	fa03 f202 	lsl.w	r2, r3, r2
 8002b5e:	4b24      	ldr	r3, [pc, #144]	; (8002bf0 <dmaStreamAllocate+0xe0>)
 8002b60:	681b      	ldr	r3, [r3, #0]
 8002b62:	4313      	orrs	r3, r2
 8002b64:	4a22      	ldr	r2, [pc, #136]	; (8002bf0 <dmaStreamAllocate+0xe0>)
 8002b66:	6013      	str	r3, [r2, #0]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
 8002b68:	4b21      	ldr	r3, [pc, #132]	; (8002bf0 <dmaStreamAllocate+0xe0>)
 8002b6a:	681b      	ldr	r3, [r3, #0]
 8002b6c:	b2db      	uxtb	r3, r3
 8002b6e:	2b00      	cmp	r3, #0
 8002b70:	d005      	beq.n	8002b7e <dmaStreamAllocate+0x6e>
    rccEnableDMA1(false);
 8002b72:	4a21      	ldr	r2, [pc, #132]	; (8002bf8 <dmaStreamAllocate+0xe8>)
 8002b74:	4b20      	ldr	r3, [pc, #128]	; (8002bf8 <dmaStreamAllocate+0xe8>)
 8002b76:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002b78:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8002b7c:	6313      	str	r3, [r2, #48]	; 0x30
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
 8002b7e:	4b1c      	ldr	r3, [pc, #112]	; (8002bf0 <dmaStreamAllocate+0xe0>)
 8002b80:	681b      	ldr	r3, [r3, #0]
 8002b82:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8002b86:	2b00      	cmp	r3, #0
 8002b88:	d005      	beq.n	8002b96 <dmaStreamAllocate+0x86>
    rccEnableDMA2(false);
 8002b8a:	4a1b      	ldr	r2, [pc, #108]	; (8002bf8 <dmaStreamAllocate+0xe8>)
 8002b8c:	4b1a      	ldr	r3, [pc, #104]	; (8002bf8 <dmaStreamAllocate+0xe8>)
 8002b8e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002b90:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8002b94:	6313      	str	r3, [r2, #48]	; 0x30
  }

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8002b96:	9b03      	ldr	r3, [sp, #12]
 8002b98:	681b      	ldr	r3, [r3, #0]
 8002b9a:	9a03      	ldr	r2, [sp, #12]
 8002b9c:	6812      	ldr	r2, [r2, #0]
 8002b9e:	6812      	ldr	r2, [r2, #0]
 8002ba0:	f022 021f 	bic.w	r2, r2, #31
 8002ba4:	601a      	str	r2, [r3, #0]
 8002ba6:	9b03      	ldr	r3, [sp, #12]
 8002ba8:	681b      	ldr	r3, [r3, #0]
 8002baa:	681b      	ldr	r3, [r3, #0]
 8002bac:	f003 0301 	and.w	r3, r3, #1
 8002bb0:	2b00      	cmp	r3, #0
 8002bb2:	d1f8      	bne.n	8002ba6 <dmaStreamAllocate+0x96>
 8002bb4:	9b03      	ldr	r3, [sp, #12]
 8002bb6:	685b      	ldr	r3, [r3, #4]
 8002bb8:	9a03      	ldr	r2, [sp, #12]
 8002bba:	7a12      	ldrb	r2, [r2, #8]
 8002bbc:	4611      	mov	r1, r2
 8002bbe:	223d      	movs	r2, #61	; 0x3d
 8002bc0:	408a      	lsls	r2, r1
 8002bc2:	601a      	str	r2, [r3, #0]
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 8002bc4:	9b03      	ldr	r3, [sp, #12]
 8002bc6:	681b      	ldr	r3, [r3, #0]
 8002bc8:	2200      	movs	r2, #0
 8002bca:	601a      	str	r2, [r3, #0]
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8002bcc:	9b03      	ldr	r3, [sp, #12]
 8002bce:	681b      	ldr	r3, [r3, #0]
 8002bd0:	2221      	movs	r2, #33	; 0x21
 8002bd2:	615a      	str	r2, [r3, #20]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL) {
 8002bd4:	9b01      	ldr	r3, [sp, #4]
 8002bd6:	2b00      	cmp	r3, #0
 8002bd8:	d005      	beq.n	8002be6 <dmaStreamAllocate+0xd6>
    nvicEnableVector(dmastp->vector, priority);
 8002bda:	9b03      	ldr	r3, [sp, #12]
 8002bdc:	7a9b      	ldrb	r3, [r3, #10]
 8002bde:	4618      	mov	r0, r3
 8002be0:	9902      	ldr	r1, [sp, #8]
 8002be2:	f001 fe0d 	bl	8004800 <nvicEnableVector>
  }

  return false;
 8002be6:	2300      	movs	r3, #0
}
 8002be8:	4618      	mov	r0, r3
 8002bea:	b005      	add	sp, #20
 8002bec:	f85d fb04 	ldr.w	pc, [sp], #4
 8002bf0:	20000980 	.word	0x20000980
 8002bf4:	20000984 	.word	0x20000984
 8002bf8:	40023800 	.word	0x40023800
 8002bfc:	00000000 	.word	0x00000000

08002c00 <port_lock.lto_priv.186>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002c00:	b082      	sub	sp, #8
 8002c02:	2320      	movs	r3, #32
 8002c04:	9301      	str	r3, [sp, #4]
 8002c06:	9b01      	ldr	r3, [sp, #4]
 8002c08:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002c0c:	b002      	add	sp, #8
 8002c0e:	4770      	bx	lr

08002c10 <port_unlock.lto_priv.184>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002c10:	b082      	sub	sp, #8
 8002c12:	2300      	movs	r3, #0
 8002c14:	9301      	str	r3, [sp, #4]
 8002c16:	9b01      	ldr	r3, [sp, #4]
 8002c18:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002c1c:	b002      	add	sp, #8
 8002c1e:	4770      	bx	lr

08002c20 <port_lock_from_isr.lto_priv.182>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8002c20:	b508      	push	{r3, lr}

  port_lock();
 8002c22:	f7ff ffed 	bl	8002c00 <port_lock.lto_priv.186>
}
 8002c26:	bd08      	pop	{r3, pc}
	...

08002c30 <port_unlock_from_isr.lto_priv.180>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8002c30:	b508      	push	{r3, lr}

  port_unlock();
 8002c32:	f7ff ffed 	bl	8002c10 <port_unlock.lto_priv.184>
}
 8002c36:	bd08      	pop	{r3, pc}
	...

08002c40 <chSysLockFromISR.lto_priv.178>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8002c40:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8002c42:	f7ff ffed 	bl	8002c20 <port_lock_from_isr.lto_priv.182>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8002c46:	bd08      	pop	{r3, pc}
	...

08002c50 <chSysUnlockFromISR.lto_priv.176>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8002c50:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8002c52:	f7ff ffed 	bl	8002c30 <port_unlock_from_isr.lto_priv.180>
}
 8002c56:	bd08      	pop	{r3, pc}
	...

08002c60 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8002c60:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8002c62:	f7ff ffed 	bl	8002c40 <chSysLockFromISR.lto_priv.178>
}
 8002c66:	bd08      	pop	{r3, pc}
	...

08002c70 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8002c70:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8002c72:	f7ff ffed 	bl	8002c50 <chSysUnlockFromISR.lto_priv.176>
}
 8002c76:	bd08      	pop	{r3, pc}
	...

08002c80 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8002c80:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
 8002c82:	f002 fca5 	bl	80055d0 <chSysTimerHandlerI>
}
 8002c86:	bd08      	pop	{r3, pc}
	...

08002c90 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8002c90:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8002c92:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002c96:	691b      	ldr	r3, [r3, #16]
 8002c98:	f003 0302 	and.w	r3, r3, #2
 8002c9c:	2b00      	cmp	r3, #0
 8002c9e:	d009      	beq.n	8002cb4 <VectorB0+0x24>
    STM32_ST_TIM->SR = 0U;
 8002ca0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002ca4:	2200      	movs	r2, #0
 8002ca6:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 8002ca8:	f7ff ffda 	bl	8002c60 <osalSysLockFromISR>
    osalOsTimerHandlerI();
 8002cac:	f7ff ffe8 	bl	8002c80 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 8002cb0:	f7ff ffde 	bl	8002c70 <osalSysUnlockFromISR>
  }

  OSAL_IRQ_EPILOGUE();
 8002cb4:	f001 ffac 	bl	8004c10 <_port_irq_epilogue>
}
 8002cb8:	bd08      	pop	{r3, pc}
 8002cba:	bf00      	nop
 8002cbc:	0000      	movs	r0, r0
	...

08002cc0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8002cc0:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8002cc2:	4a19      	ldr	r2, [pc, #100]	; (8002d28 <st_lld_init+0x68>)
 8002cc4:	4b18      	ldr	r3, [pc, #96]	; (8002d28 <st_lld_init+0x68>)
 8002cc6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002cc8:	f043 0301 	orr.w	r3, r3, #1
 8002ccc:	6413      	str	r3, [r2, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8002cce:	4a17      	ldr	r2, [pc, #92]	; (8002d2c <st_lld_init+0x6c>)
 8002cd0:	4b16      	ldr	r3, [pc, #88]	; (8002d2c <st_lld_init+0x6c>)
 8002cd2:	689b      	ldr	r3, [r3, #8]
 8002cd4:	f043 0301 	orr.w	r3, r3, #1
 8002cd8:	6093      	str	r3, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8002cda:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002cde:	f242 02cf 	movw	r2, #8399	; 0x20cf
 8002ce2:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8002ce4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002ce8:	f04f 32ff 	mov.w	r2, #4294967295
 8002cec:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8002cee:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002cf2:	2200      	movs	r2, #0
 8002cf4:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8002cf6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002cfa:	2200      	movs	r2, #0
 8002cfc:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8002cfe:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002d02:	2200      	movs	r2, #0
 8002d04:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8002d06:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002d0a:	2200      	movs	r2, #0
 8002d0c:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8002d0e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002d12:	2201      	movs	r2, #1
 8002d14:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8002d16:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002d1a:	2201      	movs	r2, #1
 8002d1c:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8002d1e:	201c      	movs	r0, #28
 8002d20:	2108      	movs	r1, #8
 8002d22:	f001 fd6d 	bl	8004800 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8002d26:	bd08      	pop	{r3, pc}
 8002d28:	40023800 	.word	0x40023800
 8002d2c:	e0042000 	.word	0xe0042000

08002d30 <ext_lld_init>:
/**
 * @brief   Low level EXT driver initialization.
 *
 * @notapi
 */
void ext_lld_init(void) {
 8002d30:	b508      	push	{r3, lr}

  /* Driver initialization.*/
  extObjectInit(&EXTD1);
 8002d32:	4802      	ldr	r0, [pc, #8]	; (8002d3c <ext_lld_init+0xc>)
 8002d34:	f002 f84c 	bl	8004dd0 <extObjectInit>
}
 8002d38:	bd08      	pop	{r3, pc}
 8002d3a:	bf00      	nop
 8002d3c:	20000a04 	.word	0x20000a04

08002d40 <ext_lld_start>:
 *
 * @param[in] extp      pointer to the @p EXTDriver object
 *
 * @notapi
 */
void ext_lld_start(EXTDriver *extp) {
 8002d40:	b500      	push	{lr}
 8002d42:	b085      	sub	sp, #20
 8002d44:	9001      	str	r0, [sp, #4]
  expchannel_t line;

  if (extp->state == EXT_STOP)
 8002d46:	9b01      	ldr	r3, [sp, #4]
 8002d48:	781b      	ldrb	r3, [r3, #0]
 8002d4a:	2b01      	cmp	r3, #1
 8002d4c:	d101      	bne.n	8002d52 <ext_lld_start+0x12>
    ext_lld_exti_irq_enable();
 8002d4e:	f000 fb6f 	bl	8003430 <ext_lld_exti_irq_enable>

  /* Configuration of automatic channels.*/
  for (line = 0; line < EXT_MAX_CHANNELS; line++)
 8002d52:	2300      	movs	r3, #0
 8002d54:	9303      	str	r3, [sp, #12]
 8002d56:	e014      	b.n	8002d82 <ext_lld_start+0x42>
    if (extp->config->channels[line].mode & EXT_CH_MODE_AUTOSTART)
 8002d58:	9b01      	ldr	r3, [sp, #4]
 8002d5a:	685b      	ldr	r3, [r3, #4]
 8002d5c:	9a03      	ldr	r2, [sp, #12]
 8002d5e:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8002d62:	f003 0304 	and.w	r3, r3, #4
 8002d66:	2b00      	cmp	r3, #0
 8002d68:	d004      	beq.n	8002d74 <ext_lld_start+0x34>
      ext_lld_channel_enable(extp, line);
 8002d6a:	9801      	ldr	r0, [sp, #4]
 8002d6c:	9903      	ldr	r1, [sp, #12]
 8002d6e:	f000 f80f 	bl	8002d90 <ext_lld_channel_enable>
 8002d72:	e003      	b.n	8002d7c <ext_lld_start+0x3c>
    else
      ext_lld_channel_disable(extp, line);
 8002d74:	9801      	ldr	r0, [sp, #4]
 8002d76:	9903      	ldr	r1, [sp, #12]
 8002d78:	f000 f89a 	bl	8002eb0 <ext_lld_channel_disable>

  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (line = 0; line < EXT_MAX_CHANNELS; line++)
 8002d7c:	9b03      	ldr	r3, [sp, #12]
 8002d7e:	3301      	adds	r3, #1
 8002d80:	9303      	str	r3, [sp, #12]
 8002d82:	9b03      	ldr	r3, [sp, #12]
 8002d84:	2b16      	cmp	r3, #22
 8002d86:	d9e7      	bls.n	8002d58 <ext_lld_start+0x18>
    if (extp->config->channels[line].mode & EXT_CH_MODE_AUTOSTART)
      ext_lld_channel_enable(extp, line);
    else
      ext_lld_channel_disable(extp, line);
}
 8002d88:	b005      	add	sp, #20
 8002d8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d8e:	bf00      	nop

08002d90 <ext_lld_channel_enable>:
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] channel   channel to be enabled
 *
 * @notapi
 */
void ext_lld_channel_enable(EXTDriver *extp, expchannel_t channel) {
 8002d90:	b086      	sub	sp, #24
 8002d92:	9001      	str	r0, [sp, #4]
 8002d94:	9100      	str	r1, [sp, #0]
  uint32_t cmask = (1 << (channel & 0x1F));
 8002d96:	9b00      	ldr	r3, [sp, #0]
 8002d98:	f003 031f 	and.w	r3, r3, #31
 8002d9c:	2201      	movs	r2, #1
 8002d9e:	fa02 f303 	lsl.w	r3, r2, r3
 8002da2:	9305      	str	r3, [sp, #20]

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
 8002da4:	9b00      	ldr	r3, [sp, #0]
 8002da6:	2b0f      	cmp	r3, #15
 8002da8:	d827      	bhi.n	8002dfa <ext_lld_channel_enable+0x6a>
    uint32_t n = channel >> 2;
 8002daa:	9b00      	ldr	r3, [sp, #0]
 8002dac:	089b      	lsrs	r3, r3, #2
 8002dae:	9304      	str	r3, [sp, #16]
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
 8002db0:	9b00      	ldr	r3, [sp, #0]
 8002db2:	f003 0303 	and.w	r3, r3, #3
 8002db6:	009b      	lsls	r3, r3, #2
 8002db8:	461a      	mov	r2, r3
 8002dba:	230f      	movs	r3, #15
 8002dbc:	4093      	lsls	r3, r2
 8002dbe:	43db      	mvns	r3, r3
 8002dc0:	9303      	str	r3, [sp, #12]
    uint32_t port = ((extp->config->channels[channel].mode &
 8002dc2:	9b01      	ldr	r3, [sp, #4]
 8002dc4:	685b      	ldr	r3, [r3, #4]
 8002dc6:	9a00      	ldr	r2, [sp, #0]
 8002dc8:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8002dcc:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
                      EXT_MODE_GPIO_MASK) >>
 8002dd0:	091b      	lsrs	r3, r3, #4
                     EXT_MODE_GPIO_OFF) << ((channel & 3) * 4);
 8002dd2:	9a00      	ldr	r2, [sp, #0]
 8002dd4:	f002 0203 	and.w	r2, r2, #3
 8002dd8:	0092      	lsls	r2, r2, #2

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
    uint32_t n = channel >> 2;
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
    uint32_t port = ((extp->config->channels[channel].mode &
 8002dda:	4093      	lsls	r3, r2
 8002ddc:	9302      	str	r3, [sp, #8]
                     EXT_MODE_GPIO_OFF) << ((channel & 3) * 4);

#if defined(STM32F1XX)
    AFIO->EXTICR[n] = (AFIO->EXTICR[n] & mask) | port;
#else /* !defined(STM32F1XX) */
    SYSCFG->EXTICR[n] = (SYSCFG->EXTICR[n] & mask) | port;
 8002dde:	4930      	ldr	r1, [pc, #192]	; (8002ea0 <ext_lld_channel_enable+0x110>)
 8002de0:	4a2f      	ldr	r2, [pc, #188]	; (8002ea0 <ext_lld_channel_enable+0x110>)
 8002de2:	9b04      	ldr	r3, [sp, #16]
 8002de4:	3302      	adds	r3, #2
 8002de6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8002dea:	9b03      	ldr	r3, [sp, #12]
 8002dec:	401a      	ands	r2, r3
 8002dee:	9b02      	ldr	r3, [sp, #8]
 8002df0:	431a      	orrs	r2, r3
 8002df2:	9b04      	ldr	r3, [sp, #16]
 8002df4:	3302      	adds	r3, #2
 8002df6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((cmask & STM32_EXTI_IMR_MASK) != 0U) {
      return;
    }

    /* Programming edge registers.*/
    if (extp->config->channels[channel].mode & EXT_CH_MODE_RISING_EDGE)
 8002dfa:	9b01      	ldr	r3, [sp, #4]
 8002dfc:	685b      	ldr	r3, [r3, #4]
 8002dfe:	9a00      	ldr	r2, [sp, #0]
 8002e00:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8002e04:	f003 0301 	and.w	r3, r3, #1
 8002e08:	2b00      	cmp	r3, #0
 8002e0a:	d006      	beq.n	8002e1a <ext_lld_channel_enable+0x8a>
      EXTI->RTSR |= cmask;
 8002e0c:	4925      	ldr	r1, [pc, #148]	; (8002ea4 <ext_lld_channel_enable+0x114>)
 8002e0e:	4b25      	ldr	r3, [pc, #148]	; (8002ea4 <ext_lld_channel_enable+0x114>)
 8002e10:	689a      	ldr	r2, [r3, #8]
 8002e12:	9b05      	ldr	r3, [sp, #20]
 8002e14:	4313      	orrs	r3, r2
 8002e16:	608b      	str	r3, [r1, #8]
 8002e18:	e006      	b.n	8002e28 <ext_lld_channel_enable+0x98>
    else
      EXTI->RTSR &= ~cmask;
 8002e1a:	4922      	ldr	r1, [pc, #136]	; (8002ea4 <ext_lld_channel_enable+0x114>)
 8002e1c:	4b21      	ldr	r3, [pc, #132]	; (8002ea4 <ext_lld_channel_enable+0x114>)
 8002e1e:	689a      	ldr	r2, [r3, #8]
 8002e20:	9b05      	ldr	r3, [sp, #20]
 8002e22:	43db      	mvns	r3, r3
 8002e24:	4013      	ands	r3, r2
 8002e26:	608b      	str	r3, [r1, #8]
    if (extp->config->channels[channel].mode & EXT_CH_MODE_FALLING_EDGE)
 8002e28:	9b01      	ldr	r3, [sp, #4]
 8002e2a:	685b      	ldr	r3, [r3, #4]
 8002e2c:	9a00      	ldr	r2, [sp, #0]
 8002e2e:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8002e32:	f003 0302 	and.w	r3, r3, #2
 8002e36:	2b00      	cmp	r3, #0
 8002e38:	d006      	beq.n	8002e48 <ext_lld_channel_enable+0xb8>
      EXTI->FTSR |= cmask;
 8002e3a:	491a      	ldr	r1, [pc, #104]	; (8002ea4 <ext_lld_channel_enable+0x114>)
 8002e3c:	4b19      	ldr	r3, [pc, #100]	; (8002ea4 <ext_lld_channel_enable+0x114>)
 8002e3e:	68da      	ldr	r2, [r3, #12]
 8002e40:	9b05      	ldr	r3, [sp, #20]
 8002e42:	4313      	orrs	r3, r2
 8002e44:	60cb      	str	r3, [r1, #12]
 8002e46:	e006      	b.n	8002e56 <ext_lld_channel_enable+0xc6>
    else
      EXTI->FTSR &= ~cmask;
 8002e48:	4916      	ldr	r1, [pc, #88]	; (8002ea4 <ext_lld_channel_enable+0x114>)
 8002e4a:	4b16      	ldr	r3, [pc, #88]	; (8002ea4 <ext_lld_channel_enable+0x114>)
 8002e4c:	68da      	ldr	r2, [r3, #12]
 8002e4e:	9b05      	ldr	r3, [sp, #20]
 8002e50:	43db      	mvns	r3, r3
 8002e52:	4013      	ands	r3, r2
 8002e54:	60cb      	str	r3, [r1, #12]

    /* Programming interrupt and event registers.*/
    if (extp->config->channels[channel].cb != NULL) {
 8002e56:	9b01      	ldr	r3, [sp, #4]
 8002e58:	685a      	ldr	r2, [r3, #4]
 8002e5a:	9b00      	ldr	r3, [sp, #0]
 8002e5c:	00db      	lsls	r3, r3, #3
 8002e5e:	4413      	add	r3, r2
 8002e60:	685b      	ldr	r3, [r3, #4]
 8002e62:	2b00      	cmp	r3, #0
 8002e64:	d00d      	beq.n	8002e82 <ext_lld_channel_enable+0xf2>
      EXTI->IMR |= cmask;
 8002e66:	490f      	ldr	r1, [pc, #60]	; (8002ea4 <ext_lld_channel_enable+0x114>)
 8002e68:	4b0e      	ldr	r3, [pc, #56]	; (8002ea4 <ext_lld_channel_enable+0x114>)
 8002e6a:	681a      	ldr	r2, [r3, #0]
 8002e6c:	9b05      	ldr	r3, [sp, #20]
 8002e6e:	4313      	orrs	r3, r2
 8002e70:	600b      	str	r3, [r1, #0]
      EXTI->EMR &= ~cmask;
 8002e72:	490c      	ldr	r1, [pc, #48]	; (8002ea4 <ext_lld_channel_enable+0x114>)
 8002e74:	4b0b      	ldr	r3, [pc, #44]	; (8002ea4 <ext_lld_channel_enable+0x114>)
 8002e76:	685a      	ldr	r2, [r3, #4]
 8002e78:	9b05      	ldr	r3, [sp, #20]
 8002e7a:	43db      	mvns	r3, r3
 8002e7c:	4013      	ands	r3, r2
 8002e7e:	604b      	str	r3, [r1, #4]
 8002e80:	e00c      	b.n	8002e9c <ext_lld_channel_enable+0x10c>
    }
    else {
      EXTI->EMR |= cmask;
 8002e82:	4908      	ldr	r1, [pc, #32]	; (8002ea4 <ext_lld_channel_enable+0x114>)
 8002e84:	4b07      	ldr	r3, [pc, #28]	; (8002ea4 <ext_lld_channel_enable+0x114>)
 8002e86:	685a      	ldr	r2, [r3, #4]
 8002e88:	9b05      	ldr	r3, [sp, #20]
 8002e8a:	4313      	orrs	r3, r2
 8002e8c:	604b      	str	r3, [r1, #4]
      EXTI->IMR &= ~cmask;
 8002e8e:	4905      	ldr	r1, [pc, #20]	; (8002ea4 <ext_lld_channel_enable+0x114>)
 8002e90:	4b04      	ldr	r3, [pc, #16]	; (8002ea4 <ext_lld_channel_enable+0x114>)
 8002e92:	681a      	ldr	r2, [r3, #0]
 8002e94:	9b05      	ldr	r3, [sp, #20]
 8002e96:	43db      	mvns	r3, r3
 8002e98:	4013      	ands	r3, r2
 8002e9a:	600b      	str	r3, [r1, #0]
      EXTI->EMR2 |= cmask;
      EXTI->IMR2 &= ~cmask;
    }
  }
#endif
}
 8002e9c:	b006      	add	sp, #24
 8002e9e:	4770      	bx	lr
 8002ea0:	40013800 	.word	0x40013800
 8002ea4:	40013c00 	.word	0x40013c00
	...

08002eb0 <ext_lld_channel_disable>:
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] channel   channel to be disabled
 *
 * @notapi
 */
void ext_lld_channel_disable(EXTDriver *extp, expchannel_t channel) {
 8002eb0:	b084      	sub	sp, #16
 8002eb2:	9001      	str	r0, [sp, #4]
 8002eb4:	9100      	str	r1, [sp, #0]
  uint32_t cmask = (1 << (channel & 0x1F));
 8002eb6:	9b00      	ldr	r3, [sp, #0]
 8002eb8:	f003 031f 	and.w	r3, r3, #31
 8002ebc:	2201      	movs	r2, #1
 8002ebe:	fa02 f303 	lsl.w	r3, r2, r3
 8002ec2:	9303      	str	r3, [sp, #12]
  (void)extp;

#if STM32_EXTI_NUM_LINES > 32
  if (channel < 32) {
#endif
    EXTI->IMR  &= ~cmask;
 8002ec4:	4910      	ldr	r1, [pc, #64]	; (8002f08 <ext_lld_channel_disable+0x58>)
 8002ec6:	4b10      	ldr	r3, [pc, #64]	; (8002f08 <ext_lld_channel_disable+0x58>)
 8002ec8:	681a      	ldr	r2, [r3, #0]
 8002eca:	9b03      	ldr	r3, [sp, #12]
 8002ecc:	43db      	mvns	r3, r3
 8002ece:	4013      	ands	r3, r2
 8002ed0:	600b      	str	r3, [r1, #0]
    EXTI->EMR  &= ~cmask;
 8002ed2:	490d      	ldr	r1, [pc, #52]	; (8002f08 <ext_lld_channel_disable+0x58>)
 8002ed4:	4b0c      	ldr	r3, [pc, #48]	; (8002f08 <ext_lld_channel_disable+0x58>)
 8002ed6:	685a      	ldr	r2, [r3, #4]
 8002ed8:	9b03      	ldr	r3, [sp, #12]
 8002eda:	43db      	mvns	r3, r3
 8002edc:	4013      	ands	r3, r2
 8002ede:	604b      	str	r3, [r1, #4]
    EXTI->RTSR &= ~cmask;
 8002ee0:	4909      	ldr	r1, [pc, #36]	; (8002f08 <ext_lld_channel_disable+0x58>)
 8002ee2:	4b09      	ldr	r3, [pc, #36]	; (8002f08 <ext_lld_channel_disable+0x58>)
 8002ee4:	689a      	ldr	r2, [r3, #8]
 8002ee6:	9b03      	ldr	r3, [sp, #12]
 8002ee8:	43db      	mvns	r3, r3
 8002eea:	4013      	ands	r3, r2
 8002eec:	608b      	str	r3, [r1, #8]
    EXTI->FTSR &= ~cmask;
 8002eee:	4906      	ldr	r1, [pc, #24]	; (8002f08 <ext_lld_channel_disable+0x58>)
 8002ef0:	4b05      	ldr	r3, [pc, #20]	; (8002f08 <ext_lld_channel_disable+0x58>)
 8002ef2:	68da      	ldr	r2, [r3, #12]
 8002ef4:	9b03      	ldr	r3, [sp, #12]
 8002ef6:	43db      	mvns	r3, r3
 8002ef8:	4013      	ands	r3, r2
 8002efa:	60cb      	str	r3, [r1, #12]
    EXTI->PR    =  cmask;
 8002efc:	4a02      	ldr	r2, [pc, #8]	; (8002f08 <ext_lld_channel_disable+0x58>)
 8002efe:	9b03      	ldr	r3, [sp, #12]
 8002f00:	6153      	str	r3, [r2, #20]
    EXTI->RTSR2 &= ~cmask;
    EXTI->FTSR2 &= ~cmask;
    EXTI->PR2    =  cmask;
  }
#endif
}
 8002f02:	b004      	add	sp, #16
 8002f04:	4770      	bx	lr
 8002f06:	bf00      	nop
 8002f08:	40013c00 	.word	0x40013c00
 8002f0c:	00000000 	.word	0x00000000

08002f10 <Vector58>:
/**
 * @brief   EXTI[0] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector58) {
 8002f10:	b500      	push	{lr}
 8002f12:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8002f14:	4b0e      	ldr	r3, [pc, #56]	; (8002f50 <Vector58+0x40>)
 8002f16:	695b      	ldr	r3, [r3, #20]
 8002f18:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & (1U << 0);
 8002f1a:	4b0d      	ldr	r3, [pc, #52]	; (8002f50 <Vector58+0x40>)
 8002f1c:	681b      	ldr	r3, [r3, #0]
 8002f1e:	f003 0301 	and.w	r3, r3, #1
 8002f22:	9a01      	ldr	r2, [sp, #4]
 8002f24:	4013      	ands	r3, r2
 8002f26:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8002f28:	4a09      	ldr	r2, [pc, #36]	; (8002f50 <Vector58+0x40>)
 8002f2a:	9b01      	ldr	r3, [sp, #4]
 8002f2c:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 0))
 8002f2e:	9b01      	ldr	r3, [sp, #4]
 8002f30:	f003 0301 	and.w	r3, r3, #1
 8002f34:	2b00      	cmp	r3, #0
 8002f36:	d005      	beq.n	8002f44 <Vector58+0x34>
    EXTD1.config->channels[0].cb(&EXTD1, 0);
 8002f38:	4b06      	ldr	r3, [pc, #24]	; (8002f54 <Vector58+0x44>)
 8002f3a:	685b      	ldr	r3, [r3, #4]
 8002f3c:	685b      	ldr	r3, [r3, #4]
 8002f3e:	4805      	ldr	r0, [pc, #20]	; (8002f54 <Vector58+0x44>)
 8002f40:	2100      	movs	r1, #0
 8002f42:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002f44:	f001 fe64 	bl	8004c10 <_port_irq_epilogue>
}
 8002f48:	b003      	add	sp, #12
 8002f4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f4e:	bf00      	nop
 8002f50:	40013c00 	.word	0x40013c00
 8002f54:	20000a04 	.word	0x20000a04
	...

08002f60 <Vector5C>:
/**
 * @brief   EXTI[1] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector5C) {
 8002f60:	b500      	push	{lr}
 8002f62:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8002f64:	4b0e      	ldr	r3, [pc, #56]	; (8002fa0 <Vector5C+0x40>)
 8002f66:	695b      	ldr	r3, [r3, #20]
 8002f68:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & (1U << 1);
 8002f6a:	4b0d      	ldr	r3, [pc, #52]	; (8002fa0 <Vector5C+0x40>)
 8002f6c:	681b      	ldr	r3, [r3, #0]
 8002f6e:	f003 0302 	and.w	r3, r3, #2
 8002f72:	9a01      	ldr	r2, [sp, #4]
 8002f74:	4013      	ands	r3, r2
 8002f76:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8002f78:	4a09      	ldr	r2, [pc, #36]	; (8002fa0 <Vector5C+0x40>)
 8002f7a:	9b01      	ldr	r3, [sp, #4]
 8002f7c:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 1))
 8002f7e:	9b01      	ldr	r3, [sp, #4]
 8002f80:	f003 0302 	and.w	r3, r3, #2
 8002f84:	2b00      	cmp	r3, #0
 8002f86:	d005      	beq.n	8002f94 <Vector5C+0x34>
    EXTD1.config->channels[1].cb(&EXTD1, 1);
 8002f88:	4b06      	ldr	r3, [pc, #24]	; (8002fa4 <Vector5C+0x44>)
 8002f8a:	685b      	ldr	r3, [r3, #4]
 8002f8c:	68db      	ldr	r3, [r3, #12]
 8002f8e:	4805      	ldr	r0, [pc, #20]	; (8002fa4 <Vector5C+0x44>)
 8002f90:	2101      	movs	r1, #1
 8002f92:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002f94:	f001 fe3c 	bl	8004c10 <_port_irq_epilogue>
}
 8002f98:	b003      	add	sp, #12
 8002f9a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f9e:	bf00      	nop
 8002fa0:	40013c00 	.word	0x40013c00
 8002fa4:	20000a04 	.word	0x20000a04
	...

08002fb0 <Vector60>:
/**
 * @brief   EXTI[2] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector60) {
 8002fb0:	b500      	push	{lr}
 8002fb2:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8002fb4:	4b0e      	ldr	r3, [pc, #56]	; (8002ff0 <Vector60+0x40>)
 8002fb6:	695b      	ldr	r3, [r3, #20]
 8002fb8:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & (1U << 2);
 8002fba:	4b0d      	ldr	r3, [pc, #52]	; (8002ff0 <Vector60+0x40>)
 8002fbc:	681b      	ldr	r3, [r3, #0]
 8002fbe:	f003 0304 	and.w	r3, r3, #4
 8002fc2:	9a01      	ldr	r2, [sp, #4]
 8002fc4:	4013      	ands	r3, r2
 8002fc6:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8002fc8:	4a09      	ldr	r2, [pc, #36]	; (8002ff0 <Vector60+0x40>)
 8002fca:	9b01      	ldr	r3, [sp, #4]
 8002fcc:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 2))
 8002fce:	9b01      	ldr	r3, [sp, #4]
 8002fd0:	f003 0304 	and.w	r3, r3, #4
 8002fd4:	2b00      	cmp	r3, #0
 8002fd6:	d005      	beq.n	8002fe4 <Vector60+0x34>
    EXTD1.config->channels[2].cb(&EXTD1, 2);
 8002fd8:	4b06      	ldr	r3, [pc, #24]	; (8002ff4 <Vector60+0x44>)
 8002fda:	685b      	ldr	r3, [r3, #4]
 8002fdc:	695b      	ldr	r3, [r3, #20]
 8002fde:	4805      	ldr	r0, [pc, #20]	; (8002ff4 <Vector60+0x44>)
 8002fe0:	2102      	movs	r1, #2
 8002fe2:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002fe4:	f001 fe14 	bl	8004c10 <_port_irq_epilogue>
}
 8002fe8:	b003      	add	sp, #12
 8002fea:	f85d fb04 	ldr.w	pc, [sp], #4
 8002fee:	bf00      	nop
 8002ff0:	40013c00 	.word	0x40013c00
 8002ff4:	20000a04 	.word	0x20000a04
	...

08003000 <Vector64>:
/**
 * @brief   EXTI[3] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector64) {
 8003000:	b500      	push	{lr}
 8003002:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8003004:	4b0e      	ldr	r3, [pc, #56]	; (8003040 <Vector64+0x40>)
 8003006:	695b      	ldr	r3, [r3, #20]
 8003008:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & (1U << 3);
 800300a:	4b0d      	ldr	r3, [pc, #52]	; (8003040 <Vector64+0x40>)
 800300c:	681b      	ldr	r3, [r3, #0]
 800300e:	f003 0308 	and.w	r3, r3, #8
 8003012:	9a01      	ldr	r2, [sp, #4]
 8003014:	4013      	ands	r3, r2
 8003016:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8003018:	4a09      	ldr	r2, [pc, #36]	; (8003040 <Vector64+0x40>)
 800301a:	9b01      	ldr	r3, [sp, #4]
 800301c:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 3))
 800301e:	9b01      	ldr	r3, [sp, #4]
 8003020:	f003 0308 	and.w	r3, r3, #8
 8003024:	2b00      	cmp	r3, #0
 8003026:	d005      	beq.n	8003034 <Vector64+0x34>
    EXTD1.config->channels[3].cb(&EXTD1, 3);
 8003028:	4b06      	ldr	r3, [pc, #24]	; (8003044 <Vector64+0x44>)
 800302a:	685b      	ldr	r3, [r3, #4]
 800302c:	69db      	ldr	r3, [r3, #28]
 800302e:	4805      	ldr	r0, [pc, #20]	; (8003044 <Vector64+0x44>)
 8003030:	2103      	movs	r1, #3
 8003032:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003034:	f001 fdec 	bl	8004c10 <_port_irq_epilogue>
}
 8003038:	b003      	add	sp, #12
 800303a:	f85d fb04 	ldr.w	pc, [sp], #4
 800303e:	bf00      	nop
 8003040:	40013c00 	.word	0x40013c00
 8003044:	20000a04 	.word	0x20000a04
	...

08003050 <Vector68>:
/**
 * @brief   EXTI[4] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector68) {
 8003050:	b500      	push	{lr}
 8003052:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8003054:	4b0e      	ldr	r3, [pc, #56]	; (8003090 <Vector68+0x40>)
 8003056:	695b      	ldr	r3, [r3, #20]
 8003058:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & (1U << 4);
 800305a:	4b0d      	ldr	r3, [pc, #52]	; (8003090 <Vector68+0x40>)
 800305c:	681b      	ldr	r3, [r3, #0]
 800305e:	f003 0310 	and.w	r3, r3, #16
 8003062:	9a01      	ldr	r2, [sp, #4]
 8003064:	4013      	ands	r3, r2
 8003066:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8003068:	4a09      	ldr	r2, [pc, #36]	; (8003090 <Vector68+0x40>)
 800306a:	9b01      	ldr	r3, [sp, #4]
 800306c:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 4))
 800306e:	9b01      	ldr	r3, [sp, #4]
 8003070:	f003 0310 	and.w	r3, r3, #16
 8003074:	2b00      	cmp	r3, #0
 8003076:	d005      	beq.n	8003084 <Vector68+0x34>
    EXTD1.config->channels[4].cb(&EXTD1, 4);
 8003078:	4b06      	ldr	r3, [pc, #24]	; (8003094 <Vector68+0x44>)
 800307a:	685b      	ldr	r3, [r3, #4]
 800307c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800307e:	4805      	ldr	r0, [pc, #20]	; (8003094 <Vector68+0x44>)
 8003080:	2104      	movs	r1, #4
 8003082:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003084:	f001 fdc4 	bl	8004c10 <_port_irq_epilogue>
}
 8003088:	b003      	add	sp, #12
 800308a:	f85d fb04 	ldr.w	pc, [sp], #4
 800308e:	bf00      	nop
 8003090:	40013c00 	.word	0x40013c00
 8003094:	20000a04 	.word	0x20000a04
	...

080030a0 <Vector9C>:
/**
 * @brief   EXTI[5]...EXTI[9] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector9C) {
 80030a0:	b500      	push	{lr}
 80030a2:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 80030a4:	4b24      	ldr	r3, [pc, #144]	; (8003138 <Vector9C+0x98>)
 80030a6:	695b      	ldr	r3, [r3, #20]
 80030a8:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & ((1U << 5) | (1U << 6) | (1U << 7) | (1U << 8) |
 80030aa:	4b23      	ldr	r3, [pc, #140]	; (8003138 <Vector9C+0x98>)
 80030ac:	681b      	ldr	r3, [r3, #0]
 80030ae:	f403 7378 	and.w	r3, r3, #992	; 0x3e0
 80030b2:	9a01      	ldr	r2, [sp, #4]
 80030b4:	4013      	ands	r3, r2
 80030b6:	9301      	str	r3, [sp, #4]
                     (1U << 9));
  EXTI->PR = pr;
 80030b8:	4a1f      	ldr	r2, [pc, #124]	; (8003138 <Vector9C+0x98>)
 80030ba:	9b01      	ldr	r3, [sp, #4]
 80030bc:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 5))
 80030be:	9b01      	ldr	r3, [sp, #4]
 80030c0:	f003 0320 	and.w	r3, r3, #32
 80030c4:	2b00      	cmp	r3, #0
 80030c6:	d005      	beq.n	80030d4 <Vector9C+0x34>
    EXTD1.config->channels[5].cb(&EXTD1, 5);
 80030c8:	4b1c      	ldr	r3, [pc, #112]	; (800313c <Vector9C+0x9c>)
 80030ca:	685b      	ldr	r3, [r3, #4]
 80030cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80030ce:	481b      	ldr	r0, [pc, #108]	; (800313c <Vector9C+0x9c>)
 80030d0:	2105      	movs	r1, #5
 80030d2:	4798      	blx	r3
  if (pr & (1U << 6))
 80030d4:	9b01      	ldr	r3, [sp, #4]
 80030d6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80030da:	2b00      	cmp	r3, #0
 80030dc:	d005      	beq.n	80030ea <Vector9C+0x4a>
    EXTD1.config->channels[6].cb(&EXTD1, 6);
 80030de:	4b17      	ldr	r3, [pc, #92]	; (800313c <Vector9C+0x9c>)
 80030e0:	685b      	ldr	r3, [r3, #4]
 80030e2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80030e4:	4815      	ldr	r0, [pc, #84]	; (800313c <Vector9C+0x9c>)
 80030e6:	2106      	movs	r1, #6
 80030e8:	4798      	blx	r3
  if (pr & (1U << 7))
 80030ea:	9b01      	ldr	r3, [sp, #4]
 80030ec:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80030f0:	2b00      	cmp	r3, #0
 80030f2:	d005      	beq.n	8003100 <Vector9C+0x60>
    EXTD1.config->channels[7].cb(&EXTD1, 7);
 80030f4:	4b11      	ldr	r3, [pc, #68]	; (800313c <Vector9C+0x9c>)
 80030f6:	685b      	ldr	r3, [r3, #4]
 80030f8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80030fa:	4810      	ldr	r0, [pc, #64]	; (800313c <Vector9C+0x9c>)
 80030fc:	2107      	movs	r1, #7
 80030fe:	4798      	blx	r3
  if (pr & (1U << 8))
 8003100:	9b01      	ldr	r3, [sp, #4]
 8003102:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8003106:	2b00      	cmp	r3, #0
 8003108:	d005      	beq.n	8003116 <Vector9C+0x76>
    EXTD1.config->channels[8].cb(&EXTD1, 8);
 800310a:	4b0c      	ldr	r3, [pc, #48]	; (800313c <Vector9C+0x9c>)
 800310c:	685b      	ldr	r3, [r3, #4]
 800310e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003110:	480a      	ldr	r0, [pc, #40]	; (800313c <Vector9C+0x9c>)
 8003112:	2108      	movs	r1, #8
 8003114:	4798      	blx	r3
  if (pr & (1U << 9))
 8003116:	9b01      	ldr	r3, [sp, #4]
 8003118:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800311c:	2b00      	cmp	r3, #0
 800311e:	d005      	beq.n	800312c <Vector9C+0x8c>
    EXTD1.config->channels[9].cb(&EXTD1, 9);
 8003120:	4b06      	ldr	r3, [pc, #24]	; (800313c <Vector9C+0x9c>)
 8003122:	685b      	ldr	r3, [r3, #4]
 8003124:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003126:	4805      	ldr	r0, [pc, #20]	; (800313c <Vector9C+0x9c>)
 8003128:	2109      	movs	r1, #9
 800312a:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800312c:	f001 fd70 	bl	8004c10 <_port_irq_epilogue>
}
 8003130:	b003      	add	sp, #12
 8003132:	f85d fb04 	ldr.w	pc, [sp], #4
 8003136:	bf00      	nop
 8003138:	40013c00 	.word	0x40013c00
 800313c:	20000a04 	.word	0x20000a04

08003140 <VectorE0>:
/**
 * @brief   EXTI[10]...EXTI[15] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE0) {
 8003140:	b500      	push	{lr}
 8003142:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8003144:	4b29      	ldr	r3, [pc, #164]	; (80031ec <VectorE0+0xac>)
 8003146:	695b      	ldr	r3, [r3, #20]
 8003148:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & ((1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
 800314a:	4b28      	ldr	r3, [pc, #160]	; (80031ec <VectorE0+0xac>)
 800314c:	681b      	ldr	r3, [r3, #0]
 800314e:	f403 437c 	and.w	r3, r3, #64512	; 0xfc00
 8003152:	9a01      	ldr	r2, [sp, #4]
 8003154:	4013      	ands	r3, r2
 8003156:	9301      	str	r3, [sp, #4]
                     (1U << 14) | (1U << 15));
  EXTI->PR = pr;
 8003158:	4a24      	ldr	r2, [pc, #144]	; (80031ec <VectorE0+0xac>)
 800315a:	9b01      	ldr	r3, [sp, #4]
 800315c:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 10))
 800315e:	9b01      	ldr	r3, [sp, #4]
 8003160:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8003164:	2b00      	cmp	r3, #0
 8003166:	d005      	beq.n	8003174 <VectorE0+0x34>
    EXTD1.config->channels[10].cb(&EXTD1, 10);
 8003168:	4b21      	ldr	r3, [pc, #132]	; (80031f0 <VectorE0+0xb0>)
 800316a:	685b      	ldr	r3, [r3, #4]
 800316c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800316e:	4820      	ldr	r0, [pc, #128]	; (80031f0 <VectorE0+0xb0>)
 8003170:	210a      	movs	r1, #10
 8003172:	4798      	blx	r3
  if (pr & (1U << 11))
 8003174:	9b01      	ldr	r3, [sp, #4]
 8003176:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800317a:	2b00      	cmp	r3, #0
 800317c:	d005      	beq.n	800318a <VectorE0+0x4a>
    EXTD1.config->channels[11].cb(&EXTD1, 11);
 800317e:	4b1c      	ldr	r3, [pc, #112]	; (80031f0 <VectorE0+0xb0>)
 8003180:	685b      	ldr	r3, [r3, #4]
 8003182:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8003184:	481a      	ldr	r0, [pc, #104]	; (80031f0 <VectorE0+0xb0>)
 8003186:	210b      	movs	r1, #11
 8003188:	4798      	blx	r3
  if (pr & (1U << 12))
 800318a:	9b01      	ldr	r3, [sp, #4]
 800318c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8003190:	2b00      	cmp	r3, #0
 8003192:	d005      	beq.n	80031a0 <VectorE0+0x60>
    EXTD1.config->channels[12].cb(&EXTD1, 12);
 8003194:	4b16      	ldr	r3, [pc, #88]	; (80031f0 <VectorE0+0xb0>)
 8003196:	685b      	ldr	r3, [r3, #4]
 8003198:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800319a:	4815      	ldr	r0, [pc, #84]	; (80031f0 <VectorE0+0xb0>)
 800319c:	210c      	movs	r1, #12
 800319e:	4798      	blx	r3
  if (pr & (1U << 13))
 80031a0:	9b01      	ldr	r3, [sp, #4]
 80031a2:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 80031a6:	2b00      	cmp	r3, #0
 80031a8:	d005      	beq.n	80031b6 <VectorE0+0x76>
    EXTD1.config->channels[13].cb(&EXTD1, 13);
 80031aa:	4b11      	ldr	r3, [pc, #68]	; (80031f0 <VectorE0+0xb0>)
 80031ac:	685b      	ldr	r3, [r3, #4]
 80031ae:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80031b0:	480f      	ldr	r0, [pc, #60]	; (80031f0 <VectorE0+0xb0>)
 80031b2:	210d      	movs	r1, #13
 80031b4:	4798      	blx	r3
  if (pr & (1U << 14))
 80031b6:	9b01      	ldr	r3, [sp, #4]
 80031b8:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80031bc:	2b00      	cmp	r3, #0
 80031be:	d005      	beq.n	80031cc <VectorE0+0x8c>
    EXTD1.config->channels[14].cb(&EXTD1, 14);
 80031c0:	4b0b      	ldr	r3, [pc, #44]	; (80031f0 <VectorE0+0xb0>)
 80031c2:	685b      	ldr	r3, [r3, #4]
 80031c4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80031c6:	480a      	ldr	r0, [pc, #40]	; (80031f0 <VectorE0+0xb0>)
 80031c8:	210e      	movs	r1, #14
 80031ca:	4798      	blx	r3
  if (pr & (1U << 15))
 80031cc:	9b01      	ldr	r3, [sp, #4]
 80031ce:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80031d2:	2b00      	cmp	r3, #0
 80031d4:	d005      	beq.n	80031e2 <VectorE0+0xa2>
    EXTD1.config->channels[15].cb(&EXTD1, 15);
 80031d6:	4b06      	ldr	r3, [pc, #24]	; (80031f0 <VectorE0+0xb0>)
 80031d8:	685b      	ldr	r3, [r3, #4]
 80031da:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80031dc:	4804      	ldr	r0, [pc, #16]	; (80031f0 <VectorE0+0xb0>)
 80031de:	210f      	movs	r1, #15
 80031e0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80031e2:	f001 fd15 	bl	8004c10 <_port_irq_epilogue>
}
 80031e6:	b003      	add	sp, #12
 80031e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80031ec:	40013c00 	.word	0x40013c00
 80031f0:	20000a04 	.word	0x20000a04
	...

08003200 <Vector44>:
/**
 * @brief   EXTI[16] interrupt handler (PVD).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector44) {
 8003200:	b500      	push	{lr}
 8003202:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8003204:	4b0d      	ldr	r3, [pc, #52]	; (800323c <Vector44+0x3c>)
 8003206:	695b      	ldr	r3, [r3, #20]
 8003208:	9301      	str	r3, [sp, #4]
  pr = EXTI->IMR & (1U << 16);
 800320a:	4b0c      	ldr	r3, [pc, #48]	; (800323c <Vector44+0x3c>)
 800320c:	681b      	ldr	r3, [r3, #0]
 800320e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8003212:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8003214:	4a09      	ldr	r2, [pc, #36]	; (800323c <Vector44+0x3c>)
 8003216:	9b01      	ldr	r3, [sp, #4]
 8003218:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 16))
 800321a:	9b01      	ldr	r3, [sp, #4]
 800321c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8003220:	2b00      	cmp	r3, #0
 8003222:	d006      	beq.n	8003232 <Vector44+0x32>
    EXTD1.config->channels[16].cb(&EXTD1, 16);
 8003224:	4b06      	ldr	r3, [pc, #24]	; (8003240 <Vector44+0x40>)
 8003226:	685b      	ldr	r3, [r3, #4]
 8003228:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800322c:	4804      	ldr	r0, [pc, #16]	; (8003240 <Vector44+0x40>)
 800322e:	2110      	movs	r1, #16
 8003230:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003232:	f001 fced 	bl	8004c10 <_port_irq_epilogue>
}
 8003236:	b003      	add	sp, #12
 8003238:	f85d fb04 	ldr.w	pc, [sp], #4
 800323c:	40013c00 	.word	0x40013c00
 8003240:	20000a04 	.word	0x20000a04
	...

08003250 <VectorE4>:
/**
 * @brief   EXTI[17] interrupt handler (RTC_ALARM).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE4) {
 8003250:	b500      	push	{lr}
 8003252:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8003254:	4b0d      	ldr	r3, [pc, #52]	; (800328c <VectorE4+0x3c>)
 8003256:	695b      	ldr	r3, [r3, #20]
 8003258:	9301      	str	r3, [sp, #4]
  pr = EXTI->IMR & (1U << 17);
 800325a:	4b0c      	ldr	r3, [pc, #48]	; (800328c <VectorE4+0x3c>)
 800325c:	681b      	ldr	r3, [r3, #0]
 800325e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003262:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8003264:	4a09      	ldr	r2, [pc, #36]	; (800328c <VectorE4+0x3c>)
 8003266:	9b01      	ldr	r3, [sp, #4]
 8003268:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 17))
 800326a:	9b01      	ldr	r3, [sp, #4]
 800326c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003270:	2b00      	cmp	r3, #0
 8003272:	d006      	beq.n	8003282 <VectorE4+0x32>
    EXTD1.config->channels[17].cb(&EXTD1, 17);
 8003274:	4b06      	ldr	r3, [pc, #24]	; (8003290 <VectorE4+0x40>)
 8003276:	685b      	ldr	r3, [r3, #4]
 8003278:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800327c:	4804      	ldr	r0, [pc, #16]	; (8003290 <VectorE4+0x40>)
 800327e:	2111      	movs	r1, #17
 8003280:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003282:	f001 fcc5 	bl	8004c10 <_port_irq_epilogue>
}
 8003286:	b003      	add	sp, #12
 8003288:	f85d fb04 	ldr.w	pc, [sp], #4
 800328c:	40013c00 	.word	0x40013c00
 8003290:	20000a04 	.word	0x20000a04
	...

080032a0 <VectorE8>:
/**
 * @brief   EXTI[18] interrupt handler (OTG_FS_WKUP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE8) {
 80032a0:	b500      	push	{lr}
 80032a2:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 80032a4:	4b0e      	ldr	r3, [pc, #56]	; (80032e0 <VectorE8+0x40>)
 80032a6:	695b      	ldr	r3, [r3, #20]
 80032a8:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & (1U << 18);
 80032aa:	4b0d      	ldr	r3, [pc, #52]	; (80032e0 <VectorE8+0x40>)
 80032ac:	681b      	ldr	r3, [r3, #0]
 80032ae:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80032b2:	9a01      	ldr	r2, [sp, #4]
 80032b4:	4013      	ands	r3, r2
 80032b6:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 80032b8:	4a09      	ldr	r2, [pc, #36]	; (80032e0 <VectorE8+0x40>)
 80032ba:	9b01      	ldr	r3, [sp, #4]
 80032bc:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 18))
 80032be:	9b01      	ldr	r3, [sp, #4]
 80032c0:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80032c4:	2b00      	cmp	r3, #0
 80032c6:	d006      	beq.n	80032d6 <VectorE8+0x36>
    EXTD1.config->channels[18].cb(&EXTD1, 18);
 80032c8:	4b06      	ldr	r3, [pc, #24]	; (80032e4 <VectorE8+0x44>)
 80032ca:	685b      	ldr	r3, [r3, #4]
 80032cc:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80032d0:	4804      	ldr	r0, [pc, #16]	; (80032e4 <VectorE8+0x44>)
 80032d2:	2112      	movs	r1, #18
 80032d4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80032d6:	f001 fc9b 	bl	8004c10 <_port_irq_epilogue>
}
 80032da:	b003      	add	sp, #12
 80032dc:	f85d fb04 	ldr.w	pc, [sp], #4
 80032e0:	40013c00 	.word	0x40013c00
 80032e4:	20000a04 	.word	0x20000a04
	...

080032f0 <Vector138>:
/**
 * @brief   EXTI[19] interrupt handler (ETH_WKUP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector138) {
 80032f0:	b500      	push	{lr}
 80032f2:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 80032f4:	4b0e      	ldr	r3, [pc, #56]	; (8003330 <Vector138+0x40>)
 80032f6:	695b      	ldr	r3, [r3, #20]
 80032f8:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & (1U << 19);
 80032fa:	4b0d      	ldr	r3, [pc, #52]	; (8003330 <Vector138+0x40>)
 80032fc:	681b      	ldr	r3, [r3, #0]
 80032fe:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8003302:	9a01      	ldr	r2, [sp, #4]
 8003304:	4013      	ands	r3, r2
 8003306:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8003308:	4a09      	ldr	r2, [pc, #36]	; (8003330 <Vector138+0x40>)
 800330a:	9b01      	ldr	r3, [sp, #4]
 800330c:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 19))
 800330e:	9b01      	ldr	r3, [sp, #4]
 8003310:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8003314:	2b00      	cmp	r3, #0
 8003316:	d006      	beq.n	8003326 <Vector138+0x36>
    EXTD1.config->channels[19].cb(&EXTD1, 19);
 8003318:	4b06      	ldr	r3, [pc, #24]	; (8003334 <Vector138+0x44>)
 800331a:	685b      	ldr	r3, [r3, #4]
 800331c:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8003320:	4804      	ldr	r0, [pc, #16]	; (8003334 <Vector138+0x44>)
 8003322:	2113      	movs	r1, #19
 8003324:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003326:	f001 fc73 	bl	8004c10 <_port_irq_epilogue>
}
 800332a:	b003      	add	sp, #12
 800332c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003330:	40013c00 	.word	0x40013c00
 8003334:	20000a04 	.word	0x20000a04
	...

08003340 <Vector170>:
/**
 * @brief   EXTI[20] interrupt handler (OTG_HS_WKUP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector170) {
 8003340:	b500      	push	{lr}
 8003342:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8003344:	4b0e      	ldr	r3, [pc, #56]	; (8003380 <Vector170+0x40>)
 8003346:	695b      	ldr	r3, [r3, #20]
 8003348:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & (1U << 20);
 800334a:	4b0d      	ldr	r3, [pc, #52]	; (8003380 <Vector170+0x40>)
 800334c:	681b      	ldr	r3, [r3, #0]
 800334e:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8003352:	9a01      	ldr	r2, [sp, #4]
 8003354:	4013      	ands	r3, r2
 8003356:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8003358:	4a09      	ldr	r2, [pc, #36]	; (8003380 <Vector170+0x40>)
 800335a:	9b01      	ldr	r3, [sp, #4]
 800335c:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 20))
 800335e:	9b01      	ldr	r3, [sp, #4]
 8003360:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8003364:	2b00      	cmp	r3, #0
 8003366:	d006      	beq.n	8003376 <Vector170+0x36>
    EXTD1.config->channels[20].cb(&EXTD1, 20);
 8003368:	4b06      	ldr	r3, [pc, #24]	; (8003384 <Vector170+0x44>)
 800336a:	685b      	ldr	r3, [r3, #4]
 800336c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 8003370:	4804      	ldr	r0, [pc, #16]	; (8003384 <Vector170+0x44>)
 8003372:	2114      	movs	r1, #20
 8003374:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003376:	f001 fc4b 	bl	8004c10 <_port_irq_epilogue>
}
 800337a:	b003      	add	sp, #12
 800337c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003380:	40013c00 	.word	0x40013c00
 8003384:	20000a04 	.word	0x20000a04
	...

08003390 <Vector48>:
/**
 * @brief   EXTI[21] interrupt handler (TAMPER_STAMP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector48) {
 8003390:	b500      	push	{lr}
 8003392:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8003394:	4b0e      	ldr	r3, [pc, #56]	; (80033d0 <Vector48+0x40>)
 8003396:	695b      	ldr	r3, [r3, #20]
 8003398:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & (1U << 21);
 800339a:	4b0d      	ldr	r3, [pc, #52]	; (80033d0 <Vector48+0x40>)
 800339c:	681b      	ldr	r3, [r3, #0]
 800339e:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80033a2:	9a01      	ldr	r2, [sp, #4]
 80033a4:	4013      	ands	r3, r2
 80033a6:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 80033a8:	4a09      	ldr	r2, [pc, #36]	; (80033d0 <Vector48+0x40>)
 80033aa:	9b01      	ldr	r3, [sp, #4]
 80033ac:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 21))
 80033ae:	9b01      	ldr	r3, [sp, #4]
 80033b0:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80033b4:	2b00      	cmp	r3, #0
 80033b6:	d006      	beq.n	80033c6 <Vector48+0x36>
    EXTD1.config->channels[21].cb(&EXTD1, 21);
 80033b8:	4b06      	ldr	r3, [pc, #24]	; (80033d4 <Vector48+0x44>)
 80033ba:	685b      	ldr	r3, [r3, #4]
 80033bc:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 80033c0:	4804      	ldr	r0, [pc, #16]	; (80033d4 <Vector48+0x44>)
 80033c2:	2115      	movs	r1, #21
 80033c4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80033c6:	f001 fc23 	bl	8004c10 <_port_irq_epilogue>
}
 80033ca:	b003      	add	sp, #12
 80033cc:	f85d fb04 	ldr.w	pc, [sp], #4
 80033d0:	40013c00 	.word	0x40013c00
 80033d4:	20000a04 	.word	0x20000a04
	...

080033e0 <Vector4C>:
/**
 * @brief   EXTI[22] interrupt handler (RTC_WKUP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector4C) {
 80033e0:	b500      	push	{lr}
 80033e2:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 80033e4:	4b0e      	ldr	r3, [pc, #56]	; (8003420 <Vector4C+0x40>)
 80033e6:	695b      	ldr	r3, [r3, #20]
 80033e8:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & (1U << 22);
 80033ea:	4b0d      	ldr	r3, [pc, #52]	; (8003420 <Vector4C+0x40>)
 80033ec:	681b      	ldr	r3, [r3, #0]
 80033ee:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80033f2:	9a01      	ldr	r2, [sp, #4]
 80033f4:	4013      	ands	r3, r2
 80033f6:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 80033f8:	4a09      	ldr	r2, [pc, #36]	; (8003420 <Vector4C+0x40>)
 80033fa:	9b01      	ldr	r3, [sp, #4]
 80033fc:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 22))
 80033fe:	9b01      	ldr	r3, [sp, #4]
 8003400:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8003404:	2b00      	cmp	r3, #0
 8003406:	d006      	beq.n	8003416 <Vector4C+0x36>
    EXTD1.config->channels[22].cb(&EXTD1, 22);
 8003408:	4b06      	ldr	r3, [pc, #24]	; (8003424 <Vector4C+0x44>)
 800340a:	685b      	ldr	r3, [r3, #4]
 800340c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8003410:	4804      	ldr	r0, [pc, #16]	; (8003424 <Vector4C+0x44>)
 8003412:	2116      	movs	r1, #22
 8003414:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003416:	f001 fbfb 	bl	8004c10 <_port_irq_epilogue>
}
 800341a:	b003      	add	sp, #12
 800341c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003420:	40013c00 	.word	0x40013c00
 8003424:	20000a04 	.word	0x20000a04
	...

08003430 <ext_lld_exti_irq_enable>:
/**
 * @brief   Enables EXTI IRQ sources.
 *
 * @notapi
 */
void ext_lld_exti_irq_enable(void) {
 8003430:	b508      	push	{r3, lr}

  nvicEnableVector(EXTI0_IRQn, STM32_EXT_EXTI0_IRQ_PRIORITY);
 8003432:	2006      	movs	r0, #6
 8003434:	2106      	movs	r1, #6
 8003436:	f001 f9e3 	bl	8004800 <nvicEnableVector>
  nvicEnableVector(EXTI1_IRQn, STM32_EXT_EXTI1_IRQ_PRIORITY);
 800343a:	2007      	movs	r0, #7
 800343c:	2106      	movs	r1, #6
 800343e:	f001 f9df 	bl	8004800 <nvicEnableVector>
  nvicEnableVector(EXTI2_IRQn, STM32_EXT_EXTI2_IRQ_PRIORITY);
 8003442:	2008      	movs	r0, #8
 8003444:	2106      	movs	r1, #6
 8003446:	f001 f9db 	bl	8004800 <nvicEnableVector>
  nvicEnableVector(EXTI3_IRQn, STM32_EXT_EXTI3_IRQ_PRIORITY);
 800344a:	2009      	movs	r0, #9
 800344c:	2106      	movs	r1, #6
 800344e:	f001 f9d7 	bl	8004800 <nvicEnableVector>
  nvicEnableVector(EXTI4_IRQn, STM32_EXT_EXTI4_IRQ_PRIORITY);
 8003452:	200a      	movs	r0, #10
 8003454:	2106      	movs	r1, #6
 8003456:	f001 f9d3 	bl	8004800 <nvicEnableVector>
  nvicEnableVector(EXTI9_5_IRQn, STM32_EXT_EXTI5_9_IRQ_PRIORITY);
 800345a:	2017      	movs	r0, #23
 800345c:	2106      	movs	r1, #6
 800345e:	f001 f9cf 	bl	8004800 <nvicEnableVector>
  nvicEnableVector(EXTI15_10_IRQn, STM32_EXT_EXTI10_15_IRQ_PRIORITY);
 8003462:	2028      	movs	r0, #40	; 0x28
 8003464:	2106      	movs	r1, #6
 8003466:	f001 f9cb 	bl	8004800 <nvicEnableVector>
  nvicEnableVector(PVD_IRQn, STM32_EXT_EXTI16_IRQ_PRIORITY);
 800346a:	2001      	movs	r0, #1
 800346c:	2106      	movs	r1, #6
 800346e:	f001 f9c7 	bl	8004800 <nvicEnableVector>
  nvicEnableVector(RTC_Alarm_IRQn, STM32_EXT_EXTI17_IRQ_PRIORITY);
 8003472:	2029      	movs	r0, #41	; 0x29
 8003474:	210f      	movs	r1, #15
 8003476:	f001 f9c3 	bl	8004800 <nvicEnableVector>
  nvicEnableVector(OTG_FS_WKUP_IRQn, STM32_EXT_EXTI18_IRQ_PRIORITY);
 800347a:	202a      	movs	r0, #42	; 0x2a
 800347c:	2106      	movs	r1, #6
 800347e:	f001 f9bf 	bl	8004800 <nvicEnableVector>
#if STM32_HAS_ETH
  nvicEnableVector(ETH_WKUP_IRQn, STM32_EXT_EXTI19_IRQ_PRIORITY);
 8003482:	203e      	movs	r0, #62	; 0x3e
 8003484:	2106      	movs	r1, #6
 8003486:	f001 f9bb 	bl	8004800 <nvicEnableVector>
#endif
#if STM32_HAS_OTG2
  nvicEnableVector(OTG_HS_WKUP_IRQn, STM32_EXT_EXTI20_IRQ_PRIORITY);
 800348a:	204c      	movs	r0, #76	; 0x4c
 800348c:	2106      	movs	r1, #6
 800348e:	f001 f9b7 	bl	8004800 <nvicEnableVector>
#endif
#if !defined(STM32F401xx)
  nvicEnableVector(TAMP_STAMP_IRQn, STM32_EXT_EXTI21_IRQ_PRIORITY);
 8003492:	2002      	movs	r0, #2
 8003494:	210f      	movs	r1, #15
 8003496:	f001 f9b3 	bl	8004800 <nvicEnableVector>
#endif /* !defined(STM32F401xx) */
  nvicEnableVector(RTC_WKUP_IRQn, STM32_EXT_EXTI22_IRQ_PRIORITY);
 800349a:	2003      	movs	r0, #3
 800349c:	210f      	movs	r1, #15
 800349e:	f001 f9af 	bl	8004800 <nvicEnableVector>
}
 80034a2:	bd08      	pop	{r3, pc}
	...

080034b0 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 80034b0:	b082      	sub	sp, #8
 80034b2:	9001      	str	r0, [sp, #4]
 80034b4:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 80034b6:	9b00      	ldr	r3, [sp, #0]
 80034b8:	685a      	ldr	r2, [r3, #4]
 80034ba:	9b01      	ldr	r3, [sp, #4]
 80034bc:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80034be:	9b00      	ldr	r3, [sp, #0]
 80034c0:	689a      	ldr	r2, [r3, #8]
 80034c2:	9b01      	ldr	r3, [sp, #4]
 80034c4:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 80034c6:	9b00      	ldr	r3, [sp, #0]
 80034c8:	68da      	ldr	r2, [r3, #12]
 80034ca:	9b01      	ldr	r3, [sp, #4]
 80034cc:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 80034ce:	9b00      	ldr	r3, [sp, #0]
 80034d0:	691a      	ldr	r2, [r3, #16]
 80034d2:	9b01      	ldr	r3, [sp, #4]
 80034d4:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 80034d6:	9b00      	ldr	r3, [sp, #0]
 80034d8:	695a      	ldr	r2, [r3, #20]
 80034da:	9b01      	ldr	r3, [sp, #4]
 80034dc:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 80034de:	9b00      	ldr	r3, [sp, #0]
 80034e0:	699a      	ldr	r2, [r3, #24]
 80034e2:	9b01      	ldr	r3, [sp, #4]
 80034e4:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80034e6:	9b00      	ldr	r3, [sp, #0]
 80034e8:	681a      	ldr	r2, [r3, #0]
 80034ea:	9b01      	ldr	r3, [sp, #4]
 80034ec:	601a      	str	r2, [r3, #0]
}
 80034ee:	b002      	add	sp, #8
 80034f0:	4770      	bx	lr
 80034f2:	bf00      	nop
	...

08003500 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8003500:	b500      	push	{lr}
 8003502:	b083      	sub	sp, #12
 8003504:	9001      	str	r0, [sp, #4]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8003506:	4a24      	ldr	r2, [pc, #144]	; (8003598 <_pal_lld_init+0x98>)
 8003508:	4b23      	ldr	r3, [pc, #140]	; (8003598 <_pal_lld_init+0x98>)
 800350a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800350c:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8003510:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8003514:	6313      	str	r3, [r2, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 8003516:	4a20      	ldr	r2, [pc, #128]	; (8003598 <_pal_lld_init+0x98>)
 8003518:	4b1f      	ldr	r3, [pc, #124]	; (8003598 <_pal_lld_init+0x98>)
 800351a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800351c:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8003520:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8003524:	6513      	str	r3, [r2, #80]	; 0x50

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 8003526:	9b01      	ldr	r3, [sp, #4]
 8003528:	481c      	ldr	r0, [pc, #112]	; (800359c <_pal_lld_init+0x9c>)
 800352a:	4619      	mov	r1, r3
 800352c:	f7ff ffc0 	bl	80034b0 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 8003530:	9b01      	ldr	r3, [sp, #4]
 8003532:	331c      	adds	r3, #28
 8003534:	481a      	ldr	r0, [pc, #104]	; (80035a0 <_pal_lld_init+0xa0>)
 8003536:	4619      	mov	r1, r3
 8003538:	f7ff ffba 	bl	80034b0 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 800353c:	9b01      	ldr	r3, [sp, #4]
 800353e:	3338      	adds	r3, #56	; 0x38
 8003540:	4818      	ldr	r0, [pc, #96]	; (80035a4 <_pal_lld_init+0xa4>)
 8003542:	4619      	mov	r1, r3
 8003544:	f7ff ffb4 	bl	80034b0 <initgpio>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
 8003548:	9b01      	ldr	r3, [sp, #4]
 800354a:	3354      	adds	r3, #84	; 0x54
 800354c:	4816      	ldr	r0, [pc, #88]	; (80035a8 <_pal_lld_init+0xa8>)
 800354e:	4619      	mov	r1, r3
 8003550:	f7ff ffae 	bl	80034b0 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
 8003554:	9b01      	ldr	r3, [sp, #4]
 8003556:	3370      	adds	r3, #112	; 0x70
 8003558:	4814      	ldr	r0, [pc, #80]	; (80035ac <_pal_lld_init+0xac>)
 800355a:	4619      	mov	r1, r3
 800355c:	f7ff ffa8 	bl	80034b0 <initgpio>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 8003560:	9b01      	ldr	r3, [sp, #4]
 8003562:	338c      	adds	r3, #140	; 0x8c
 8003564:	4812      	ldr	r0, [pc, #72]	; (80035b0 <_pal_lld_init+0xb0>)
 8003566:	4619      	mov	r1, r3
 8003568:	f7ff ffa2 	bl	80034b0 <initgpio>
#endif
#if STM32_HAS_GPIOG
  initgpio(GPIOG, &config->PGData);
 800356c:	9b01      	ldr	r3, [sp, #4]
 800356e:	33a8      	adds	r3, #168	; 0xa8
 8003570:	4810      	ldr	r0, [pc, #64]	; (80035b4 <_pal_lld_init+0xb4>)
 8003572:	4619      	mov	r1, r3
 8003574:	f7ff ff9c 	bl	80034b0 <initgpio>
#endif
#if STM32_HAS_GPIOH
  initgpio(GPIOH, &config->PHData);
 8003578:	9b01      	ldr	r3, [sp, #4]
 800357a:	33c4      	adds	r3, #196	; 0xc4
 800357c:	480e      	ldr	r0, [pc, #56]	; (80035b8 <_pal_lld_init+0xb8>)
 800357e:	4619      	mov	r1, r3
 8003580:	f7ff ff96 	bl	80034b0 <initgpio>
#endif
#if STM32_HAS_GPIOI
  initgpio(GPIOI, &config->PIData);
 8003584:	9b01      	ldr	r3, [sp, #4]
 8003586:	33e0      	adds	r3, #224	; 0xe0
 8003588:	480c      	ldr	r0, [pc, #48]	; (80035bc <_pal_lld_init+0xbc>)
 800358a:	4619      	mov	r1, r3
 800358c:	f7ff ff90 	bl	80034b0 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 8003590:	b003      	add	sp, #12
 8003592:	f85d fb04 	ldr.w	pc, [sp], #4
 8003596:	bf00      	nop
 8003598:	40023800 	.word	0x40023800
 800359c:	40020000 	.word	0x40020000
 80035a0:	40020400 	.word	0x40020400
 80035a4:	40020800 	.word	0x40020800
 80035a8:	40020c00 	.word	0x40020c00
 80035ac:	40021000 	.word	0x40021000
 80035b0:	40021400 	.word	0x40021400
 80035b4:	40021800 	.word	0x40021800
 80035b8:	40021c00 	.word	0x40021c00
 80035bc:	40022000 	.word	0x40022000

080035c0 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 80035c0:	b08e      	sub	sp, #56	; 0x38
 80035c2:	9003      	str	r0, [sp, #12]
 80035c4:	9102      	str	r1, [sp, #8]
 80035c6:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80035c8:	9b01      	ldr	r3, [sp, #4]
 80035ca:	f003 0303 	and.w	r3, r3, #3
 80035ce:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 80035d0:	9b01      	ldr	r3, [sp, #4]
 80035d2:	f003 0304 	and.w	r3, r3, #4
 80035d6:	089b      	lsrs	r3, r3, #2
 80035d8:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 80035da:	9b01      	ldr	r3, [sp, #4]
 80035dc:	f003 0318 	and.w	r3, r3, #24
 80035e0:	08db      	lsrs	r3, r3, #3
 80035e2:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 80035e4:	9b01      	ldr	r3, [sp, #4]
 80035e6:	f003 0360 	and.w	r3, r3, #96	; 0x60
 80035ea:	095b      	lsrs	r3, r3, #5
 80035ec:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 80035ee:	9b01      	ldr	r3, [sp, #4]
 80035f0:	f403 63f0 	and.w	r3, r3, #1920	; 0x780
 80035f4:	09db      	lsrs	r3, r3, #7
 80035f6:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 80035f8:	2300      	movs	r3, #0
 80035fa:	9309      	str	r3, [sp, #36]	; 0x24
  while (true) {
    if ((mask & 1) != 0) {
 80035fc:	9b02      	ldr	r3, [sp, #8]
 80035fe:	f003 0301 	and.w	r3, r3, #1
 8003602:	2b00      	cmp	r3, #0
 8003604:	d077      	beq.n	80036f6 <_pal_lld_setgroupmode+0x136>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8003606:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003608:	f003 0307 	and.w	r3, r3, #7
 800360c:	009b      	lsls	r3, r3, #2
 800360e:	461a      	mov	r2, r3
 8003610:	9b08      	ldr	r3, [sp, #32]
 8003612:	4093      	lsls	r3, r2
 8003614:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 8003616:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003618:	2201      	movs	r2, #1
 800361a:	fa02 f303 	lsl.w	r3, r2, r3
 800361e:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 8003620:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003622:	005b      	lsls	r3, r3, #1
 8003624:	461a      	mov	r2, r3
 8003626:	2303      	movs	r3, #3
 8003628:	4093      	lsls	r3, r2
 800362a:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 800362c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800362e:	f003 0307 	and.w	r3, r3, #7
 8003632:	009b      	lsls	r3, r3, #2
 8003634:	461a      	mov	r2, r3
 8003636:	230f      	movs	r3, #15
 8003638:	4093      	lsls	r3, r2
 800363a:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800363c:	9b03      	ldr	r3, [sp, #12]
 800363e:	685a      	ldr	r2, [r3, #4]
 8003640:	9b06      	ldr	r3, [sp, #24]
 8003642:	43db      	mvns	r3, r3
 8003644:	401a      	ands	r2, r3
 8003646:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8003648:	431a      	orrs	r2, r3
 800364a:	9b03      	ldr	r3, [sp, #12]
 800364c:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800364e:	9b03      	ldr	r3, [sp, #12]
 8003650:	689a      	ldr	r2, [r3, #8]
 8003652:	9b05      	ldr	r3, [sp, #20]
 8003654:	43db      	mvns	r3, r3
 8003656:	401a      	ands	r2, r3
 8003658:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800365a:	431a      	orrs	r2, r3
 800365c:	9b03      	ldr	r3, [sp, #12]
 800365e:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8003660:	9b03      	ldr	r3, [sp, #12]
 8003662:	68da      	ldr	r2, [r3, #12]
 8003664:	9b05      	ldr	r3, [sp, #20]
 8003666:	43db      	mvns	r3, r3
 8003668:	401a      	ands	r2, r3
 800366a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800366c:	431a      	orrs	r2, r3
 800366e:	9b03      	ldr	r3, [sp, #12]
 8003670:	60da      	str	r2, [r3, #12]
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 8003672:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003674:	2b02      	cmp	r3, #2
 8003676:	d11f      	bne.n	80036b8 <_pal_lld_setgroupmode+0xf8>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8003678:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800367a:	2b07      	cmp	r3, #7
 800367c:	d809      	bhi.n	8003692 <_pal_lld_setgroupmode+0xd2>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800367e:	9b03      	ldr	r3, [sp, #12]
 8003680:	6a1a      	ldr	r2, [r3, #32]
 8003682:	9b04      	ldr	r3, [sp, #16]
 8003684:	43db      	mvns	r3, r3
 8003686:	401a      	ands	r2, r3
 8003688:	9b07      	ldr	r3, [sp, #28]
 800368a:	431a      	orrs	r2, r3
 800368c:	9b03      	ldr	r3, [sp, #12]
 800368e:	621a      	str	r2, [r3, #32]
 8003690:	e008      	b.n	80036a4 <_pal_lld_setgroupmode+0xe4>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8003692:	9b03      	ldr	r3, [sp, #12]
 8003694:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003696:	9b04      	ldr	r3, [sp, #16]
 8003698:	43db      	mvns	r3, r3
 800369a:	401a      	ands	r2, r3
 800369c:	9b07      	ldr	r3, [sp, #28]
 800369e:	431a      	orrs	r2, r3
 80036a0:	9b03      	ldr	r3, [sp, #12]
 80036a2:	625a      	str	r2, [r3, #36]	; 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 80036a4:	9b03      	ldr	r3, [sp, #12]
 80036a6:	681a      	ldr	r2, [r3, #0]
 80036a8:	9b05      	ldr	r3, [sp, #20]
 80036aa:	43db      	mvns	r3, r3
 80036ac:	401a      	ands	r2, r3
 80036ae:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80036b0:	431a      	orrs	r2, r3
 80036b2:	9b03      	ldr	r3, [sp, #12]
 80036b4:	601a      	str	r2, [r3, #0]
 80036b6:	e01e      	b.n	80036f6 <_pal_lld_setgroupmode+0x136>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 80036b8:	9b03      	ldr	r3, [sp, #12]
 80036ba:	681a      	ldr	r2, [r3, #0]
 80036bc:	9b05      	ldr	r3, [sp, #20]
 80036be:	43db      	mvns	r3, r3
 80036c0:	401a      	ands	r2, r3
 80036c2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80036c4:	431a      	orrs	r2, r3
 80036c6:	9b03      	ldr	r3, [sp, #12]
 80036c8:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 80036ca:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80036cc:	2b07      	cmp	r3, #7
 80036ce:	d809      	bhi.n	80036e4 <_pal_lld_setgroupmode+0x124>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80036d0:	9b03      	ldr	r3, [sp, #12]
 80036d2:	6a1a      	ldr	r2, [r3, #32]
 80036d4:	9b04      	ldr	r3, [sp, #16]
 80036d6:	43db      	mvns	r3, r3
 80036d8:	401a      	ands	r2, r3
 80036da:	9b07      	ldr	r3, [sp, #28]
 80036dc:	431a      	orrs	r2, r3
 80036de:	9b03      	ldr	r3, [sp, #12]
 80036e0:	621a      	str	r2, [r3, #32]
 80036e2:	e008      	b.n	80036f6 <_pal_lld_setgroupmode+0x136>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80036e4:	9b03      	ldr	r3, [sp, #12]
 80036e6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80036e8:	9b04      	ldr	r3, [sp, #16]
 80036ea:	43db      	mvns	r3, r3
 80036ec:	401a      	ands	r2, r3
 80036ee:	9b07      	ldr	r3, [sp, #28]
 80036f0:	431a      	orrs	r2, r3
 80036f2:	9b03      	ldr	r3, [sp, #12]
 80036f4:	625a      	str	r2, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
 80036f6:	9b02      	ldr	r3, [sp, #8]
 80036f8:	085b      	lsrs	r3, r3, #1
 80036fa:	9302      	str	r3, [sp, #8]
    if (!mask)
 80036fc:	9b02      	ldr	r3, [sp, #8]
 80036fe:	2b00      	cmp	r3, #0
 8003700:	d00f      	beq.n	8003722 <_pal_lld_setgroupmode+0x162>
      return;
    otyper <<= 1;
 8003702:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8003704:	005b      	lsls	r3, r3, #1
 8003706:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
 8003708:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800370a:	009b      	lsls	r3, r3, #2
 800370c:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
 800370e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8003710:	009b      	lsls	r3, r3, #2
 8003712:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
 8003714:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003716:	009b      	lsls	r3, r3, #2
 8003718:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
 800371a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800371c:	3301      	adds	r3, #1
 800371e:	9309      	str	r3, [sp, #36]	; 0x24
 8003720:	e76c      	b.n	80035fc <_pal_lld_setgroupmode+0x3c>
  }
}
 8003722:	b00e      	add	sp, #56	; 0x38
 8003724:	4770      	bx	lr
 8003726:	bf00      	nop
	...

08003730 <port_lock.lto_priv.187>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003730:	b082      	sub	sp, #8
 8003732:	2320      	movs	r3, #32
 8003734:	9301      	str	r3, [sp, #4]
 8003736:	9b01      	ldr	r3, [sp, #4]
 8003738:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800373c:	b002      	add	sp, #8
 800373e:	4770      	bx	lr

08003740 <port_unlock.lto_priv.185>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003740:	b082      	sub	sp, #8
 8003742:	2300      	movs	r3, #0
 8003744:	9301      	str	r3, [sp, #4]
 8003746:	9b01      	ldr	r3, [sp, #4]
 8003748:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800374c:	b002      	add	sp, #8
 800374e:	4770      	bx	lr

08003750 <port_lock_from_isr.lto_priv.183>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8003750:	b508      	push	{r3, lr}

  port_lock();
 8003752:	f7ff ffed 	bl	8003730 <port_lock.lto_priv.187>
}
 8003756:	bd08      	pop	{r3, pc}
	...

08003760 <port_unlock_from_isr.lto_priv.181>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8003760:	b508      	push	{r3, lr}

  port_unlock();
 8003762:	f7ff ffed 	bl	8003740 <port_unlock.lto_priv.185>
}
 8003766:	bd08      	pop	{r3, pc}
	...

08003770 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003770:	b508      	push	{r3, lr}

  port_lock();
 8003772:	f7ff ffdd 	bl	8003730 <port_lock.lto_priv.187>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8003776:	bd08      	pop	{r3, pc}
	...

08003780 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003780:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8003782:	f7ff ffdd 	bl	8003740 <port_unlock.lto_priv.185>
}
 8003786:	bd08      	pop	{r3, pc}
	...

08003790 <chSysLockFromISR.lto_priv.179>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8003790:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8003792:	f7ff ffdd 	bl	8003750 <port_lock_from_isr.lto_priv.183>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8003796:	bd08      	pop	{r3, pc}
	...

080037a0 <chSysUnlockFromISR.lto_priv.177>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80037a0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80037a2:	f7ff ffdd 	bl	8003760 <port_unlock_from_isr.lto_priv.181>
}
 80037a6:	bd08      	pop	{r3, pc}
	...

080037b0 <chThdStartI.lto_priv.169>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
static inline thread_t *chThdStartI(thread_t *tp) {
 80037b0:	b500      	push	{lr}
 80037b2:	b083      	sub	sp, #12
 80037b4:	9001      	str	r0, [sp, #4]

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 80037b6:	9801      	ldr	r0, [sp, #4]
 80037b8:	f002 f92a 	bl	8005a10 <chSchReadyI>
 80037bc:	4603      	mov	r3, r0
}
 80037be:	4618      	mov	r0, r3
 80037c0:	b003      	add	sp, #12
 80037c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80037c6:	bf00      	nop
	...

080037d0 <chRegSetThreadName.lto_priv.159>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 80037d0:	b082      	sub	sp, #8
 80037d2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 80037d4:	4b02      	ldr	r3, [pc, #8]	; (80037e0 <chRegSetThreadName.lto_priv.159+0x10>)
 80037d6:	699b      	ldr	r3, [r3, #24]
 80037d8:	9a01      	ldr	r2, [sp, #4]
 80037da:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 80037dc:	b002      	add	sp, #8
 80037de:	4770      	bx	lr
 80037e0:	20000808 	.word	0x20000808
	...

080037f0 <osalSysLock.lto_priv.154>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 80037f0:	b508      	push	{r3, lr}

  chSysLock();
 80037f2:	f7ff ffbd 	bl	8003770 <chSysLock>
}
 80037f6:	bd08      	pop	{r3, pc}
	...

08003800 <osalSysUnlock.lto_priv.155>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8003800:	b508      	push	{r3, lr}

  chSysUnlock();
 8003802:	f7ff ffbd 	bl	8003780 <chSysUnlock>
}
 8003806:	bd08      	pop	{r3, pc}
	...

08003810 <osalSysLockFromISR.lto_priv.173>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8003810:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8003812:	f7ff ffbd 	bl	8003790 <chSysLockFromISR.lto_priv.179>
}
 8003816:	bd08      	pop	{r3, pc}
	...

08003820 <osalSysUnlockFromISR.lto_priv.171>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8003820:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8003822:	f7ff ffbd 	bl	80037a0 <chSysUnlockFromISR.lto_priv.177>
}
 8003826:	bd08      	pop	{r3, pc}
	...

08003830 <osalSysPolledDelayX>:
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {
 8003830:	b500      	push	{lr}
 8003832:	b083      	sub	sp, #12
 8003834:	9001      	str	r0, [sp, #4]

  chSysPolledDelayX(cycles);
 8003836:	9801      	ldr	r0, [sp, #4]
 8003838:	f001 feea 	bl	8005610 <chSysPolledDelayX>
}
 800383c:	b003      	add	sp, #12
 800383e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003842:	bf00      	nop
	...

08003850 <osalThreadSuspendS.lto_priv.158>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8003850:	b500      	push	{lr}
 8003852:	b083      	sub	sp, #12
 8003854:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 8003856:	9801      	ldr	r0, [sp, #4]
 8003858:	f002 fbda 	bl	8006010 <chThdSuspendS>
 800385c:	4603      	mov	r3, r0
}
 800385e:	4618      	mov	r0, r3
 8003860:	b003      	add	sp, #12
 8003862:	f85d fb04 	ldr.w	pc, [sp], #4
 8003866:	bf00      	nop
	...

08003870 <osalThreadResumeI.lto_priv.172>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8003870:	b500      	push	{lr}
 8003872:	b083      	sub	sp, #12
 8003874:	9001      	str	r0, [sp, #4]
 8003876:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 8003878:	9801      	ldr	r0, [sp, #4]
 800387a:	9900      	ldr	r1, [sp, #0]
 800387c:	f002 fbe0 	bl	8006040 <chThdResumeI>
}
 8003880:	b003      	add	sp, #12
 8003882:	f85d fb04 	ldr.w	pc, [sp], #4
 8003886:	bf00      	nop
	...

08003890 <otg_core_reset.lto_priv.170>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void otg_core_reset(USBDriver *usbp) {
 8003890:	b500      	push	{lr}
 8003892:	b085      	sub	sp, #20
 8003894:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8003896:	9b01      	ldr	r3, [sp, #4]
 8003898:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800389a:	9303      	str	r3, [sp, #12]

  osalSysPolledDelayX(32);
 800389c:	2020      	movs	r0, #32
 800389e:	f7ff ffc7 	bl	8003830 <osalSysPolledDelayX>

  /* Core reset and delay of at least 3 PHY cycles.*/
  otgp->GRSTCTL = GRSTCTL_CSRST;
 80038a2:	9b03      	ldr	r3, [sp, #12]
 80038a4:	2201      	movs	r2, #1
 80038a6:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 80038a8:	9b03      	ldr	r3, [sp, #12]
 80038aa:	691b      	ldr	r3, [r3, #16]
 80038ac:	f003 0301 	and.w	r3, r3, #1
 80038b0:	2b00      	cmp	r3, #0
 80038b2:	d1f9      	bne.n	80038a8 <otg_core_reset.lto_priv.170+0x18>
    ;

  osalSysPolledDelayX(18);
 80038b4:	2012      	movs	r0, #18
 80038b6:	f7ff ffbb 	bl	8003830 <osalSysPolledDelayX>

  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 80038ba:	9b03      	ldr	r3, [sp, #12]
 80038bc:	691b      	ldr	r3, [r3, #16]
 80038be:	2b00      	cmp	r3, #0
 80038c0:	dafb      	bge.n	80038ba <otg_core_reset.lto_priv.170+0x2a>
    ;
}
 80038c2:	b005      	add	sp, #20
 80038c4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080038d0 <otg_disable_ep.lto_priv.164>:

static void otg_disable_ep(USBDriver *usbp) {
 80038d0:	b084      	sub	sp, #16
 80038d2:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 80038d4:	9b01      	ldr	r3, [sp, #4]
 80038d6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80038d8:	9302      	str	r3, [sp, #8]
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80038da:	2300      	movs	r3, #0
 80038dc:	9303      	str	r3, [sp, #12]
 80038de:	e032      	b.n	8003946 <otg_disable_ep.lto_priv.164+0x76>
    otgp->ie[i].DIEPCTL = 0;
 80038e0:	9a02      	ldr	r2, [sp, #8]
 80038e2:	9b03      	ldr	r3, [sp, #12]
 80038e4:	3348      	adds	r3, #72	; 0x48
 80038e6:	015b      	lsls	r3, r3, #5
 80038e8:	4413      	add	r3, r2
 80038ea:	2200      	movs	r2, #0
 80038ec:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPTSIZ = 0;
 80038ee:	9a02      	ldr	r2, [sp, #8]
 80038f0:	9b03      	ldr	r3, [sp, #12]
 80038f2:	015b      	lsls	r3, r3, #5
 80038f4:	4413      	add	r3, r2
 80038f6:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 80038fa:	2200      	movs	r2, #0
 80038fc:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80038fe:	9a02      	ldr	r2, [sp, #8]
 8003900:	9b03      	ldr	r3, [sp, #12]
 8003902:	015b      	lsls	r3, r3, #5
 8003904:	4413      	add	r3, r2
 8003906:	f603 1308 	addw	r3, r3, #2312	; 0x908
 800390a:	f04f 32ff 	mov.w	r2, #4294967295
 800390e:	601a      	str	r2, [r3, #0]

    otgp->oe[i].DOEPCTL = 0;
 8003910:	9a02      	ldr	r2, [sp, #8]
 8003912:	9b03      	ldr	r3, [sp, #12]
 8003914:	3358      	adds	r3, #88	; 0x58
 8003916:	015b      	lsls	r3, r3, #5
 8003918:	4413      	add	r3, r2
 800391a:	2200      	movs	r2, #0
 800391c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPTSIZ = 0;
 800391e:	9a02      	ldr	r2, [sp, #8]
 8003920:	9b03      	ldr	r3, [sp, #12]
 8003922:	015b      	lsls	r3, r3, #5
 8003924:	4413      	add	r3, r2
 8003926:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 800392a:	2200      	movs	r2, #0
 800392c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800392e:	9a02      	ldr	r2, [sp, #8]
 8003930:	9b03      	ldr	r3, [sp, #12]
 8003932:	015b      	lsls	r3, r3, #5
 8003934:	4413      	add	r3, r2
 8003936:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 800393a:	f04f 32ff 	mov.w	r2, #4294967295
 800393e:	601a      	str	r2, [r3, #0]

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8003940:	9b03      	ldr	r3, [sp, #12]
 8003942:	3301      	adds	r3, #1
 8003944:	9303      	str	r3, [sp, #12]
 8003946:	9b01      	ldr	r3, [sp, #4]
 8003948:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800394a:	689a      	ldr	r2, [r3, #8]
 800394c:	9b03      	ldr	r3, [sp, #12]
 800394e:	429a      	cmp	r2, r3
 8003950:	d2c6      	bcs.n	80038e0 <otg_disable_ep.lto_priv.164+0x10>

    otgp->oe[i].DOEPCTL = 0;
    otgp->oe[i].DOEPTSIZ = 0;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8003952:	9b02      	ldr	r3, [sp, #8]
 8003954:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8003958:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
}
 800395c:	b004      	add	sp, #16
 800395e:	4770      	bx	lr

08003960 <otg_rxfifo_flush.lto_priv.168>:

static void otg_rxfifo_flush(USBDriver *usbp) {
 8003960:	b500      	push	{lr}
 8003962:	b085      	sub	sp, #20
 8003964:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8003966:	9b01      	ldr	r3, [sp, #4]
 8003968:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800396a:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 800396c:	9b03      	ldr	r3, [sp, #12]
 800396e:	2210      	movs	r2, #16
 8003970:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 8003972:	9b03      	ldr	r3, [sp, #12]
 8003974:	691b      	ldr	r3, [r3, #16]
 8003976:	f003 0310 	and.w	r3, r3, #16
 800397a:	2b00      	cmp	r3, #0
 800397c:	d1f9      	bne.n	8003972 <otg_rxfifo_flush.lto_priv.168+0x12>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 800397e:	2012      	movs	r0, #18
 8003980:	f7ff ff56 	bl	8003830 <osalSysPolledDelayX>
}
 8003984:	b005      	add	sp, #20
 8003986:	f85d fb04 	ldr.w	pc, [sp], #4
 800398a:	bf00      	nop
 800398c:	0000      	movs	r0, r0
	...

08003990 <otg_txfifo_flush.lto_priv.166>:

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
 8003990:	b500      	push	{lr}
 8003992:	b085      	sub	sp, #20
 8003994:	9001      	str	r0, [sp, #4]
 8003996:	9100      	str	r1, [sp, #0]
  stm32_otg_t *otgp = usbp->otg;
 8003998:	9b01      	ldr	r3, [sp, #4]
 800399a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800399c:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800399e:	9b00      	ldr	r3, [sp, #0]
 80039a0:	019b      	lsls	r3, r3, #6
 80039a2:	f043 0220 	orr.w	r2, r3, #32
 80039a6:	9b03      	ldr	r3, [sp, #12]
 80039a8:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 80039aa:	9b03      	ldr	r3, [sp, #12]
 80039ac:	691b      	ldr	r3, [r3, #16]
 80039ae:	f003 0320 	and.w	r3, r3, #32
 80039b2:	2b00      	cmp	r3, #0
 80039b4:	d1f9      	bne.n	80039aa <otg_txfifo_flush.lto_priv.166+0x1a>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 80039b6:	2012      	movs	r0, #18
 80039b8:	f7ff ff3a 	bl	8003830 <osalSysPolledDelayX>
}
 80039bc:	b005      	add	sp, #20
 80039be:	f85d fb04 	ldr.w	pc, [sp], #4
 80039c2:	bf00      	nop
	...

080039d0 <otg_ram_reset.lto_priv.165>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {
 80039d0:	b082      	sub	sp, #8
 80039d2:	9001      	str	r0, [sp, #4]

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 80039d4:	9b01      	ldr	r3, [sp, #4]
 80039d6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80039d8:	681a      	ldr	r2, [r3, #0]
 80039da:	9b01      	ldr	r3, [sp, #4]
 80039dc:	659a      	str	r2, [r3, #88]	; 0x58
}
 80039de:	b002      	add	sp, #8
 80039e0:	4770      	bx	lr
 80039e2:	bf00      	nop
	...

080039f0 <otg_ram_alloc.lto_priv.167>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] size      size of the packet buffer to allocate in words
 *
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
 80039f0:	b084      	sub	sp, #16
 80039f2:	9001      	str	r0, [sp, #4]
 80039f4:	9100      	str	r1, [sp, #0]
  uint32_t next;

  next = usbp->pmnext;
 80039f6:	9b01      	ldr	r3, [sp, #4]
 80039f8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80039fa:	9303      	str	r3, [sp, #12]
  usbp->pmnext += size;
 80039fc:	9b01      	ldr	r3, [sp, #4]
 80039fe:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8003a00:	9b00      	ldr	r3, [sp, #0]
 8003a02:	441a      	add	r2, r3
 8003a04:	9b01      	ldr	r3, [sp, #4]
 8003a06:	659a      	str	r2, [r3, #88]	; 0x58
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
                "OTG FIFO memory overflow");
  return next;
 8003a08:	9b03      	ldr	r3, [sp, #12]
}
 8003a0a:	4618      	mov	r0, r3
 8003a0c:	b004      	add	sp, #16
 8003a0e:	4770      	bx	lr

08003a10 <otg_fifo_write_from_buffer.lto_priv.174>:
 *
 * @notapi
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {
 8003a10:	b084      	sub	sp, #16
 8003a12:	9003      	str	r0, [sp, #12]
 8003a14:	9102      	str	r1, [sp, #8]
 8003a16:	9201      	str	r2, [sp, #4]

  osalDbgAssert(n > 0, "is zero");

  while (true) {
    *fifop = *((uint32_t *)buf);
 8003a18:	9b02      	ldr	r3, [sp, #8]
 8003a1a:	681a      	ldr	r2, [r3, #0]
 8003a1c:	9b03      	ldr	r3, [sp, #12]
 8003a1e:	601a      	str	r2, [r3, #0]
    if (n <= 4) {
 8003a20:	9b01      	ldr	r3, [sp, #4]
 8003a22:	2b04      	cmp	r3, #4
 8003a24:	d906      	bls.n	8003a34 <otg_fifo_write_from_buffer.lto_priv.174+0x24>
      break;
    }
    n -= 4;
 8003a26:	9b01      	ldr	r3, [sp, #4]
 8003a28:	3b04      	subs	r3, #4
 8003a2a:	9301      	str	r3, [sp, #4]
    buf += 4;
 8003a2c:	9b02      	ldr	r3, [sp, #8]
 8003a2e:	3304      	adds	r3, #4
 8003a30:	9302      	str	r3, [sp, #8]
 8003a32:	e7f1      	b.n	8003a18 <otg_fifo_write_from_buffer.lto_priv.174+0x8>
  }
}
 8003a34:	b004      	add	sp, #16
 8003a36:	4770      	bx	lr
	...

08003a40 <otg_fifo_read_to_buffer.lto_priv.175>:
 * @notapi
 */
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {
 8003a40:	b086      	sub	sp, #24
 8003a42:	9003      	str	r0, [sp, #12]
 8003a44:	9102      	str	r1, [sp, #8]
 8003a46:	9201      	str	r2, [sp, #4]
 8003a48:	9300      	str	r3, [sp, #0]
  uint32_t w = 0;
 8003a4a:	2300      	movs	r3, #0
 8003a4c:	9305      	str	r3, [sp, #20]
  size_t i = 0;
 8003a4e:	2300      	movs	r3, #0
 8003a50:	9304      	str	r3, [sp, #16]
 8003a52:	e017      	b.n	8003a84 <otg_fifo_read_to_buffer.lto_priv.175+0x44>

  while (i < n) {
    if ((i & 3) == 0){
 8003a54:	9b04      	ldr	r3, [sp, #16]
 8003a56:	f003 0303 	and.w	r3, r3, #3
 8003a5a:	2b00      	cmp	r3, #0
 8003a5c:	d102      	bne.n	8003a64 <otg_fifo_read_to_buffer.lto_priv.175+0x24>
      w = *fifop;
 8003a5e:	9b03      	ldr	r3, [sp, #12]
 8003a60:	681b      	ldr	r3, [r3, #0]
 8003a62:	9305      	str	r3, [sp, #20]
    }
    if (i < max) {
 8003a64:	9a04      	ldr	r2, [sp, #16]
 8003a66:	9b00      	ldr	r3, [sp, #0]
 8003a68:	429a      	cmp	r2, r3
 8003a6a:	d208      	bcs.n	8003a7e <otg_fifo_read_to_buffer.lto_priv.175+0x3e>
      *buf++ = (uint8_t)w;
 8003a6c:	9b02      	ldr	r3, [sp, #8]
 8003a6e:	1c5a      	adds	r2, r3, #1
 8003a70:	9202      	str	r2, [sp, #8]
 8003a72:	9a05      	ldr	r2, [sp, #20]
 8003a74:	b2d2      	uxtb	r2, r2
 8003a76:	701a      	strb	r2, [r3, #0]
      w >>= 8;
 8003a78:	9b05      	ldr	r3, [sp, #20]
 8003a7a:	0a1b      	lsrs	r3, r3, #8
 8003a7c:	9305      	str	r3, [sp, #20]
    }
    i++;
 8003a7e:	9b04      	ldr	r3, [sp, #16]
 8003a80:	3301      	adds	r3, #1
 8003a82:	9304      	str	r3, [sp, #16]
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 8003a84:	9a04      	ldr	r2, [sp, #16]
 8003a86:	9b01      	ldr	r3, [sp, #4]
 8003a88:	429a      	cmp	r2, r3
 8003a8a:	d3e3      	bcc.n	8003a54 <otg_fifo_read_to_buffer.lto_priv.175+0x14>
      *buf++ = (uint8_t)w;
      w >>= 8;
    }
    i++;
  }
}
 8003a8c:	b006      	add	sp, #24
 8003a8e:	4770      	bx	lr

08003a90 <spiInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void spiInit(void) {
 8003a90:	b508      	push	{r3, lr}

  spi_lld_init();
 8003a92:	f7fd fa45 	bl	8000f20 <spi_lld_init>
}
 8003a96:	bd08      	pop	{r3, pc}
	...

08003aa0 <spiObjectInit>:
 *
 * @param[out] spip     pointer to the @p SPIDriver object
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {
 8003aa0:	b500      	push	{lr}
 8003aa2:	b083      	sub	sp, #12
 8003aa4:	9001      	str	r0, [sp, #4]

  spip->state = SPI_STOP;
 8003aa6:	9b01      	ldr	r3, [sp, #4]
 8003aa8:	2201      	movs	r2, #1
 8003aaa:	701a      	strb	r2, [r3, #0]
  spip->config = NULL;
 8003aac:	9b01      	ldr	r3, [sp, #4]
 8003aae:	2200      	movs	r2, #0
 8003ab0:	605a      	str	r2, [r3, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 8003ab2:	9b01      	ldr	r3, [sp, #4]
 8003ab4:	2200      	movs	r2, #0
 8003ab6:	609a      	str	r2, [r3, #8]
#endif
#if SPI_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&spip->mutex);
 8003ab8:	9b01      	ldr	r3, [sp, #4]
 8003aba:	330c      	adds	r3, #12
 8003abc:	4618      	mov	r0, r3
 8003abe:	f001 fa87 	bl	8004fd0 <osalMutexObjectInit.lto_priv.201>
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
 8003ac2:	b003      	add	sp, #12
 8003ac4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003ad0 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
 8003ad0:	b500      	push	{lr}
 8003ad2:	b083      	sub	sp, #12
 8003ad4:	9001      	str	r0, [sp, #4]
 8003ad6:	9100      	str	r1, [sp, #0]

  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
 8003ad8:	f001 fa5a 	bl	8004f90 <osalSysLock.lto_priv.197>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
 8003adc:	9b01      	ldr	r3, [sp, #4]
 8003ade:	9a00      	ldr	r2, [sp, #0]
 8003ae0:	605a      	str	r2, [r3, #4]
  spi_lld_start(spip);
 8003ae2:	9801      	ldr	r0, [sp, #4]
 8003ae4:	f7fd fa44 	bl	8000f70 <spi_lld_start>
  spip->state = SPI_READY;
 8003ae8:	9b01      	ldr	r3, [sp, #4]
 8003aea:	2202      	movs	r2, #2
 8003aec:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 8003aee:	f001 fa57 	bl	8004fa0 <osalSysUnlock.lto_priv.195>
}
 8003af2:	b003      	add	sp, #12
 8003af4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003b00 <spiSelect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
 8003b00:	b500      	push	{lr}
 8003b02:	b083      	sub	sp, #12
 8003b04:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalSysLock();
 8003b06:	f001 fa43 	bl	8004f90 <osalSysLock.lto_priv.197>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiSelectI(spip);
 8003b0a:	9801      	ldr	r0, [sp, #4]
 8003b0c:	f7fd fab0 	bl	8001070 <spi_lld_select>
  osalSysUnlock();
 8003b10:	f001 fa46 	bl	8004fa0 <osalSysUnlock.lto_priv.195>
}
 8003b14:	b003      	add	sp, #12
 8003b16:	f85d fb04 	ldr.w	pc, [sp], #4
 8003b1a:	bf00      	nop
 8003b1c:	0000      	movs	r0, r0
	...

08003b20 <spiUnselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
 8003b20:	b500      	push	{lr}
 8003b22:	b083      	sub	sp, #12
 8003b24:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalSysLock();
 8003b26:	f001 fa33 	bl	8004f90 <osalSysLock.lto_priv.197>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiUnselectI(spip);
 8003b2a:	9801      	ldr	r0, [sp, #4]
 8003b2c:	f7fd fab0 	bl	8001090 <spi_lld_unselect>
  osalSysUnlock();
 8003b30:	f001 fa36 	bl	8004fa0 <osalSysUnlock.lto_priv.195>
}
 8003b34:	b003      	add	sp, #12
 8003b36:	f85d fb04 	ldr.w	pc, [sp], #4
 8003b3a:	bf00      	nop
 8003b3c:	0000      	movs	r0, r0
	...

08003b40 <spiExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiExchange(SPIDriver *spip, size_t n,
                 const void *txbuf, void *rxbuf) {
 8003b40:	b500      	push	{lr}
 8003b42:	b085      	sub	sp, #20
 8003b44:	9003      	str	r0, [sp, #12]
 8003b46:	9102      	str	r1, [sp, #8]
 8003b48:	9201      	str	r2, [sp, #4]
 8003b4a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U) &&
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
 8003b4c:	f001 fa20 	bl	8004f90 <osalSysLock.lto_priv.197>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 8003b50:	9b03      	ldr	r3, [sp, #12]
 8003b52:	2203      	movs	r2, #3
 8003b54:	701a      	strb	r2, [r3, #0]
 8003b56:	9803      	ldr	r0, [sp, #12]
 8003b58:	9902      	ldr	r1, [sp, #8]
 8003b5a:	9a01      	ldr	r2, [sp, #4]
 8003b5c:	9b00      	ldr	r3, [sp, #0]
 8003b5e:	f7fd faa7 	bl	80010b0 <spi_lld_exchange>
  (void) osalThreadSuspendS(&spip->thread);
 8003b62:	9b03      	ldr	r3, [sp, #12]
 8003b64:	3308      	adds	r3, #8
 8003b66:	4618      	mov	r0, r3
 8003b68:	f001 fa22 	bl	8004fb0 <osalThreadSuspendS.lto_priv.193>
  osalSysUnlock();
 8003b6c:	f001 fa18 	bl	8004fa0 <osalSysUnlock.lto_priv.195>
}
 8003b70:	b005      	add	sp, #20
 8003b72:	f85d fb04 	ldr.w	pc, [sp], #4
 8003b76:	bf00      	nop
	...

08003b80 <spiSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
 8003b80:	b500      	push	{lr}
 8003b82:	b085      	sub	sp, #20
 8003b84:	9003      	str	r0, [sp, #12]
 8003b86:	9102      	str	r1, [sp, #8]
 8003b88:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));

  osalSysLock();
 8003b8a:	f001 fa01 	bl	8004f90 <osalSysLock.lto_priv.197>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartSendI(spip, n, txbuf);
 8003b8e:	9b03      	ldr	r3, [sp, #12]
 8003b90:	2203      	movs	r2, #3
 8003b92:	701a      	strb	r2, [r3, #0]
 8003b94:	9803      	ldr	r0, [sp, #12]
 8003b96:	9902      	ldr	r1, [sp, #8]
 8003b98:	9a01      	ldr	r2, [sp, #4]
 8003b9a:	f7fd fac9 	bl	8001130 <spi_lld_send>
  (void) osalThreadSuspendS(&spip->thread);
 8003b9e:	9b03      	ldr	r3, [sp, #12]
 8003ba0:	3308      	adds	r3, #8
 8003ba2:	4618      	mov	r0, r3
 8003ba4:	f001 fa04 	bl	8004fb0 <osalThreadSuspendS.lto_priv.193>
  osalSysUnlock();
 8003ba8:	f001 f9fa 	bl	8004fa0 <osalSysUnlock.lto_priv.195>
}
 8003bac:	b005      	add	sp, #20
 8003bae:	f85d fb04 	ldr.w	pc, [sp], #4
 8003bb2:	bf00      	nop
	...

08003bc0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003bc0:	b082      	sub	sp, #8
 8003bc2:	2320      	movs	r3, #32
 8003bc4:	9301      	str	r3, [sp, #4]
 8003bc6:	9b01      	ldr	r3, [sp, #4]
 8003bc8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003bcc:	b002      	add	sp, #8
 8003bce:	4770      	bx	lr

08003bd0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003bd0:	b082      	sub	sp, #8
 8003bd2:	2300      	movs	r3, #0
 8003bd4:	9301      	str	r3, [sp, #4]
 8003bd6:	9b01      	ldr	r3, [sp, #4]
 8003bd8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003bdc:	b002      	add	sp, #8
 8003bde:	4770      	bx	lr

08003be0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8003be0:	b508      	push	{r3, lr}

  port_lock();
 8003be2:	f7ff ffed 	bl	8003bc0 <port_lock>
}
 8003be6:	bd08      	pop	{r3, pc}
	...

08003bf0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8003bf0:	b508      	push	{r3, lr}

  port_unlock();
 8003bf2:	f7ff ffed 	bl	8003bd0 <port_unlock>
}
 8003bf6:	bd08      	pop	{r3, pc}
	...

08003c00 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003c00:	b508      	push	{r3, lr}

  port_lock();
 8003c02:	f7ff ffdd 	bl	8003bc0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8003c06:	bd08      	pop	{r3, pc}
	...

08003c10 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003c10:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8003c12:	f7ff ffdd 	bl	8003bd0 <port_unlock>
}
 8003c16:	bd08      	pop	{r3, pc}
	...

08003c20 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8003c20:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8003c22:	f7ff ffdd 	bl	8003be0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8003c26:	bd08      	pop	{r3, pc}
	...

08003c30 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8003c30:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8003c32:	f7ff ffdd 	bl	8003bf0 <port_unlock_from_isr>
}
 8003c36:	bd08      	pop	{r3, pc}
	...

08003c40 <osalSysLock.lto_priv.198>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8003c40:	b508      	push	{r3, lr}

  chSysLock();
 8003c42:	f7ff ffdd 	bl	8003c00 <chSysLock>
}
 8003c46:	bd08      	pop	{r3, pc}
	...

08003c50 <osalSysUnlock.lto_priv.196>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8003c50:	b508      	push	{r3, lr}

  chSysUnlock();
 8003c52:	f7ff ffdd 	bl	8003c10 <chSysUnlock>
}
 8003c56:	bd08      	pop	{r3, pc}
	...

08003c60 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8003c60:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8003c62:	f7ff ffdd 	bl	8003c20 <chSysLockFromISR>
}
 8003c66:	bd08      	pop	{r3, pc}
	...

08003c70 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8003c70:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8003c72:	f7ff ffdd 	bl	8003c30 <chSysUnlockFromISR>
}
 8003c76:	bd08      	pop	{r3, pc}
	...

08003c80 <osalThreadSuspendS.lto_priv.194>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8003c80:	b500      	push	{lr}
 8003c82:	b083      	sub	sp, #12
 8003c84:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 8003c86:	9801      	ldr	r0, [sp, #4]
 8003c88:	f002 f9c2 	bl	8006010 <chThdSuspendS>
 8003c8c:	4603      	mov	r3, r0
}
 8003c8e:	4618      	mov	r0, r3
 8003c90:	b003      	add	sp, #12
 8003c92:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c96:	bf00      	nop
	...

08003ca0 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8003ca0:	b500      	push	{lr}
 8003ca2:	b083      	sub	sp, #12
 8003ca4:	9001      	str	r0, [sp, #4]
 8003ca6:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 8003ca8:	9801      	ldr	r0, [sp, #4]
 8003caa:	9900      	ldr	r1, [sp, #0]
 8003cac:	f002 f9c8 	bl	8006040 <chThdResumeI>
}
 8003cb0:	b003      	add	sp, #12
 8003cb2:	f85d fb04 	ldr.w	pc, [sp], #4
 8003cb6:	bf00      	nop
	...

08003cc0 <get_hword>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static uint16_t get_hword(uint8_t *p) {
 8003cc0:	b084      	sub	sp, #16
 8003cc2:	9001      	str	r0, [sp, #4]
  uint16_t hw;

  hw  = (uint16_t)*p++;
 8003cc4:	9b01      	ldr	r3, [sp, #4]
 8003cc6:	1c5a      	adds	r2, r3, #1
 8003cc8:	9201      	str	r2, [sp, #4]
 8003cca:	781b      	ldrb	r3, [r3, #0]
 8003ccc:	f8ad 300e 	strh.w	r3, [sp, #14]
  hw |= (uint16_t)*p << 8U;
 8003cd0:	9b01      	ldr	r3, [sp, #4]
 8003cd2:	781b      	ldrb	r3, [r3, #0]
 8003cd4:	021b      	lsls	r3, r3, #8
 8003cd6:	b29a      	uxth	r2, r3
 8003cd8:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8003cdc:	4313      	orrs	r3, r2
 8003cde:	b29b      	uxth	r3, r3
 8003ce0:	f8ad 300e 	strh.w	r3, [sp, #14]
  return hw;
 8003ce4:	f8bd 300e 	ldrh.w	r3, [sp, #14]
}
 8003ce8:	4618      	mov	r0, r3
 8003cea:	b004      	add	sp, #16
 8003cec:	4770      	bx	lr
 8003cee:	bf00      	nop

08003cf0 <set_address>:
/**
 * @brief  SET ADDRESS transaction callback.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {
 8003cf0:	b500      	push	{lr}
 8003cf2:	b083      	sub	sp, #12
 8003cf4:	9001      	str	r0, [sp, #4]

  usbp->address = usbp->setup[2];
 8003cf6:	9b01      	ldr	r3, [sp, #4]
 8003cf8:	f893 2046 	ldrb.w	r2, [r3, #70]	; 0x46
 8003cfc:	9b01      	ldr	r3, [sp, #4]
 8003cfe:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
  usb_lld_set_address(usbp);
 8003d02:	9801      	ldr	r0, [sp, #4]
 8003d04:	f7fe f9e4 	bl	80020d0 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8003d08:	9b01      	ldr	r3, [sp, #4]
 8003d0a:	685b      	ldr	r3, [r3, #4]
 8003d0c:	681b      	ldr	r3, [r3, #0]
 8003d0e:	2b00      	cmp	r3, #0
 8003d10:	d005      	beq.n	8003d1e <set_address+0x2e>
 8003d12:	9b01      	ldr	r3, [sp, #4]
 8003d14:	685b      	ldr	r3, [r3, #4]
 8003d16:	681b      	ldr	r3, [r3, #0]
 8003d18:	9801      	ldr	r0, [sp, #4]
 8003d1a:	2101      	movs	r1, #1
 8003d1c:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 8003d1e:	9b01      	ldr	r3, [sp, #4]
 8003d20:	2203      	movs	r2, #3
 8003d22:	701a      	strb	r2, [r3, #0]
}
 8003d24:	b003      	add	sp, #12
 8003d26:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d2a:	bf00      	nop
 8003d2c:	0000      	movs	r0, r0
	...

08003d30 <default_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @return              The request handling exit code.
 * @retval false        Request not recognized by the handler or error.
 * @retval true         Request handled.
 */
static bool default_handler(USBDriver *usbp) {
 8003d30:	b570      	push	{r4, r5, r6, lr}
 8003d32:	b084      	sub	sp, #16
 8003d34:	9001      	str	r0, [sp, #4]
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8003d36:	9b01      	ldr	r3, [sp, #4]
 8003d38:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8003d3c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 8003d40:	9b01      	ldr	r3, [sp, #4]
 8003d42:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8003d46:	021b      	lsls	r3, r3, #8
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                                        USB_RTYPE_TYPE_MASK)) |
 8003d48:	4313      	orrs	r3, r2
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8003d4a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8003d4e:	d05a      	beq.n	8003e06 <default_handler+0xd6>
 8003d50:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8003d54:	d812      	bhi.n	8003d7c <default_handler+0x4c>
 8003d56:	2b02      	cmp	r3, #2
 8003d58:	f000 80ee 	beq.w	8003f38 <default_handler+0x208>
 8003d5c:	2b02      	cmp	r3, #2
 8003d5e:	d805      	bhi.n	8003d6c <default_handler+0x3c>
 8003d60:	2b00      	cmp	r3, #0
 8003d62:	d028      	beq.n	8003db6 <default_handler+0x86>
 8003d64:	2b01      	cmp	r3, #1
 8003d66:	f000 80dc 	beq.w	8003f22 <default_handler+0x1f2>
 8003d6a:	e1a6      	b.n	80040ba <default_handler+0x38a>
 8003d6c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8003d70:	d02e      	beq.n	8003dd0 <default_handler+0xa0>
 8003d72:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 8003d76:	f000 8136 	beq.w	8003fe6 <default_handler+0x2b6>
 8003d7a:	e19e      	b.n	80040ba <default_handler+0x38a>
 8003d7c:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8003d80:	d074      	beq.n	8003e6c <default_handler+0x13c>
 8003d82:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8003d86:	d808      	bhi.n	8003d9a <default_handler+0x6a>
 8003d88:	f240 3202 	movw	r2, #770	; 0x302
 8003d8c:	4293      	cmp	r3, r2
 8003d8e:	f000 815f 	beq.w	8004050 <default_handler+0x320>
 8003d92:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8003d96:	d051      	beq.n	8003e3c <default_handler+0x10c>
 8003d98:	e18f      	b.n	80040ba <default_handler+0x38a>
 8003d9a:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 8003d9e:	f000 8098 	beq.w	8003ed2 <default_handler+0x1a2>
 8003da2:	f640 4202 	movw	r2, #3074	; 0xc02
 8003da6:	4293      	cmp	r3, r2
 8003da8:	f000 80bb 	beq.w	8003f22 <default_handler+0x1f2>
 8003dac:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8003db0:	f000 8082 	beq.w	8003eb8 <default_handler+0x188>
 8003db4:	e181      	b.n	80040ba <default_handler+0x38a>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8003db6:	9b01      	ldr	r3, [sp, #4]
 8003db8:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 8003dbc:	9b01      	ldr	r3, [sp, #4]
 8003dbe:	639a      	str	r2, [r3, #56]	; 0x38
 8003dc0:	9b01      	ldr	r3, [sp, #4]
 8003dc2:	2202      	movs	r2, #2
 8003dc4:	63da      	str	r2, [r3, #60]	; 0x3c
 8003dc6:	9b01      	ldr	r3, [sp, #4]
 8003dc8:	2200      	movs	r2, #0
 8003dca:	641a      	str	r2, [r3, #64]	; 0x40
    return true;
 8003dcc:	2301      	movs	r3, #1
 8003dce:	e175      	b.n	80040bc <default_handler+0x38c>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8003dd0:	9b01      	ldr	r3, [sp, #4]
 8003dd2:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
 8003dd6:	2b01      	cmp	r3, #1
 8003dd8:	d113      	bne.n	8003e02 <default_handler+0xd2>
      usbp->status &= ~2U;
 8003dda:	9b01      	ldr	r3, [sp, #4]
 8003ddc:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
 8003de0:	f023 0302 	bic.w	r3, r3, #2
 8003de4:	b29a      	uxth	r2, r3
 8003de6:	9b01      	ldr	r3, [sp, #4]
 8003de8:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8003dec:	9b01      	ldr	r3, [sp, #4]
 8003dee:	2200      	movs	r2, #0
 8003df0:	639a      	str	r2, [r3, #56]	; 0x38
 8003df2:	9b01      	ldr	r3, [sp, #4]
 8003df4:	2200      	movs	r2, #0
 8003df6:	63da      	str	r2, [r3, #60]	; 0x3c
 8003df8:	9b01      	ldr	r3, [sp, #4]
 8003dfa:	2200      	movs	r2, #0
 8003dfc:	641a      	str	r2, [r3, #64]	; 0x40
      return true;
 8003dfe:	2301      	movs	r3, #1
 8003e00:	e15c      	b.n	80040bc <default_handler+0x38c>
    }
    return false;
 8003e02:	2300      	movs	r3, #0
 8003e04:	e15a      	b.n	80040bc <default_handler+0x38c>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8003e06:	9b01      	ldr	r3, [sp, #4]
 8003e08:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
 8003e0c:	2b01      	cmp	r3, #1
 8003e0e:	d113      	bne.n	8003e38 <default_handler+0x108>
      usbp->status |= 2U;
 8003e10:	9b01      	ldr	r3, [sp, #4]
 8003e12:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
 8003e16:	f043 0302 	orr.w	r3, r3, #2
 8003e1a:	b29a      	uxth	r2, r3
 8003e1c:	9b01      	ldr	r3, [sp, #4]
 8003e1e:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8003e22:	9b01      	ldr	r3, [sp, #4]
 8003e24:	2200      	movs	r2, #0
 8003e26:	639a      	str	r2, [r3, #56]	; 0x38
 8003e28:	9b01      	ldr	r3, [sp, #4]
 8003e2a:	2200      	movs	r2, #0
 8003e2c:	63da      	str	r2, [r3, #60]	; 0x3c
 8003e2e:	9b01      	ldr	r3, [sp, #4]
 8003e30:	2200      	movs	r2, #0
 8003e32:	641a      	str	r2, [r3, #64]	; 0x40
      return true;
 8003e34:	2301      	movs	r3, #1
 8003e36:	e141      	b.n	80040bc <default_handler+0x38c>
    }
    return false;
 8003e38:	2300      	movs	r3, #0
 8003e3a:	e13f      	b.n	80040bc <default_handler+0x38c>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 8003e3c:	9b01      	ldr	r3, [sp, #4]
 8003e3e:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8003e42:	2b00      	cmp	r3, #0
 8003e44:	d107      	bne.n	8003e56 <default_handler+0x126>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
 8003e46:	9b01      	ldr	r3, [sp, #4]
 8003e48:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 8003e4c:	2b05      	cmp	r3, #5
 8003e4e:	d102      	bne.n	8003e56 <default_handler+0x126>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
      set_address(usbp);
 8003e50:	9801      	ldr	r0, [sp, #4]
 8003e52:	f7ff ff4d 	bl	8003cf0 <set_address>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8003e56:	9b01      	ldr	r3, [sp, #4]
 8003e58:	2200      	movs	r2, #0
 8003e5a:	639a      	str	r2, [r3, #56]	; 0x38
 8003e5c:	9b01      	ldr	r3, [sp, #4]
 8003e5e:	2200      	movs	r2, #0
 8003e60:	63da      	str	r2, [r3, #60]	; 0x3c
 8003e62:	9b01      	ldr	r3, [sp, #4]
 8003e64:	2200      	movs	r2, #0
 8003e66:	641a      	str	r2, [r3, #64]	; 0x40
#else
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
 8003e68:	2301      	movs	r3, #1
 8003e6a:	e127      	b.n	80040bc <default_handler+0x38c>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8003e6c:	9b01      	ldr	r3, [sp, #4]
 8003e6e:	685b      	ldr	r3, [r3, #4]
 8003e70:	685c      	ldr	r4, [r3, #4]
 8003e72:	9b01      	ldr	r3, [sp, #4]
 8003e74:	f893 6047 	ldrb.w	r6, [r3, #71]	; 0x47
 8003e78:	9b01      	ldr	r3, [sp, #4]
 8003e7a:	f893 5046 	ldrb.w	r5, [r3, #70]	; 0x46
 8003e7e:	9b01      	ldr	r3, [sp, #4]
 8003e80:	3348      	adds	r3, #72	; 0x48
 8003e82:	4618      	mov	r0, r3
 8003e84:	f7ff ff1c 	bl	8003cc0 <get_hword>
 8003e88:	4603      	mov	r3, r0
 8003e8a:	9801      	ldr	r0, [sp, #4]
 8003e8c:	4631      	mov	r1, r6
 8003e8e:	462a      	mov	r2, r5
 8003e90:	47a0      	blx	r4
 8003e92:	9003      	str	r0, [sp, #12]
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 8003e94:	9b03      	ldr	r3, [sp, #12]
 8003e96:	2b00      	cmp	r3, #0
 8003e98:	d101      	bne.n	8003e9e <default_handler+0x16e>
      return false;
 8003e9a:	2300      	movs	r3, #0
 8003e9c:	e10e      	b.n	80040bc <default_handler+0x38c>
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 8003e9e:	9b03      	ldr	r3, [sp, #12]
 8003ea0:	685a      	ldr	r2, [r3, #4]
 8003ea2:	9b01      	ldr	r3, [sp, #4]
 8003ea4:	639a      	str	r2, [r3, #56]	; 0x38
 8003ea6:	9b03      	ldr	r3, [sp, #12]
 8003ea8:	681a      	ldr	r2, [r3, #0]
 8003eaa:	9b01      	ldr	r3, [sp, #4]
 8003eac:	63da      	str	r2, [r3, #60]	; 0x3c
 8003eae:	9b01      	ldr	r3, [sp, #4]
 8003eb0:	2200      	movs	r2, #0
 8003eb2:	641a      	str	r2, [r3, #64]	; 0x40
    /*lint -restore*/
    return true;
 8003eb4:	2301      	movs	r3, #1
 8003eb6:	e101      	b.n	80040bc <default_handler+0x38c>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8003eb8:	9b01      	ldr	r3, [sp, #4]
 8003eba:	f103 024f 	add.w	r2, r3, #79	; 0x4f
 8003ebe:	9b01      	ldr	r3, [sp, #4]
 8003ec0:	639a      	str	r2, [r3, #56]	; 0x38
 8003ec2:	9b01      	ldr	r3, [sp, #4]
 8003ec4:	2201      	movs	r2, #1
 8003ec6:	63da      	str	r2, [r3, #60]	; 0x3c
 8003ec8:	9b01      	ldr	r3, [sp, #4]
 8003eca:	2200      	movs	r2, #0
 8003ecc:	641a      	str	r2, [r3, #64]	; 0x40
    return true;
 8003ece:	2301      	movs	r3, #1
 8003ed0:	e0f4      	b.n	80040bc <default_handler+0x38c>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host.*/
    usbp->configuration = usbp->setup[2];
 8003ed2:	9b01      	ldr	r3, [sp, #4]
 8003ed4:	f893 2046 	ldrb.w	r2, [r3, #70]	; 0x46
 8003ed8:	9b01      	ldr	r3, [sp, #4]
 8003eda:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
    if (usbp->configuration == 0U) {
 8003ede:	9b01      	ldr	r3, [sp, #4]
 8003ee0:	f893 304f 	ldrb.w	r3, [r3, #79]	; 0x4f
 8003ee4:	2b00      	cmp	r3, #0
 8003ee6:	d103      	bne.n	8003ef0 <default_handler+0x1c0>
      usbp->state = USB_SELECTED;
 8003ee8:	9b01      	ldr	r3, [sp, #4]
 8003eea:	2203      	movs	r2, #3
 8003eec:	701a      	strb	r2, [r3, #0]
 8003eee:	e002      	b.n	8003ef6 <default_handler+0x1c6>
    }
    else {
      usbp->state = USB_ACTIVE;
 8003ef0:	9b01      	ldr	r3, [sp, #4]
 8003ef2:	2204      	movs	r2, #4
 8003ef4:	701a      	strb	r2, [r3, #0]
    }
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8003ef6:	9b01      	ldr	r3, [sp, #4]
 8003ef8:	685b      	ldr	r3, [r3, #4]
 8003efa:	681b      	ldr	r3, [r3, #0]
 8003efc:	2b00      	cmp	r3, #0
 8003efe:	d005      	beq.n	8003f0c <default_handler+0x1dc>
 8003f00:	9b01      	ldr	r3, [sp, #4]
 8003f02:	685b      	ldr	r3, [r3, #4]
 8003f04:	681b      	ldr	r3, [r3, #0]
 8003f06:	9801      	ldr	r0, [sp, #4]
 8003f08:	2102      	movs	r1, #2
 8003f0a:	4798      	blx	r3
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8003f0c:	9b01      	ldr	r3, [sp, #4]
 8003f0e:	2200      	movs	r2, #0
 8003f10:	639a      	str	r2, [r3, #56]	; 0x38
 8003f12:	9b01      	ldr	r3, [sp, #4]
 8003f14:	2200      	movs	r2, #0
 8003f16:	63da      	str	r2, [r3, #60]	; 0x3c
 8003f18:	9b01      	ldr	r3, [sp, #4]
 8003f1a:	2200      	movs	r2, #0
 8003f1c:	641a      	str	r2, [r3, #64]	; 0x40
    return true;
 8003f1e:	2301      	movs	r3, #1
 8003f20:	e0cc      	b.n	80040bc <default_handler+0x38c>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8003f22:	9b01      	ldr	r3, [sp, #4]
 8003f24:	4a67      	ldr	r2, [pc, #412]	; (80040c4 <default_handler+0x394>)
 8003f26:	639a      	str	r2, [r3, #56]	; 0x38
 8003f28:	9b01      	ldr	r3, [sp, #4]
 8003f2a:	2202      	movs	r2, #2
 8003f2c:	63da      	str	r2, [r3, #60]	; 0x3c
 8003f2e:	9b01      	ldr	r3, [sp, #4]
 8003f30:	2200      	movs	r2, #0
 8003f32:	641a      	str	r2, [r3, #64]	; 0x40
    /*lint -restore*/
    return true;
 8003f34:	2301      	movs	r3, #1
 8003f36:	e0c1      	b.n	80040bc <default_handler+0x38c>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8003f38:	9b01      	ldr	r3, [sp, #4]
 8003f3a:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8003f3e:	b2db      	uxtb	r3, r3
 8003f40:	b25b      	sxtb	r3, r3
 8003f42:	2b00      	cmp	r3, #0
 8003f44:	da27      	bge.n	8003f96 <default_handler+0x266>
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 8003f46:	9b01      	ldr	r3, [sp, #4]
 8003f48:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8003f4c:	f003 030f 	and.w	r3, r3, #15
 8003f50:	b2db      	uxtb	r3, r3
 8003f52:	9801      	ldr	r0, [sp, #4]
 8003f54:	4619      	mov	r1, r3
 8003f56:	f7fe fa1b 	bl	8002390 <usb_lld_get_status_in>
 8003f5a:	4603      	mov	r3, r0
 8003f5c:	2b01      	cmp	r3, #1
 8003f5e:	d002      	beq.n	8003f66 <default_handler+0x236>
 8003f60:	2b02      	cmp	r3, #2
 8003f62:	d00b      	beq.n	8003f7c <default_handler+0x24c>
 8003f64:	e015      	b.n	8003f92 <default_handler+0x262>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8003f66:	9b01      	ldr	r3, [sp, #4]
 8003f68:	4a57      	ldr	r2, [pc, #348]	; (80040c8 <default_handler+0x398>)
 8003f6a:	639a      	str	r2, [r3, #56]	; 0x38
 8003f6c:	9b01      	ldr	r3, [sp, #4]
 8003f6e:	2202      	movs	r2, #2
 8003f70:	63da      	str	r2, [r3, #60]	; 0x3c
 8003f72:	9b01      	ldr	r3, [sp, #4]
 8003f74:	2200      	movs	r2, #0
 8003f76:	641a      	str	r2, [r3, #64]	; 0x40
        /*lint -restore*/
        return true;
 8003f78:	2301      	movs	r3, #1
 8003f7a:	e09f      	b.n	80040bc <default_handler+0x38c>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8003f7c:	9b01      	ldr	r3, [sp, #4]
 8003f7e:	4a53      	ldr	r2, [pc, #332]	; (80040cc <default_handler+0x39c>)
 8003f80:	639a      	str	r2, [r3, #56]	; 0x38
 8003f82:	9b01      	ldr	r3, [sp, #4]
 8003f84:	2202      	movs	r2, #2
 8003f86:	63da      	str	r2, [r3, #60]	; 0x3c
 8003f88:	9b01      	ldr	r3, [sp, #4]
 8003f8a:	2200      	movs	r2, #0
 8003f8c:	641a      	str	r2, [r3, #64]	; 0x40
        /*lint -restore*/
        return true;
 8003f8e:	2301      	movs	r3, #1
 8003f90:	e094      	b.n	80040bc <default_handler+0x38c>
      case EP_STATUS_DISABLED:
      default:
        return false;
 8003f92:	2300      	movs	r3, #0
 8003f94:	e092      	b.n	80040bc <default_handler+0x38c>
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 8003f96:	9b01      	ldr	r3, [sp, #4]
 8003f98:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8003f9c:	f003 030f 	and.w	r3, r3, #15
 8003fa0:	b2db      	uxtb	r3, r3
 8003fa2:	9801      	ldr	r0, [sp, #4]
 8003fa4:	4619      	mov	r1, r3
 8003fa6:	f7fe f9d3 	bl	8002350 <usb_lld_get_status_out>
 8003faa:	4603      	mov	r3, r0
 8003fac:	2b01      	cmp	r3, #1
 8003fae:	d002      	beq.n	8003fb6 <default_handler+0x286>
 8003fb0:	2b02      	cmp	r3, #2
 8003fb2:	d00b      	beq.n	8003fcc <default_handler+0x29c>
 8003fb4:	e015      	b.n	8003fe2 <default_handler+0x2b2>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8003fb6:	9b01      	ldr	r3, [sp, #4]
 8003fb8:	4a43      	ldr	r2, [pc, #268]	; (80040c8 <default_handler+0x398>)
 8003fba:	639a      	str	r2, [r3, #56]	; 0x38
 8003fbc:	9b01      	ldr	r3, [sp, #4]
 8003fbe:	2202      	movs	r2, #2
 8003fc0:	63da      	str	r2, [r3, #60]	; 0x3c
 8003fc2:	9b01      	ldr	r3, [sp, #4]
 8003fc4:	2200      	movs	r2, #0
 8003fc6:	641a      	str	r2, [r3, #64]	; 0x40
        /*lint -restore*/
        return true;
 8003fc8:	2301      	movs	r3, #1
 8003fca:	e077      	b.n	80040bc <default_handler+0x38c>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8003fcc:	9b01      	ldr	r3, [sp, #4]
 8003fce:	4a3f      	ldr	r2, [pc, #252]	; (80040cc <default_handler+0x39c>)
 8003fd0:	639a      	str	r2, [r3, #56]	; 0x38
 8003fd2:	9b01      	ldr	r3, [sp, #4]
 8003fd4:	2202      	movs	r2, #2
 8003fd6:	63da      	str	r2, [r3, #60]	; 0x3c
 8003fd8:	9b01      	ldr	r3, [sp, #4]
 8003fda:	2200      	movs	r2, #0
 8003fdc:	641a      	str	r2, [r3, #64]	; 0x40
        /*lint -restore*/
        return true;
 8003fde:	2301      	movs	r3, #1
 8003fe0:	e06c      	b.n	80040bc <default_handler+0x38c>
      case EP_STATUS_DISABLED:
      default:
        return false;
 8003fe2:	2300      	movs	r3, #0
 8003fe4:	e06a      	b.n	80040bc <default_handler+0x38c>
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8003fe6:	9b01      	ldr	r3, [sp, #4]
 8003fe8:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
 8003fec:	2b00      	cmp	r3, #0
 8003fee:	d001      	beq.n	8003ff4 <default_handler+0x2c4>
      return false;
 8003ff0:	2300      	movs	r3, #0
 8003ff2:	e063      	b.n	80040bc <default_handler+0x38c>
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8003ff4:	9b01      	ldr	r3, [sp, #4]
 8003ff6:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8003ffa:	f003 030f 	and.w	r3, r3, #15
 8003ffe:	2b00      	cmp	r3, #0
 8004000:	d01b      	beq.n	800403a <default_handler+0x30a>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8004002:	9b01      	ldr	r3, [sp, #4]
 8004004:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8004008:	b2db      	uxtb	r3, r3
 800400a:	b25b      	sxtb	r3, r3
 800400c:	2b00      	cmp	r3, #0
 800400e:	da0a      	bge.n	8004026 <default_handler+0x2f6>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 8004010:	9b01      	ldr	r3, [sp, #4]
 8004012:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8004016:	f003 030f 	and.w	r3, r3, #15
 800401a:	b2db      	uxtb	r3, r3
 800401c:	9801      	ldr	r0, [sp, #4]
 800401e:	4619      	mov	r1, r3
 8004020:	f7fe fb9e 	bl	8002760 <usb_lld_clear_in>
 8004024:	e009      	b.n	800403a <default_handler+0x30a>
      }
      else {
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 8004026:	9b01      	ldr	r3, [sp, #4]
 8004028:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 800402c:	f003 030f 	and.w	r3, r3, #15
 8004030:	b2db      	uxtb	r3, r3
 8004032:	9801      	ldr	r0, [sp, #4]
 8004034:	4619      	mov	r1, r3
 8004036:	f7fe fb73 	bl	8002720 <usb_lld_clear_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800403a:	9b01      	ldr	r3, [sp, #4]
 800403c:	2200      	movs	r2, #0
 800403e:	639a      	str	r2, [r3, #56]	; 0x38
 8004040:	9b01      	ldr	r3, [sp, #4]
 8004042:	2200      	movs	r2, #0
 8004044:	63da      	str	r2, [r3, #60]	; 0x3c
 8004046:	9b01      	ldr	r3, [sp, #4]
 8004048:	2200      	movs	r2, #0
 800404a:	641a      	str	r2, [r3, #64]	; 0x40
    return true;
 800404c:	2301      	movs	r3, #1
 800404e:	e035      	b.n	80040bc <default_handler+0x38c>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8004050:	9b01      	ldr	r3, [sp, #4]
 8004052:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
 8004056:	2b00      	cmp	r3, #0
 8004058:	d001      	beq.n	800405e <default_handler+0x32e>
      return false;
 800405a:	2300      	movs	r3, #0
 800405c:	e02e      	b.n	80040bc <default_handler+0x38c>
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 800405e:	9b01      	ldr	r3, [sp, #4]
 8004060:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8004064:	f003 030f 	and.w	r3, r3, #15
 8004068:	2b00      	cmp	r3, #0
 800406a:	d01b      	beq.n	80040a4 <default_handler+0x374>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800406c:	9b01      	ldr	r3, [sp, #4]
 800406e:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8004072:	b2db      	uxtb	r3, r3
 8004074:	b25b      	sxtb	r3, r3
 8004076:	2b00      	cmp	r3, #0
 8004078:	da0a      	bge.n	8004090 <default_handler+0x360>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 800407a:	9b01      	ldr	r3, [sp, #4]
 800407c:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8004080:	f003 030f 	and.w	r3, r3, #15
 8004084:	b2db      	uxtb	r3, r3
 8004086:	9801      	ldr	r0, [sp, #4]
 8004088:	4619      	mov	r1, r3
 800408a:	f7fe fb29 	bl	80026e0 <usb_lld_stall_in>
 800408e:	e009      	b.n	80040a4 <default_handler+0x374>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 8004090:	9b01      	ldr	r3, [sp, #4]
 8004092:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8004096:	f003 030f 	and.w	r3, r3, #15
 800409a:	b2db      	uxtb	r3, r3
 800409c:	9801      	ldr	r0, [sp, #4]
 800409e:	4619      	mov	r1, r3
 80040a0:	f7fe fafe 	bl	80026a0 <usb_lld_stall_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80040a4:	9b01      	ldr	r3, [sp, #4]
 80040a6:	2200      	movs	r2, #0
 80040a8:	639a      	str	r2, [r3, #56]	; 0x38
 80040aa:	9b01      	ldr	r3, [sp, #4]
 80040ac:	2200      	movs	r2, #0
 80040ae:	63da      	str	r2, [r3, #60]	; 0x3c
 80040b0:	9b01      	ldr	r3, [sp, #4]
 80040b2:	2200      	movs	r2, #0
 80040b4:	641a      	str	r2, [r3, #64]	; 0x40
    return true;
 80040b6:	2301      	movs	r3, #1
 80040b8:	e000      	b.n	80040bc <default_handler+0x38c>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_INTERFACE << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_SET_INTERFACE << 8):
    /* All the above requests are not handled here, if you need them then
       use the hook mechanism and provide handling.*/
  default:
    return false;
 80040ba:	2300      	movs	r3, #0
  }
}
 80040bc:	4618      	mov	r0, r3
 80040be:	b004      	add	sp, #16
 80040c0:	bd70      	pop	{r4, r5, r6, pc}
 80040c2:	bf00      	nop
 80040c4:	08006a80 	.word	0x08006a80
 80040c8:	08006aa0 	.word	0x08006aa0
 80040cc:	08006a90 	.word	0x08006a90

080040d0 <usbInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void usbInit(void) {
 80040d0:	b508      	push	{r3, lr}

  usb_lld_init();
 80040d2:	f7fd fea5 	bl	8001e20 <usb_lld_init>
}
 80040d6:	bd08      	pop	{r3, pc}
	...

080040e0 <usbObjectInit>:
 *
 * @param[out] usbp     pointer to the @p USBDriver object
 *
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
 80040e0:	b084      	sub	sp, #16
 80040e2:	9001      	str	r0, [sp, #4]
  unsigned i;

  usbp->state        = USB_STOP;
 80040e4:	9b01      	ldr	r3, [sp, #4]
 80040e6:	2201      	movs	r2, #1
 80040e8:	701a      	strb	r2, [r3, #0]
  usbp->config       = NULL;
 80040ea:	9b01      	ldr	r3, [sp, #4]
 80040ec:	2200      	movs	r2, #0
 80040ee:	605a      	str	r2, [r3, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 80040f0:	2300      	movs	r3, #0
 80040f2:	9303      	str	r3, [sp, #12]
 80040f4:	e00f      	b.n	8004116 <usbObjectInit+0x36>
    usbp->in_params[i]  = NULL;
 80040f6:	9a01      	ldr	r2, [sp, #4]
 80040f8:	9b03      	ldr	r3, [sp, #12]
 80040fa:	3306      	adds	r3, #6
 80040fc:	009b      	lsls	r3, r3, #2
 80040fe:	4413      	add	r3, r2
 8004100:	2200      	movs	r2, #0
 8004102:	605a      	str	r2, [r3, #4]
    usbp->out_params[i] = NULL;
 8004104:	9b01      	ldr	r3, [sp, #4]
 8004106:	9a03      	ldr	r2, [sp, #12]
 8004108:	320a      	adds	r2, #10
 800410a:	2100      	movs	r1, #0
 800410c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8004110:	9b03      	ldr	r3, [sp, #12]
 8004112:	3301      	adds	r3, #1
 8004114:	9303      	str	r3, [sp, #12]
 8004116:	9b03      	ldr	r3, [sp, #12]
 8004118:	2b02      	cmp	r3, #2
 800411a:	d9ec      	bls.n	80040f6 <usbObjectInit+0x16>
    usbp->in_params[i]  = NULL;
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
 800411c:	9b01      	ldr	r3, [sp, #4]
 800411e:	2200      	movs	r2, #0
 8004120:	811a      	strh	r2, [r3, #8]
  usbp->receiving    = 0;
 8004122:	9b01      	ldr	r3, [sp, #4]
 8004124:	2200      	movs	r2, #0
 8004126:	815a      	strh	r2, [r3, #10]
}
 8004128:	b004      	add	sp, #16
 800412a:	4770      	bx	lr
 800412c:	0000      	movs	r0, r0
	...

08004130 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 8004130:	b500      	push	{lr}
 8004132:	b085      	sub	sp, #20
 8004134:	9001      	str	r0, [sp, #4]
 8004136:	9100      	str	r1, [sp, #0]
  unsigned i;

  osalDbgCheck((usbp != NULL) && (config != NULL));

  osalSysLock();
 8004138:	f7ff fd82 	bl	8003c40 <osalSysLock.lto_priv.198>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
 800413c:	9b01      	ldr	r3, [sp, #4]
 800413e:	9a00      	ldr	r2, [sp, #0]
 8004140:	605a      	str	r2, [r3, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8004142:	2300      	movs	r3, #0
 8004144:	9303      	str	r3, [sp, #12]
 8004146:	e009      	b.n	800415c <usbStart+0x2c>
    usbp->epc[i] = NULL;
 8004148:	9a01      	ldr	r2, [sp, #4]
 800414a:	9b03      	ldr	r3, [sp, #12]
 800414c:	3302      	adds	r3, #2
 800414e:	009b      	lsls	r3, r3, #2
 8004150:	4413      	add	r3, r2
 8004152:	2200      	movs	r2, #0
 8004154:	605a      	str	r2, [r3, #4]

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8004156:	9b03      	ldr	r3, [sp, #12]
 8004158:	3301      	adds	r3, #1
 800415a:	9303      	str	r3, [sp, #12]
 800415c:	9b03      	ldr	r3, [sp, #12]
 800415e:	2b03      	cmp	r3, #3
 8004160:	d9f2      	bls.n	8004148 <usbStart+0x18>
    usbp->epc[i] = NULL;
  }
  usb_lld_start(usbp);
 8004162:	9801      	ldr	r0, [sp, #4]
 8004164:	f7fd fe8c 	bl	8001e80 <usb_lld_start>
  usbp->state = USB_READY;
 8004168:	9b01      	ldr	r3, [sp, #4]
 800416a:	2202      	movs	r2, #2
 800416c:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 800416e:	f7ff fd6f 	bl	8003c50 <osalSysUnlock.lto_priv.196>
}
 8004172:	b005      	add	sp, #20
 8004174:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004180 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 8004180:	b500      	push	{lr}
 8004182:	b085      	sub	sp, #20
 8004184:	9003      	str	r0, [sp, #12]
 8004186:	460b      	mov	r3, r1
 8004188:	9201      	str	r2, [sp, #4]
 800418a:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;
 800418e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8004192:	9a03      	ldr	r2, [sp, #12]
 8004194:	3302      	adds	r3, #2
 8004196:	009b      	lsls	r3, r3, #2
 8004198:	4413      	add	r3, r2
 800419a:	9a01      	ldr	r2, [sp, #4]
 800419c:	605a      	str	r2, [r3, #4]

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 800419e:	9b01      	ldr	r3, [sp, #4]
 80041a0:	695b      	ldr	r3, [r3, #20]
 80041a2:	2b00      	cmp	r3, #0
 80041a4:	d006      	beq.n	80041b4 <usbInitEndpointI+0x34>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 80041a6:	9b01      	ldr	r3, [sp, #4]
 80041a8:	695b      	ldr	r3, [r3, #20]
 80041aa:	4618      	mov	r0, r3
 80041ac:	2100      	movs	r1, #0
 80041ae:	2214      	movs	r2, #20
 80041b0:	f002 f81e 	bl	80061f0 <memset>
  }
  if (epcp->out_state != NULL) {
 80041b4:	9b01      	ldr	r3, [sp, #4]
 80041b6:	699b      	ldr	r3, [r3, #24]
 80041b8:	2b00      	cmp	r3, #0
 80041ba:	d006      	beq.n	80041ca <usbInitEndpointI+0x4a>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 80041bc:	9b01      	ldr	r3, [sp, #4]
 80041be:	699b      	ldr	r3, [r3, #24]
 80041c0:	4618      	mov	r0, r3
 80041c2:	2100      	movs	r1, #0
 80041c4:	2214      	movs	r2, #20
 80041c6:	f002 f813 	bl	80061f0 <memset>
  }

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 80041ca:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80041ce:	9803      	ldr	r0, [sp, #12]
 80041d0:	4619      	mov	r1, r3
 80041d2:	f7fd ff95 	bl	8002100 <usb_lld_init_endpoint>
}
 80041d6:	b005      	add	sp, #20
 80041d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80041dc:	0000      	movs	r0, r0
	...

080041e0 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 80041e0:	b500      	push	{lr}
 80041e2:	b087      	sub	sp, #28
 80041e4:	9003      	str	r0, [sp, #12]
 80041e6:	9201      	str	r2, [sp, #4]
 80041e8:	9300      	str	r3, [sp, #0]
 80041ea:	460b      	mov	r3, r1
 80041ec:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80041f0:	9b03      	ldr	r3, [sp, #12]
 80041f2:	895a      	ldrh	r2, [r3, #10]
 80041f4:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80041f8:	2101      	movs	r1, #1
 80041fa:	fa01 f303 	lsl.w	r3, r1, r3
 80041fe:	b29b      	uxth	r3, r3
 8004200:	4313      	orrs	r3, r2
 8004202:	b29a      	uxth	r2, r3
 8004204:	9b03      	ldr	r3, [sp, #12]
 8004206:	815a      	strh	r2, [r3, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8004208:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800420c:	9a03      	ldr	r2, [sp, #12]
 800420e:	3302      	adds	r3, #2
 8004210:	009b      	lsls	r3, r3, #2
 8004212:	4413      	add	r3, r2
 8004214:	685b      	ldr	r3, [r3, #4]
 8004216:	699b      	ldr	r3, [r3, #24]
 8004218:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  osp->rxbuf  = buf;
 800421a:	9b05      	ldr	r3, [sp, #20]
 800421c:	9a01      	ldr	r2, [sp, #4]
 800421e:	609a      	str	r2, [r3, #8]
  osp->rxsize = n;
 8004220:	9b05      	ldr	r3, [sp, #20]
 8004222:	9a00      	ldr	r2, [sp, #0]
 8004224:	601a      	str	r2, [r3, #0]
  osp->rxcnt  = 0;
 8004226:	9b05      	ldr	r3, [sp, #20]
 8004228:	2200      	movs	r2, #0
 800422a:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
 800422c:	9b05      	ldr	r3, [sp, #20]
 800422e:	2200      	movs	r2, #0
 8004230:	60da      	str	r2, [r3, #12]
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 8004232:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8004236:	9803      	ldr	r0, [sp, #12]
 8004238:	4619      	mov	r1, r3
 800423a:	f7fe f8e1 	bl	8002400 <usb_lld_start_out>
}
 800423e:	b007      	add	sp, #28
 8004240:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004250 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 8004250:	b500      	push	{lr}
 8004252:	b087      	sub	sp, #28
 8004254:	9003      	str	r0, [sp, #12]
 8004256:	9201      	str	r2, [sp, #4]
 8004258:	9300      	str	r3, [sp, #0]
 800425a:	460b      	mov	r3, r1
 800425c:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8004260:	9b03      	ldr	r3, [sp, #12]
 8004262:	891a      	ldrh	r2, [r3, #8]
 8004264:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8004268:	2101      	movs	r1, #1
 800426a:	fa01 f303 	lsl.w	r3, r1, r3
 800426e:	b29b      	uxth	r3, r3
 8004270:	4313      	orrs	r3, r2
 8004272:	b29a      	uxth	r2, r3
 8004274:	9b03      	ldr	r3, [sp, #12]
 8004276:	811a      	strh	r2, [r3, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8004278:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800427c:	9a03      	ldr	r2, [sp, #12]
 800427e:	3302      	adds	r3, #2
 8004280:	009b      	lsls	r3, r3, #2
 8004282:	4413      	add	r3, r2
 8004284:	685b      	ldr	r3, [r3, #4]
 8004286:	695b      	ldr	r3, [r3, #20]
 8004288:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  isp->txbuf  = buf;
 800428a:	9b05      	ldr	r3, [sp, #20]
 800428c:	9a01      	ldr	r2, [sp, #4]
 800428e:	609a      	str	r2, [r3, #8]
  isp->txsize = n;
 8004290:	9b05      	ldr	r3, [sp, #20]
 8004292:	9a00      	ldr	r2, [sp, #0]
 8004294:	601a      	str	r2, [r3, #0]
  isp->txcnt  = 0;
 8004296:	9b05      	ldr	r3, [sp, #20]
 8004298:	2200      	movs	r2, #0
 800429a:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
 800429c:	9b05      	ldr	r3, [sp, #20]
 800429e:	2200      	movs	r2, #0
 80042a0:	60da      	str	r2, [r3, #12]
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 80042a2:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80042a6:	9803      	ldr	r0, [sp, #12]
 80042a8:	4619      	mov	r1, r3
 80042aa:	f7fe f949 	bl	8002540 <usb_lld_start_in>
}
 80042ae:	b007      	add	sp, #28
 80042b0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080042c0 <usbTransmit>:
 *                      has been aborted by an USB reset or a transition to
 *                      the @p USB_SUSPENDED state.
 *
 * @api
 */
msg_t usbTransmit(USBDriver *usbp, usbep_t ep, const uint8_t *buf, size_t n) {
 80042c0:	b500      	push	{lr}
 80042c2:	b087      	sub	sp, #28
 80042c4:	9003      	str	r0, [sp, #12]
 80042c6:	9201      	str	r2, [sp, #4]
 80042c8:	9300      	str	r3, [sp, #0]
 80042ca:	460b      	mov	r3, r1
 80042cc:	f88d 300b 	strb.w	r3, [sp, #11]
  msg_t msg;

  osalSysLock();
 80042d0:	f7ff fcb6 	bl	8003c40 <osalSysLock.lto_priv.198>

  if (usbGetDriverStateI(usbp) != USB_ACTIVE) {
 80042d4:	9b03      	ldr	r3, [sp, #12]
 80042d6:	781b      	ldrb	r3, [r3, #0]
 80042d8:	2b04      	cmp	r3, #4
 80042da:	d004      	beq.n	80042e6 <usbTransmit+0x26>
    osalSysUnlock();
 80042dc:	f7ff fcb8 	bl	8003c50 <osalSysUnlock.lto_priv.196>
    return MSG_RESET;
 80042e0:	f06f 0301 	mvn.w	r3, #1
 80042e4:	e017      	b.n	8004316 <usbTransmit+0x56>
  }

  usbStartTransmitI(usbp, ep, buf, n);
 80042e6:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80042ea:	9803      	ldr	r0, [sp, #12]
 80042ec:	4619      	mov	r1, r3
 80042ee:	9a01      	ldr	r2, [sp, #4]
 80042f0:	9b00      	ldr	r3, [sp, #0]
 80042f2:	f7ff ffad 	bl	8004250 <usbStartTransmitI>
  msg = osalThreadSuspendS(&usbp->epc[ep]->in_state->thread);
 80042f6:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80042fa:	9a03      	ldr	r2, [sp, #12]
 80042fc:	3302      	adds	r3, #2
 80042fe:	009b      	lsls	r3, r3, #2
 8004300:	4413      	add	r3, r2
 8004302:	685b      	ldr	r3, [r3, #4]
 8004304:	695b      	ldr	r3, [r3, #20]
 8004306:	330c      	adds	r3, #12
 8004308:	4618      	mov	r0, r3
 800430a:	f7ff fcb9 	bl	8003c80 <osalThreadSuspendS.lto_priv.194>
 800430e:	9005      	str	r0, [sp, #20]
  osalSysUnlock();
 8004310:	f7ff fc9e 	bl	8003c50 <osalSysUnlock.lto_priv.196>

  return msg;
 8004314:	9b05      	ldr	r3, [sp, #20]
}
 8004316:	4618      	mov	r0, r3
 8004318:	b007      	add	sp, #28
 800431a:	f85d fb04 	ldr.w	pc, [sp], #4
 800431e:	bf00      	nop

08004320 <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 8004320:	b500      	push	{lr}
 8004322:	b085      	sub	sp, #20
 8004324:	9001      	str	r0, [sp, #4]
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8004326:	9b01      	ldr	r3, [sp, #4]
 8004328:	2202      	movs	r2, #2
 800432a:	701a      	strb	r2, [r3, #0]

  /* Resetting internal state.*/
  usbp->status        = 0;
 800432c:	9b01      	ldr	r3, [sp, #4]
 800432e:	2200      	movs	r2, #0
 8004330:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
  usbp->address       = 0;
 8004334:	9b01      	ldr	r3, [sp, #4]
 8004336:	2200      	movs	r2, #0
 8004338:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
  usbp->configuration = 0;
 800433c:	9b01      	ldr	r3, [sp, #4]
 800433e:	2200      	movs	r2, #0
 8004340:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
  usbp->transmitting  = 0;
 8004344:	9b01      	ldr	r3, [sp, #4]
 8004346:	2200      	movs	r2, #0
 8004348:	811a      	strh	r2, [r3, #8]
  usbp->receiving     = 0;
 800434a:	9b01      	ldr	r3, [sp, #4]
 800434c:	2200      	movs	r2, #0
 800434e:	815a      	strh	r2, [r3, #10]

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8004350:	2300      	movs	r3, #0
 8004352:	9303      	str	r3, [sp, #12]
 8004354:	e041      	b.n	80043da <_usb_reset+0xba>
#if USB_USE_WAIT == TRUE
    /* Signaling the event to threads waiting on endpoints.*/
    if (usbp->epc[i] != NULL) {
 8004356:	9a01      	ldr	r2, [sp, #4]
 8004358:	9b03      	ldr	r3, [sp, #12]
 800435a:	3302      	adds	r3, #2
 800435c:	009b      	lsls	r3, r3, #2
 800435e:	4413      	add	r3, r2
 8004360:	685b      	ldr	r3, [r3, #4]
 8004362:	2b00      	cmp	r3, #0
 8004364:	d02f      	beq.n	80043c6 <_usb_reset+0xa6>
      osalSysLockFromISR();
 8004366:	f7ff fc7b 	bl	8003c60 <osalSysLockFromISR>
      if (usbp->epc[i]->in_state != NULL) {
 800436a:	9a01      	ldr	r2, [sp, #4]
 800436c:	9b03      	ldr	r3, [sp, #12]
 800436e:	3302      	adds	r3, #2
 8004370:	009b      	lsls	r3, r3, #2
 8004372:	4413      	add	r3, r2
 8004374:	685b      	ldr	r3, [r3, #4]
 8004376:	695b      	ldr	r3, [r3, #20]
 8004378:	2b00      	cmp	r3, #0
 800437a:	d00c      	beq.n	8004396 <_usb_reset+0x76>
        osalThreadResumeI(&usbp->epc[i]->in_state->thread, MSG_RESET);
 800437c:	9a01      	ldr	r2, [sp, #4]
 800437e:	9b03      	ldr	r3, [sp, #12]
 8004380:	3302      	adds	r3, #2
 8004382:	009b      	lsls	r3, r3, #2
 8004384:	4413      	add	r3, r2
 8004386:	685b      	ldr	r3, [r3, #4]
 8004388:	695b      	ldr	r3, [r3, #20]
 800438a:	330c      	adds	r3, #12
 800438c:	4618      	mov	r0, r3
 800438e:	f06f 0101 	mvn.w	r1, #1
 8004392:	f7ff fc85 	bl	8003ca0 <osalThreadResumeI>
      }
      if (usbp->epc[i]->out_state != NULL) {
 8004396:	9a01      	ldr	r2, [sp, #4]
 8004398:	9b03      	ldr	r3, [sp, #12]
 800439a:	3302      	adds	r3, #2
 800439c:	009b      	lsls	r3, r3, #2
 800439e:	4413      	add	r3, r2
 80043a0:	685b      	ldr	r3, [r3, #4]
 80043a2:	699b      	ldr	r3, [r3, #24]
 80043a4:	2b00      	cmp	r3, #0
 80043a6:	d00c      	beq.n	80043c2 <_usb_reset+0xa2>
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
 80043a8:	9a01      	ldr	r2, [sp, #4]
 80043aa:	9b03      	ldr	r3, [sp, #12]
 80043ac:	3302      	adds	r3, #2
 80043ae:	009b      	lsls	r3, r3, #2
 80043b0:	4413      	add	r3, r2
 80043b2:	685b      	ldr	r3, [r3, #4]
 80043b4:	699b      	ldr	r3, [r3, #24]
 80043b6:	330c      	adds	r3, #12
 80043b8:	4618      	mov	r0, r3
 80043ba:	f06f 0101 	mvn.w	r1, #1
 80043be:	f7ff fc6f 	bl	8003ca0 <osalThreadResumeI>
      }
      osalSysUnlockFromISR();
 80043c2:	f7ff fc55 	bl	8003c70 <osalSysUnlockFromISR>
    }
#endif
    usbp->epc[i] = NULL;
 80043c6:	9a01      	ldr	r2, [sp, #4]
 80043c8:	9b03      	ldr	r3, [sp, #12]
 80043ca:	3302      	adds	r3, #2
 80043cc:	009b      	lsls	r3, r3, #2
 80043ce:	4413      	add	r3, r2
 80043d0:	2200      	movs	r2, #0
 80043d2:	605a      	str	r2, [r3, #4]
  usbp->configuration = 0;
  usbp->transmitting  = 0;
  usbp->receiving     = 0;

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 80043d4:	9b03      	ldr	r3, [sp, #12]
 80043d6:	3301      	adds	r3, #1
 80043d8:	9303      	str	r3, [sp, #12]
 80043da:	9b03      	ldr	r3, [sp, #12]
 80043dc:	2b03      	cmp	r3, #3
 80043de:	d9ba      	bls.n	8004356 <_usb_reset+0x36>
#endif
    usbp->epc[i] = NULL;
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 80043e0:	9b01      	ldr	r3, [sp, #4]
 80043e2:	2200      	movs	r2, #0
 80043e4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Low level reset.*/
  usb_lld_reset(usbp);
 80043e8:	9801      	ldr	r0, [sp, #4]
 80043ea:	f7fd fdd9 	bl	8001fa0 <usb_lld_reset>

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 80043ee:	9b01      	ldr	r3, [sp, #4]
 80043f0:	685b      	ldr	r3, [r3, #4]
 80043f2:	681b      	ldr	r3, [r3, #0]
 80043f4:	2b00      	cmp	r3, #0
 80043f6:	d005      	beq.n	8004404 <_usb_reset+0xe4>
 80043f8:	9b01      	ldr	r3, [sp, #4]
 80043fa:	685b      	ldr	r3, [r3, #4]
 80043fc:	681b      	ldr	r3, [r3, #0]
 80043fe:	9801      	ldr	r0, [sp, #4]
 8004400:	2100      	movs	r1, #0
 8004402:	4798      	blx	r3
}
 8004404:	b005      	add	sp, #20
 8004406:	f85d fb04 	ldr.w	pc, [sp], #4
 800440a:	bf00      	nop
 800440c:	0000      	movs	r0, r0
	...

08004410 <_usb_suspend>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_suspend(USBDriver *usbp) {
 8004410:	b500      	push	{lr}
 8004412:	b085      	sub	sp, #20
 8004414:	9001      	str	r0, [sp, #4]

  /* State transition.*/
  usbp->state = USB_SUSPENDED;
 8004416:	9b01      	ldr	r3, [sp, #4]
 8004418:	2205      	movs	r2, #5
 800441a:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 800441c:	9b01      	ldr	r3, [sp, #4]
 800441e:	685b      	ldr	r3, [r3, #4]
 8004420:	681b      	ldr	r3, [r3, #0]
 8004422:	2b00      	cmp	r3, #0
 8004424:	d005      	beq.n	8004432 <_usb_suspend+0x22>
 8004426:	9b01      	ldr	r3, [sp, #4]
 8004428:	685b      	ldr	r3, [r3, #4]
 800442a:	681b      	ldr	r3, [r3, #0]
 800442c:	9801      	ldr	r0, [sp, #4]
 800442e:	2103      	movs	r1, #3
 8004430:	4798      	blx	r3
  /* Signaling the event to threads waiting on endpoints.*/
#if USB_USE_WAIT == TRUE
  {
    unsigned i;

    for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8004432:	2300      	movs	r3, #0
 8004434:	9303      	str	r3, [sp, #12]
 8004436:	e03a      	b.n	80044ae <_usb_suspend+0x9e>
      if (usbp->epc[i] != NULL) {
 8004438:	9a01      	ldr	r2, [sp, #4]
 800443a:	9b03      	ldr	r3, [sp, #12]
 800443c:	3302      	adds	r3, #2
 800443e:	009b      	lsls	r3, r3, #2
 8004440:	4413      	add	r3, r2
 8004442:	685b      	ldr	r3, [r3, #4]
 8004444:	2b00      	cmp	r3, #0
 8004446:	d02f      	beq.n	80044a8 <_usb_suspend+0x98>
        osalSysLockFromISR();
 8004448:	f7ff fc0a 	bl	8003c60 <osalSysLockFromISR>
        if (usbp->epc[i]->in_state != NULL) {
 800444c:	9a01      	ldr	r2, [sp, #4]
 800444e:	9b03      	ldr	r3, [sp, #12]
 8004450:	3302      	adds	r3, #2
 8004452:	009b      	lsls	r3, r3, #2
 8004454:	4413      	add	r3, r2
 8004456:	685b      	ldr	r3, [r3, #4]
 8004458:	695b      	ldr	r3, [r3, #20]
 800445a:	2b00      	cmp	r3, #0
 800445c:	d00c      	beq.n	8004478 <_usb_suspend+0x68>
          osalThreadResumeI(&usbp->epc[i]->in_state->thread, MSG_RESET);
 800445e:	9a01      	ldr	r2, [sp, #4]
 8004460:	9b03      	ldr	r3, [sp, #12]
 8004462:	3302      	adds	r3, #2
 8004464:	009b      	lsls	r3, r3, #2
 8004466:	4413      	add	r3, r2
 8004468:	685b      	ldr	r3, [r3, #4]
 800446a:	695b      	ldr	r3, [r3, #20]
 800446c:	330c      	adds	r3, #12
 800446e:	4618      	mov	r0, r3
 8004470:	f06f 0101 	mvn.w	r1, #1
 8004474:	f7ff fc14 	bl	8003ca0 <osalThreadResumeI>
        }
        if (usbp->epc[i]->out_state != NULL) {
 8004478:	9a01      	ldr	r2, [sp, #4]
 800447a:	9b03      	ldr	r3, [sp, #12]
 800447c:	3302      	adds	r3, #2
 800447e:	009b      	lsls	r3, r3, #2
 8004480:	4413      	add	r3, r2
 8004482:	685b      	ldr	r3, [r3, #4]
 8004484:	699b      	ldr	r3, [r3, #24]
 8004486:	2b00      	cmp	r3, #0
 8004488:	d00c      	beq.n	80044a4 <_usb_suspend+0x94>
          osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
 800448a:	9a01      	ldr	r2, [sp, #4]
 800448c:	9b03      	ldr	r3, [sp, #12]
 800448e:	3302      	adds	r3, #2
 8004490:	009b      	lsls	r3, r3, #2
 8004492:	4413      	add	r3, r2
 8004494:	685b      	ldr	r3, [r3, #4]
 8004496:	699b      	ldr	r3, [r3, #24]
 8004498:	330c      	adds	r3, #12
 800449a:	4618      	mov	r0, r3
 800449c:	f06f 0101 	mvn.w	r1, #1
 80044a0:	f7ff fbfe 	bl	8003ca0 <osalThreadResumeI>
        }
        osalSysUnlockFromISR();
 80044a4:	f7ff fbe4 	bl	8003c70 <osalSysUnlockFromISR>
  /* Signaling the event to threads waiting on endpoints.*/
#if USB_USE_WAIT == TRUE
  {
    unsigned i;

    for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 80044a8:	9b03      	ldr	r3, [sp, #12]
 80044aa:	3301      	adds	r3, #1
 80044ac:	9303      	str	r3, [sp, #12]
 80044ae:	9b03      	ldr	r3, [sp, #12]
 80044b0:	2b03      	cmp	r3, #3
 80044b2:	d9c1      	bls.n	8004438 <_usb_suspend+0x28>
        osalSysUnlockFromISR();
      }
    }
  }
#endif
}
 80044b4:	b005      	add	sp, #20
 80044b6:	f85d fb04 	ldr.w	pc, [sp], #4
 80044ba:	bf00      	nop
 80044bc:	0000      	movs	r0, r0
	...

080044c0 <_usb_wakeup>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {
 80044c0:	b500      	push	{lr}
 80044c2:	b083      	sub	sp, #12
 80044c4:	9001      	str	r0, [sp, #4]

  /* State transition.*/
  usbp->state = USB_ACTIVE;
 80044c6:	9b01      	ldr	r3, [sp, #4]
 80044c8:	2204      	movs	r2, #4
 80044ca:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 80044cc:	9b01      	ldr	r3, [sp, #4]
 80044ce:	685b      	ldr	r3, [r3, #4]
 80044d0:	681b      	ldr	r3, [r3, #0]
 80044d2:	2b00      	cmp	r3, #0
 80044d4:	d005      	beq.n	80044e2 <_usb_wakeup+0x22>
 80044d6:	9b01      	ldr	r3, [sp, #4]
 80044d8:	685b      	ldr	r3, [r3, #4]
 80044da:	681b      	ldr	r3, [r3, #0]
 80044dc:	9801      	ldr	r0, [sp, #4]
 80044de:	2104      	movs	r1, #4
 80044e0:	4798      	blx	r3
}
 80044e2:	b003      	add	sp, #12
 80044e4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080044f0 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 80044f0:	b500      	push	{lr}
 80044f2:	b085      	sub	sp, #20
 80044f4:	9001      	str	r0, [sp, #4]
 80044f6:	460b      	mov	r3, r1
 80044f8:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 80044fc:	9b01      	ldr	r3, [sp, #4]
 80044fe:	2200      	movs	r2, #0
 8004500:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  usbReadSetup(usbp, ep, usbp->setup);
 8004504:	9b01      	ldr	r3, [sp, #4]
 8004506:	3344      	adds	r3, #68	; 0x44
 8004508:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800450c:	9801      	ldr	r0, [sp, #4]
 800450e:	4611      	mov	r1, r2
 8004510:	461a      	mov	r2, r3
 8004512:	f7fd ff5d 	bl	80023d0 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8004516:	9b01      	ldr	r3, [sp, #4]
 8004518:	685b      	ldr	r3, [r3, #4]
 800451a:	689b      	ldr	r3, [r3, #8]
 800451c:	2b00      	cmp	r3, #0
 800451e:	d00a      	beq.n	8004536 <_usb_ep0setup+0x46>
      !(usbp->config->requests_hook_cb(usbp))) {
 8004520:	9b01      	ldr	r3, [sp, #4]
 8004522:	685b      	ldr	r3, [r3, #4]
 8004524:	689b      	ldr	r3, [r3, #8]
 8004526:	9801      	ldr	r0, [sp, #4]
 8004528:	4798      	blx	r3
 800452a:	4603      	mov	r3, r0
 800452c:	f083 0301 	eor.w	r3, r3, #1
 8004530:	b2db      	uxtb	r3, r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8004532:	2b00      	cmp	r3, #0
 8004534:	d027      	beq.n	8004586 <_usb_ep0setup+0x96>
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8004536:	9b01      	ldr	r3, [sp, #4]
 8004538:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800453c:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8004540:	2b00      	cmp	r3, #0
 8004542:	d108      	bne.n	8004556 <_usb_ep0setup+0x66>
        !default_handler(usbp)) {
 8004544:	9801      	ldr	r0, [sp, #4]
 8004546:	f7ff fbf3 	bl	8003d30 <default_handler>
 800454a:	4603      	mov	r3, r0
 800454c:	f083 0301 	eor.w	r3, r3, #1
 8004550:	b2db      	uxtb	r3, r3
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8004552:	2b00      	cmp	r3, #0
 8004554:	d017      	beq.n	8004586 <_usb_ep0setup+0x96>
        !default_handler(usbp)) {
    /*lint -restore*/
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
 8004556:	9801      	ldr	r0, [sp, #4]
 8004558:	2100      	movs	r1, #0
 800455a:	f7fe f8c1 	bl	80026e0 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 800455e:	9801      	ldr	r0, [sp, #4]
 8004560:	2100      	movs	r1, #0
 8004562:	f7fe f89d 	bl	80026a0 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8004566:	9b01      	ldr	r3, [sp, #4]
 8004568:	685b      	ldr	r3, [r3, #4]
 800456a:	681b      	ldr	r3, [r3, #0]
 800456c:	2b00      	cmp	r3, #0
 800456e:	d005      	beq.n	800457c <_usb_ep0setup+0x8c>
 8004570:	9b01      	ldr	r3, [sp, #4]
 8004572:	685b      	ldr	r3, [r3, #4]
 8004574:	681b      	ldr	r3, [r3, #0]
 8004576:	9801      	ldr	r0, [sp, #4]
 8004578:	2105      	movs	r1, #5
 800457a:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 800457c:	9b01      	ldr	r3, [sp, #4]
 800457e:	2206      	movs	r2, #6
 8004580:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
 8004584:	e05c      	b.n	8004640 <_usb_ep0setup+0x150>
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 8004586:	9b01      	ldr	r3, [sp, #4]
 8004588:	334a      	adds	r3, #74	; 0x4a
 800458a:	4618      	mov	r0, r3
 800458c:	f7ff fb98 	bl	8003cc0 <get_hword>
 8004590:	4603      	mov	r3, r0
 8004592:	9303      	str	r3, [sp, #12]
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 8004594:	9b01      	ldr	r3, [sp, #4]
 8004596:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8004598:	9b03      	ldr	r3, [sp, #12]
 800459a:	429a      	cmp	r2, r3
 800459c:	d902      	bls.n	80045a4 <_usb_ep0setup+0xb4>
    usbp->ep0n = max;
 800459e:	9b01      	ldr	r3, [sp, #4]
 80045a0:	9a03      	ldr	r2, [sp, #12]
 80045a2:	63da      	str	r2, [r3, #60]	; 0x3c
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80045a4:	9b01      	ldr	r3, [sp, #4]
 80045a6:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 80045aa:	b2db      	uxtb	r3, r3
 80045ac:	b25b      	sxtb	r3, r3
 80045ae:	2b00      	cmp	r3, #0
 80045b0:	da23      	bge.n	80045fa <_usb_ep0setup+0x10a>
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 80045b2:	9b01      	ldr	r3, [sp, #4]
 80045b4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80045b6:	2b00      	cmp	r3, #0
 80045b8:	d010      	beq.n	80045dc <_usb_ep0setup+0xec>
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 80045ba:	9b01      	ldr	r3, [sp, #4]
 80045bc:	2201      	movs	r2, #1
 80045be:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      osalSysLockFromISR();
 80045c2:	f7ff fb4d 	bl	8003c60 <osalSysLockFromISR>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 80045c6:	9b01      	ldr	r3, [sp, #4]
 80045c8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80045ca:	9b01      	ldr	r3, [sp, #4]
 80045cc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80045ce:	9801      	ldr	r0, [sp, #4]
 80045d0:	2100      	movs	r1, #0
 80045d2:	f7ff fe3d 	bl	8004250 <usbStartTransmitI>
      osalSysUnlockFromISR();
 80045d6:	f7ff fb4b 	bl	8003c70 <osalSysUnlockFromISR>
 80045da:	e031      	b.n	8004640 <_usb_ep0setup+0x150>
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 80045dc:	9b01      	ldr	r3, [sp, #4]
 80045de:	2203      	movs	r2, #3
 80045e0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 80045e4:	f7ff fb3c 	bl	8003c60 <osalSysLockFromISR>
      usbStartReceiveI(usbp, 0, NULL, 0);
 80045e8:	9801      	ldr	r0, [sp, #4]
 80045ea:	2100      	movs	r1, #0
 80045ec:	2200      	movs	r2, #0
 80045ee:	2300      	movs	r3, #0
 80045f0:	f7ff fdf6 	bl	80041e0 <usbStartReceiveI>
      osalSysUnlockFromISR();
 80045f4:	f7ff fb3c 	bl	8003c70 <osalSysUnlockFromISR>
 80045f8:	e022      	b.n	8004640 <_usb_ep0setup+0x150>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 80045fa:	9b01      	ldr	r3, [sp, #4]
 80045fc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80045fe:	2b00      	cmp	r3, #0
 8004600:	d010      	beq.n	8004624 <_usb_ep0setup+0x134>
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 8004602:	9b01      	ldr	r3, [sp, #4]
 8004604:	2204      	movs	r2, #4
 8004606:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      osalSysLockFromISR();
 800460a:	f7ff fb29 	bl	8003c60 <osalSysLockFromISR>
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 800460e:	9b01      	ldr	r3, [sp, #4]
 8004610:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8004612:	9b01      	ldr	r3, [sp, #4]
 8004614:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004616:	9801      	ldr	r0, [sp, #4]
 8004618:	2100      	movs	r1, #0
 800461a:	f7ff fde1 	bl	80041e0 <usbStartReceiveI>
      osalSysUnlockFromISR();
 800461e:	f7ff fb27 	bl	8003c70 <osalSysUnlockFromISR>
 8004622:	e00d      	b.n	8004640 <_usb_ep0setup+0x150>
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 8004624:	9b01      	ldr	r3, [sp, #4]
 8004626:	2205      	movs	r2, #5
 8004628:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 800462c:	f7ff fb18 	bl	8003c60 <osalSysLockFromISR>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8004630:	9801      	ldr	r0, [sp, #4]
 8004632:	2100      	movs	r1, #0
 8004634:	2200      	movs	r2, #0
 8004636:	2300      	movs	r3, #0
 8004638:	f7ff fe0a 	bl	8004250 <usbStartTransmitI>
      osalSysUnlockFromISR();
 800463c:	f7ff fb18 	bl	8003c70 <osalSysUnlockFromISR>
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
 8004640:	b005      	add	sp, #20
 8004642:	f85d fb04 	ldr.w	pc, [sp], #4
 8004646:	bf00      	nop
	...

08004650 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8004650:	b500      	push	{lr}
 8004652:	b085      	sub	sp, #20
 8004654:	9001      	str	r0, [sp, #4]
 8004656:	460b      	mov	r3, r1
 8004658:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 800465c:	9b01      	ldr	r3, [sp, #4]
 800465e:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8004662:	2b06      	cmp	r3, #6
 8004664:	d86a      	bhi.n	800473c <_usb_ep0in+0xec>
 8004666:	a201      	add	r2, pc, #4	; (adr r2, 800466c <_usb_ep0in+0x1c>)
 8004668:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800466c:	0800470f 	.word	0x0800470f
 8004670:	08004689 	.word	0x08004689
 8004674:	080046d7 	.word	0x080046d7
 8004678:	0800470f 	.word	0x0800470f
 800467c:	0800470f 	.word	0x0800470f
 8004680:	080046f5 	.word	0x080046f5
 8004684:	0800470f 	.word	0x0800470f
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 8004688:	9b01      	ldr	r3, [sp, #4]
 800468a:	334a      	adds	r3, #74	; 0x4a
 800468c:	4618      	mov	r0, r3
 800468e:	f7ff fb17 	bl	8003cc0 <get_hword>
 8004692:	4603      	mov	r3, r0
 8004694:	9303      	str	r3, [sp, #12]
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8004696:	9b01      	ldr	r3, [sp, #4]
 8004698:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800469a:	9b03      	ldr	r3, [sp, #12]
 800469c:	429a      	cmp	r2, r3
 800469e:	d21a      	bcs.n	80046d6 <_usb_ep0in+0x86>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 80046a0:	9b01      	ldr	r3, [sp, #4]
 80046a2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80046a4:	9a01      	ldr	r2, [sp, #4]
 80046a6:	68d2      	ldr	r2, [r2, #12]
 80046a8:	8a12      	ldrh	r2, [r2, #16]
 80046aa:	fbb3 f1f2 	udiv	r1, r3, r2
 80046ae:	fb02 f201 	mul.w	r2, r2, r1
 80046b2:	1a9b      	subs	r3, r3, r2
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 80046b4:	2b00      	cmp	r3, #0
 80046b6:	d10e      	bne.n	80046d6 <_usb_ep0in+0x86>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      osalSysLockFromISR();
 80046b8:	f7ff fad2 	bl	8003c60 <osalSysLockFromISR>
      usbStartTransmitI(usbp, 0, NULL, 0);
 80046bc:	9801      	ldr	r0, [sp, #4]
 80046be:	2100      	movs	r1, #0
 80046c0:	2200      	movs	r2, #0
 80046c2:	2300      	movs	r3, #0
 80046c4:	f7ff fdc4 	bl	8004250 <usbStartTransmitI>
      osalSysUnlockFromISR();
 80046c8:	f7ff fad2 	bl	8003c70 <osalSysUnlockFromISR>
      usbp->ep0state = USB_EP0_WAITING_TX0;
 80046cc:	9b01      	ldr	r3, [sp, #4]
 80046ce:	2202      	movs	r2, #2
 80046d0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
 80046d4:	e032      	b.n	800473c <_usb_ep0in+0xec>
      return;
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 80046d6:	9b01      	ldr	r3, [sp, #4]
 80046d8:	2203      	movs	r2, #3
 80046da:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 80046de:	f7ff fabf 	bl	8003c60 <osalSysLockFromISR>
    usbStartReceiveI(usbp, 0, NULL, 0);
 80046e2:	9801      	ldr	r0, [sp, #4]
 80046e4:	2100      	movs	r1, #0
 80046e6:	2200      	movs	r2, #0
 80046e8:	2300      	movs	r3, #0
 80046ea:	f7ff fd79 	bl	80041e0 <usbStartReceiveI>
    osalSysUnlockFromISR();
 80046ee:	f7ff fabf 	bl	8003c70 <osalSysUnlockFromISR>
 80046f2:	e023      	b.n	800473c <_usb_ep0in+0xec>
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 80046f4:	9b01      	ldr	r3, [sp, #4]
 80046f6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80046f8:	2b00      	cmp	r3, #0
 80046fa:	d003      	beq.n	8004704 <_usb_ep0in+0xb4>
      usbp->ep0endcb(usbp);
 80046fc:	9b01      	ldr	r3, [sp, #4]
 80046fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004700:	9801      	ldr	r0, [sp, #4]
 8004702:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8004704:	9b01      	ldr	r3, [sp, #4]
 8004706:	2200      	movs	r2, #0
 8004708:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
 800470c:	e016      	b.n	800473c <_usb_ep0in+0xec>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 800470e:	9801      	ldr	r0, [sp, #4]
 8004710:	2100      	movs	r1, #0
 8004712:	f7fd ffe5 	bl	80026e0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8004716:	9801      	ldr	r0, [sp, #4]
 8004718:	2100      	movs	r1, #0
 800471a:	f7fd ffc1 	bl	80026a0 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800471e:	9b01      	ldr	r3, [sp, #4]
 8004720:	685b      	ldr	r3, [r3, #4]
 8004722:	681b      	ldr	r3, [r3, #0]
 8004724:	2b00      	cmp	r3, #0
 8004726:	d005      	beq.n	8004734 <_usb_ep0in+0xe4>
 8004728:	9b01      	ldr	r3, [sp, #4]
 800472a:	685b      	ldr	r3, [r3, #4]
 800472c:	681b      	ldr	r3, [r3, #0]
 800472e:	9801      	ldr	r0, [sp, #4]
 8004730:	2105      	movs	r1, #5
 8004732:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8004734:	9b01      	ldr	r3, [sp, #4]
 8004736:	2206      	movs	r2, #6
 8004738:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 800473c:	b005      	add	sp, #20
 800473e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004742:	bf00      	nop
	...

08004750 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8004750:	b500      	push	{lr}
 8004752:	b083      	sub	sp, #12
 8004754:	9001      	str	r0, [sp, #4]
 8004756:	460b      	mov	r3, r1
 8004758:	f88d 3003 	strb.w	r3, [sp, #3]

  (void)ep;
  switch (usbp->ep0state) {
 800475c:	9b01      	ldr	r3, [sp, #4]
 800475e:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8004762:	2b06      	cmp	r3, #6
 8004764:	d849      	bhi.n	80047fa <_usb_ep0out+0xaa>
 8004766:	a201      	add	r2, pc, #4	; (adr r2, 800476c <_usb_ep0out+0x1c>)
 8004768:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800476c:	080047cd 	.word	0x080047cd
 8004770:	080047cd 	.word	0x080047cd
 8004774:	080047cd 	.word	0x080047cd
 8004778:	080047a7 	.word	0x080047a7
 800477c:	08004789 	.word	0x08004789
 8004780:	080047cd 	.word	0x080047cd
 8004784:	080047cd 	.word	0x080047cd
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 8004788:	9b01      	ldr	r3, [sp, #4]
 800478a:	2205      	movs	r2, #5
 800478c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 8004790:	f7ff fa66 	bl	8003c60 <osalSysLockFromISR>
    usbStartTransmitI(usbp, 0, NULL, 0);
 8004794:	9801      	ldr	r0, [sp, #4]
 8004796:	2100      	movs	r1, #0
 8004798:	2200      	movs	r2, #0
 800479a:	2300      	movs	r3, #0
 800479c:	f7ff fd58 	bl	8004250 <usbStartTransmitI>
    osalSysUnlockFromISR();
 80047a0:	f7ff fa66 	bl	8003c70 <osalSysUnlockFromISR>
 80047a4:	e029      	b.n	80047fa <_usb_ep0out+0xaa>
    return;
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 80047a6:	9b01      	ldr	r3, [sp, #4]
 80047a8:	68db      	ldr	r3, [r3, #12]
 80047aa:	699b      	ldr	r3, [r3, #24]
 80047ac:	685b      	ldr	r3, [r3, #4]
 80047ae:	2b00      	cmp	r3, #0
 80047b0:	d123      	bne.n	80047fa <_usb_ep0out+0xaa>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 80047b2:	9b01      	ldr	r3, [sp, #4]
 80047b4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80047b6:	2b00      	cmp	r3, #0
 80047b8:	d003      	beq.n	80047c2 <_usb_ep0out+0x72>
      usbp->ep0endcb(usbp);
 80047ba:	9b01      	ldr	r3, [sp, #4]
 80047bc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80047be:	9801      	ldr	r0, [sp, #4]
 80047c0:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 80047c2:	9b01      	ldr	r3, [sp, #4]
 80047c4:	2200      	movs	r2, #0
 80047c6:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
 80047ca:	e016      	b.n	80047fa <_usb_ep0out+0xaa>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 80047cc:	9801      	ldr	r0, [sp, #4]
 80047ce:	2100      	movs	r1, #0
 80047d0:	f7fd ff86 	bl	80026e0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 80047d4:	9801      	ldr	r0, [sp, #4]
 80047d6:	2100      	movs	r1, #0
 80047d8:	f7fd ff62 	bl	80026a0 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80047dc:	9b01      	ldr	r3, [sp, #4]
 80047de:	685b      	ldr	r3, [r3, #4]
 80047e0:	681b      	ldr	r3, [r3, #0]
 80047e2:	2b00      	cmp	r3, #0
 80047e4:	d005      	beq.n	80047f2 <_usb_ep0out+0xa2>
 80047e6:	9b01      	ldr	r3, [sp, #4]
 80047e8:	685b      	ldr	r3, [r3, #4]
 80047ea:	681b      	ldr	r3, [r3, #0]
 80047ec:	9801      	ldr	r0, [sp, #4]
 80047ee:	2105      	movs	r1, #5
 80047f0:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 80047f2:	9b01      	ldr	r3, [sp, #4]
 80047f4:	2206      	movs	r2, #6
 80047f6:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 80047fa:	b003      	add	sp, #12
 80047fc:	f85d fb04 	ldr.w	pc, [sp], #4

08004800 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8004800:	b082      	sub	sp, #8
 8004802:	9001      	str	r0, [sp, #4]
 8004804:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8004806:	4a12      	ldr	r2, [pc, #72]	; (8004850 <nvicEnableVector+0x50>)
 8004808:	9b00      	ldr	r3, [sp, #0]
 800480a:	b2db      	uxtb	r3, r3
 800480c:	011b      	lsls	r3, r3, #4
 800480e:	b2d9      	uxtb	r1, r3
 8004810:	9b01      	ldr	r3, [sp, #4]
 8004812:	4413      	add	r3, r2
 8004814:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8004818:	460a      	mov	r2, r1
 800481a:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800481c:	490c      	ldr	r1, [pc, #48]	; (8004850 <nvicEnableVector+0x50>)
 800481e:	9b01      	ldr	r3, [sp, #4]
 8004820:	095b      	lsrs	r3, r3, #5
 8004822:	9a01      	ldr	r2, [sp, #4]
 8004824:	f002 021f 	and.w	r2, r2, #31
 8004828:	2001      	movs	r0, #1
 800482a:	fa00 f202 	lsl.w	r2, r0, r2
 800482e:	3360      	adds	r3, #96	; 0x60
 8004830:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8004834:	4906      	ldr	r1, [pc, #24]	; (8004850 <nvicEnableVector+0x50>)
 8004836:	9b01      	ldr	r3, [sp, #4]
 8004838:	095b      	lsrs	r3, r3, #5
 800483a:	9a01      	ldr	r2, [sp, #4]
 800483c:	f002 021f 	and.w	r2, r2, #31
 8004840:	2001      	movs	r0, #1
 8004842:	fa00 f202 	lsl.w	r2, r0, r2
 8004846:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800484a:	b002      	add	sp, #8
 800484c:	4770      	bx	lr
 800484e:	bf00      	nop
 8004850:	e000e100 	.word	0xe000e100
	...

08004860 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8004860:	4a0d      	ldr	r2, [pc, #52]	; (8004898 <hal_lld_backup_domain_init+0x38>)
 8004862:	4b0d      	ldr	r3, [pc, #52]	; (8004898 <hal_lld_backup_domain_init+0x38>)
 8004864:	681b      	ldr	r3, [r3, #0]
 8004866:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800486a:	6013      	str	r3, [r2, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800486c:	4b0b      	ldr	r3, [pc, #44]	; (800489c <hal_lld_backup_domain_init+0x3c>)
 800486e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004870:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8004874:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8004878:	d006      	beq.n	8004888 <hal_lld_backup_domain_init+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 800487a:	4b08      	ldr	r3, [pc, #32]	; (800489c <hal_lld_backup_domain_init+0x3c>)
 800487c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8004880:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8004882:	4b06      	ldr	r3, [pc, #24]	; (800489c <hal_lld_backup_domain_init+0x3c>)
 8004884:	2200      	movs	r2, #0
 8004886:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8004888:	4a03      	ldr	r2, [pc, #12]	; (8004898 <hal_lld_backup_domain_init+0x38>)
 800488a:	4b03      	ldr	r3, [pc, #12]	; (8004898 <hal_lld_backup_domain_init+0x38>)
 800488c:	685b      	ldr	r3, [r3, #4]
 800488e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8004892:	6053      	str	r3, [r2, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
 8004894:	4770      	bx	lr
 8004896:	bf00      	nop
 8004898:	40007000 	.word	0x40007000
 800489c:	40023800 	.word	0x40023800

080048a0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80048a0:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 80048a2:	4b17      	ldr	r3, [pc, #92]	; (8004900 <hal_lld_init+0x60>)
 80048a4:	691b      	ldr	r3, [r3, #16]
 80048a6:	4b16      	ldr	r3, [pc, #88]	; (8004900 <hal_lld_init+0x60>)
 80048a8:	f04f 32ff 	mov.w	r2, #4294967295
 80048ac:	611a      	str	r2, [r3, #16]
 80048ae:	4b14      	ldr	r3, [pc, #80]	; (8004900 <hal_lld_init+0x60>)
 80048b0:	2200      	movs	r2, #0
 80048b2:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 80048b4:	4b12      	ldr	r3, [pc, #72]	; (8004900 <hal_lld_init+0x60>)
 80048b6:	695b      	ldr	r3, [r3, #20]
 80048b8:	4b11      	ldr	r3, [pc, #68]	; (8004900 <hal_lld_init+0x60>)
 80048ba:	f04f 32ff 	mov.w	r2, #4294967295
 80048be:	615a      	str	r2, [r3, #20]
 80048c0:	4b0f      	ldr	r3, [pc, #60]	; (8004900 <hal_lld_init+0x60>)
 80048c2:	2200      	movs	r2, #0
 80048c4:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80048c6:	4a0e      	ldr	r2, [pc, #56]	; (8004900 <hal_lld_init+0x60>)
 80048c8:	4b0d      	ldr	r3, [pc, #52]	; (8004900 <hal_lld_init+0x60>)
 80048ca:	6a1b      	ldr	r3, [r3, #32]
 80048cc:	f063 5380 	orn	r3, r3, #268435456	; 0x10000000
 80048d0:	6213      	str	r3, [r2, #32]
 80048d2:	4b0b      	ldr	r3, [pc, #44]	; (8004900 <hal_lld_init+0x60>)
 80048d4:	2200      	movs	r2, #0
 80048d6:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 80048d8:	4b09      	ldr	r3, [pc, #36]	; (8004900 <hal_lld_init+0x60>)
 80048da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80048dc:	4b08      	ldr	r3, [pc, #32]	; (8004900 <hal_lld_init+0x60>)
 80048de:	f04f 32ff 	mov.w	r2, #4294967295
 80048e2:	625a      	str	r2, [r3, #36]	; 0x24
 80048e4:	4b06      	ldr	r3, [pc, #24]	; (8004900 <hal_lld_init+0x60>)
 80048e6:	2200      	movs	r2, #0
 80048e8:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80048ea:	4a05      	ldr	r2, [pc, #20]	; (8004900 <hal_lld_init+0x60>)
 80048ec:	4b04      	ldr	r3, [pc, #16]	; (8004900 <hal_lld_init+0x60>)
 80048ee:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80048f0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80048f4:	6413      	str	r3, [r2, #64]	; 0x40

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 80048f6:	f7ff ffb3 	bl	8004860 <hal_lld_backup_domain_init>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 80048fa:	f7fe f8d1 	bl	8002aa0 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 80048fe:	bd08      	pop	{r3, pc}
 8004900:	40023800 	.word	0x40023800
	...

08004910 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8004910:	4b3c      	ldr	r3, [pc, #240]	; (8004a04 <stm32_clock_init+0xf4>)
 8004912:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004916:	641a      	str	r2, [r3, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8004918:	4b3b      	ldr	r3, [pc, #236]	; (8004a08 <stm32_clock_init+0xf8>)
 800491a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 800491e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8004920:	4a38      	ldr	r2, [pc, #224]	; (8004a04 <stm32_clock_init+0xf4>)
 8004922:	4b38      	ldr	r3, [pc, #224]	; (8004a04 <stm32_clock_init+0xf4>)
 8004924:	681b      	ldr	r3, [r3, #0]
 8004926:	f043 0301 	orr.w	r3, r3, #1
 800492a:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800492c:	4b35      	ldr	r3, [pc, #212]	; (8004a04 <stm32_clock_init+0xf4>)
 800492e:	681b      	ldr	r3, [r3, #0]
 8004930:	f003 0302 	and.w	r3, r3, #2
 8004934:	2b00      	cmp	r3, #0
 8004936:	d0f9      	beq.n	800492c <stm32_clock_init+0x1c>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8004938:	4a32      	ldr	r2, [pc, #200]	; (8004a04 <stm32_clock_init+0xf4>)
 800493a:	4b32      	ldr	r3, [pc, #200]	; (8004a04 <stm32_clock_init+0xf4>)
 800493c:	689b      	ldr	r3, [r3, #8]
 800493e:	f023 0303 	bic.w	r3, r3, #3
 8004942:	6093      	str	r3, [r2, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8004944:	4a2f      	ldr	r2, [pc, #188]	; (8004a04 <stm32_clock_init+0xf4>)
 8004946:	4b2f      	ldr	r3, [pc, #188]	; (8004a04 <stm32_clock_init+0xf4>)
 8004948:	689b      	ldr	r3, [r3, #8]
 800494a:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800494c:	4b2d      	ldr	r3, [pc, #180]	; (8004a04 <stm32_clock_init+0xf4>)
 800494e:	689b      	ldr	r3, [r3, #8]
 8004950:	f003 030c 	and.w	r3, r3, #12
 8004954:	2b00      	cmp	r3, #0
 8004956:	d1f9      	bne.n	800494c <stm32_clock_init+0x3c>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8004958:	4a2a      	ldr	r2, [pc, #168]	; (8004a04 <stm32_clock_init+0xf4>)
 800495a:	4b2a      	ldr	r3, [pc, #168]	; (8004a04 <stm32_clock_init+0xf4>)
 800495c:	681b      	ldr	r3, [r3, #0]
 800495e:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 8004962:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8004964:	4b27      	ldr	r3, [pc, #156]	; (8004a04 <stm32_clock_init+0xf4>)
 8004966:	2200      	movs	r2, #0
 8004968:	609a      	str	r2, [r3, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 800496a:	4a26      	ldr	r2, [pc, #152]	; (8004a04 <stm32_clock_init+0xf4>)
 800496c:	4b25      	ldr	r3, [pc, #148]	; (8004a04 <stm32_clock_init+0xf4>)
 800496e:	681b      	ldr	r3, [r3, #0]
 8004970:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004974:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8004976:	4b23      	ldr	r3, [pc, #140]	; (8004a04 <stm32_clock_init+0xf4>)
 8004978:	681b      	ldr	r3, [r3, #0]
 800497a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800497e:	2b00      	cmp	r3, #0
 8004980:	d0f9      	beq.n	8004976 <stm32_clock_init+0x66>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8004982:	4a20      	ldr	r2, [pc, #128]	; (8004a04 <stm32_clock_init+0xf4>)
 8004984:	4b1f      	ldr	r3, [pc, #124]	; (8004a04 <stm32_clock_init+0xf4>)
 8004986:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8004988:	f043 0301 	orr.w	r3, r3, #1
 800498c:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800498e:	4b1d      	ldr	r3, [pc, #116]	; (8004a04 <stm32_clock_init+0xf4>)
 8004990:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8004992:	f003 0302 	and.w	r3, r3, #2
 8004996:	2b00      	cmp	r3, #0
 8004998:	d0f9      	beq.n	800498e <stm32_clock_init+0x7e>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 800499a:	4b1a      	ldr	r3, [pc, #104]	; (8004a04 <stm32_clock_init+0xf4>)
 800499c:	4a1b      	ldr	r2, [pc, #108]	; (8004a0c <stm32_clock_init+0xfc>)
 800499e:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 80049a0:	4a18      	ldr	r2, [pc, #96]	; (8004a04 <stm32_clock_init+0xf4>)
 80049a2:	4b18      	ldr	r3, [pc, #96]	; (8004a04 <stm32_clock_init+0xf4>)
 80049a4:	681b      	ldr	r3, [r3, #0]
 80049a6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80049aa:	6013      	str	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 80049ac:	4b16      	ldr	r3, [pc, #88]	; (8004a08 <stm32_clock_init+0xf8>)
 80049ae:	685b      	ldr	r3, [r3, #4]
 80049b0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80049b4:	2b00      	cmp	r3, #0
 80049b6:	d0f9      	beq.n	80049ac <stm32_clock_init+0x9c>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80049b8:	4b12      	ldr	r3, [pc, #72]	; (8004a04 <stm32_clock_init+0xf4>)
 80049ba:	681b      	ldr	r3, [r3, #0]
 80049bc:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80049c0:	2b00      	cmp	r3, #0
 80049c2:	d0f9      	beq.n	80049b8 <stm32_clock_init+0xa8>
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 80049c4:	4b0f      	ldr	r3, [pc, #60]	; (8004a04 <stm32_clock_init+0xf4>)
 80049c6:	4a12      	ldr	r2, [pc, #72]	; (8004a10 <stm32_clock_init+0x100>)
 80049c8:	609a      	str	r2, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 80049ca:	4b12      	ldr	r3, [pc, #72]	; (8004a14 <stm32_clock_init+0x104>)
 80049cc:	f240 7205 	movw	r2, #1797	; 0x705
 80049d0:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 80049d2:	4a0c      	ldr	r2, [pc, #48]	; (8004a04 <stm32_clock_init+0xf4>)
 80049d4:	4b0b      	ldr	r3, [pc, #44]	; (8004a04 <stm32_clock_init+0xf4>)
 80049d6:	689b      	ldr	r3, [r3, #8]
 80049d8:	f043 0302 	orr.w	r3, r3, #2
 80049dc:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80049de:	4b09      	ldr	r3, [pc, #36]	; (8004a04 <stm32_clock_init+0xf4>)
 80049e0:	689b      	ldr	r3, [r3, #8]
 80049e2:	f003 030c 	and.w	r3, r3, #12
 80049e6:	2b08      	cmp	r3, #8
 80049e8:	d1f9      	bne.n	80049de <stm32_clock_init+0xce>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80049ea:	4a06      	ldr	r2, [pc, #24]	; (8004a04 <stm32_clock_init+0xf4>)
 80049ec:	4b05      	ldr	r3, [pc, #20]	; (8004a04 <stm32_clock_init+0xf4>)
 80049ee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80049f0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80049f4:	6453      	str	r3, [r2, #68]	; 0x44
 80049f6:	4a03      	ldr	r2, [pc, #12]	; (8004a04 <stm32_clock_init+0xf4>)
 80049f8:	4b02      	ldr	r3, [pc, #8]	; (8004a04 <stm32_clock_init+0xf4>)
 80049fa:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80049fc:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8004a00:	6653      	str	r3, [r2, #100]	; 0x64
}
 8004a02:	4770      	bx	lr
 8004a04:	40023800 	.word	0x40023800
 8004a08:	40007000 	.word	0x40007000
 8004a0c:	07405408 	.word	0x07405408
 8004a10:	38889400 	.word	0x38889400
 8004a14:	40023c00 	.word	0x40023c00
	...

08004a20 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8004a20:	b500      	push	{lr}
 8004a22:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8004a24:	4b0b      	ldr	r3, [pc, #44]	; (8004a54 <Vector6C+0x34>)
 8004a26:	681b      	ldr	r3, [r3, #0]
 8004a28:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8004a2c:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 0U;
 8004a2e:	4a09      	ldr	r2, [pc, #36]	; (8004a54 <Vector6C+0x34>)
 8004a30:	9b01      	ldr	r3, [sp, #4]
 8004a32:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[0].dma_func)
 8004a34:	4b08      	ldr	r3, [pc, #32]	; (8004a58 <Vector6C+0x38>)
 8004a36:	681b      	ldr	r3, [r3, #0]
 8004a38:	2b00      	cmp	r3, #0
 8004a3a:	d006      	beq.n	8004a4a <Vector6C+0x2a>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 8004a3c:	4b06      	ldr	r3, [pc, #24]	; (8004a58 <Vector6C+0x38>)
 8004a3e:	681b      	ldr	r3, [r3, #0]
 8004a40:	4a05      	ldr	r2, [pc, #20]	; (8004a58 <Vector6C+0x38>)
 8004a42:	6852      	ldr	r2, [r2, #4]
 8004a44:	4610      	mov	r0, r2
 8004a46:	9901      	ldr	r1, [sp, #4]
 8004a48:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8004a4a:	f000 f8e1 	bl	8004c10 <_port_irq_epilogue>
}
 8004a4e:	b003      	add	sp, #12
 8004a50:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a54:	40026000 	.word	0x40026000
 8004a58:	20000984 	.word	0x20000984
 8004a5c:	00000000 	.word	0x00000000

08004a60 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8004a60:	b500      	push	{lr}
 8004a62:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8004a64:	4b0c      	ldr	r3, [pc, #48]	; (8004a98 <Vector70+0x38>)
 8004a66:	681b      	ldr	r3, [r3, #0]
 8004a68:	099b      	lsrs	r3, r3, #6
 8004a6a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8004a6e:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 6U;
 8004a70:	4a09      	ldr	r2, [pc, #36]	; (8004a98 <Vector70+0x38>)
 8004a72:	9b01      	ldr	r3, [sp, #4]
 8004a74:	019b      	lsls	r3, r3, #6
 8004a76:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[1].dma_func)
 8004a78:	4b08      	ldr	r3, [pc, #32]	; (8004a9c <Vector70+0x3c>)
 8004a7a:	689b      	ldr	r3, [r3, #8]
 8004a7c:	2b00      	cmp	r3, #0
 8004a7e:	d006      	beq.n	8004a8e <Vector70+0x2e>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8004a80:	4b06      	ldr	r3, [pc, #24]	; (8004a9c <Vector70+0x3c>)
 8004a82:	689b      	ldr	r3, [r3, #8]
 8004a84:	4a05      	ldr	r2, [pc, #20]	; (8004a9c <Vector70+0x3c>)
 8004a86:	68d2      	ldr	r2, [r2, #12]
 8004a88:	4610      	mov	r0, r2
 8004a8a:	9901      	ldr	r1, [sp, #4]
 8004a8c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8004a8e:	f000 f8bf 	bl	8004c10 <_port_irq_epilogue>
}
 8004a92:	b003      	add	sp, #12
 8004a94:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a98:	40026000 	.word	0x40026000
 8004a9c:	20000984 	.word	0x20000984

08004aa0 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8004aa0:	b500      	push	{lr}
 8004aa2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8004aa4:	4b0c      	ldr	r3, [pc, #48]	; (8004ad8 <Vector74+0x38>)
 8004aa6:	681b      	ldr	r3, [r3, #0]
 8004aa8:	0c1b      	lsrs	r3, r3, #16
 8004aaa:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8004aae:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 16U;
 8004ab0:	4a09      	ldr	r2, [pc, #36]	; (8004ad8 <Vector74+0x38>)
 8004ab2:	9b01      	ldr	r3, [sp, #4]
 8004ab4:	041b      	lsls	r3, r3, #16
 8004ab6:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[2].dma_func)
 8004ab8:	4b08      	ldr	r3, [pc, #32]	; (8004adc <Vector74+0x3c>)
 8004aba:	691b      	ldr	r3, [r3, #16]
 8004abc:	2b00      	cmp	r3, #0
 8004abe:	d006      	beq.n	8004ace <Vector74+0x2e>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8004ac0:	4b06      	ldr	r3, [pc, #24]	; (8004adc <Vector74+0x3c>)
 8004ac2:	691b      	ldr	r3, [r3, #16]
 8004ac4:	4a05      	ldr	r2, [pc, #20]	; (8004adc <Vector74+0x3c>)
 8004ac6:	6952      	ldr	r2, [r2, #20]
 8004ac8:	4610      	mov	r0, r2
 8004aca:	9901      	ldr	r1, [sp, #4]
 8004acc:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8004ace:	f000 f89f 	bl	8004c10 <_port_irq_epilogue>
}
 8004ad2:	b003      	add	sp, #12
 8004ad4:	f85d fb04 	ldr.w	pc, [sp], #4
 8004ad8:	40026000 	.word	0x40026000
 8004adc:	20000984 	.word	0x20000984

08004ae0 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8004ae0:	b500      	push	{lr}
 8004ae2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8004ae4:	4b0c      	ldr	r3, [pc, #48]	; (8004b18 <Vector78+0x38>)
 8004ae6:	681b      	ldr	r3, [r3, #0]
 8004ae8:	0d9b      	lsrs	r3, r3, #22
 8004aea:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8004aee:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 22U;
 8004af0:	4a09      	ldr	r2, [pc, #36]	; (8004b18 <Vector78+0x38>)
 8004af2:	9b01      	ldr	r3, [sp, #4]
 8004af4:	059b      	lsls	r3, r3, #22
 8004af6:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[3].dma_func)
 8004af8:	4b08      	ldr	r3, [pc, #32]	; (8004b1c <Vector78+0x3c>)
 8004afa:	699b      	ldr	r3, [r3, #24]
 8004afc:	2b00      	cmp	r3, #0
 8004afe:	d006      	beq.n	8004b0e <Vector78+0x2e>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 8004b00:	4b06      	ldr	r3, [pc, #24]	; (8004b1c <Vector78+0x3c>)
 8004b02:	699b      	ldr	r3, [r3, #24]
 8004b04:	4a05      	ldr	r2, [pc, #20]	; (8004b1c <Vector78+0x3c>)
 8004b06:	69d2      	ldr	r2, [r2, #28]
 8004b08:	4610      	mov	r0, r2
 8004b0a:	9901      	ldr	r1, [sp, #4]
 8004b0c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8004b0e:	f000 f87f 	bl	8004c10 <_port_irq_epilogue>
}
 8004b12:	b003      	add	sp, #12
 8004b14:	f85d fb04 	ldr.w	pc, [sp], #4
 8004b18:	40026000 	.word	0x40026000
 8004b1c:	20000984 	.word	0x20000984

08004b20 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 8004b20:	b084      	sub	sp, #16
 8004b22:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8004b24:	9b01      	ldr	r3, [sp, #4]
 8004b26:	3307      	adds	r3, #7
 8004b28:	f023 0307 	bic.w	r3, r3, #7
 8004b2c:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8004b2e:	4b0c      	ldr	r3, [pc, #48]	; (8004b60 <chCoreAllocI+0x40>)
 8004b30:	681b      	ldr	r3, [r3, #0]
 8004b32:	461a      	mov	r2, r3
 8004b34:	4b0b      	ldr	r3, [pc, #44]	; (8004b64 <chCoreAllocI+0x44>)
 8004b36:	681b      	ldr	r3, [r3, #0]
 8004b38:	1ad3      	subs	r3, r2, r3
 8004b3a:	461a      	mov	r2, r3
 8004b3c:	9b01      	ldr	r3, [sp, #4]
 8004b3e:	429a      	cmp	r2, r3
 8004b40:	d201      	bcs.n	8004b46 <chCoreAllocI+0x26>
  /*lint -restore*/
    return NULL;
 8004b42:	2300      	movs	r3, #0
 8004b44:	e009      	b.n	8004b5a <chCoreAllocI+0x3a>
  }
  p = nextmem;
 8004b46:	4b07      	ldr	r3, [pc, #28]	; (8004b64 <chCoreAllocI+0x44>)
 8004b48:	681b      	ldr	r3, [r3, #0]
 8004b4a:	9303      	str	r3, [sp, #12]
  nextmem += size;
 8004b4c:	4b05      	ldr	r3, [pc, #20]	; (8004b64 <chCoreAllocI+0x44>)
 8004b4e:	681a      	ldr	r2, [r3, #0]
 8004b50:	9b01      	ldr	r3, [sp, #4]
 8004b52:	4413      	add	r3, r2
 8004b54:	4a03      	ldr	r2, [pc, #12]	; (8004b64 <chCoreAllocI+0x44>)
 8004b56:	6013      	str	r3, [r2, #0]

  return p;
 8004b58:	9b03      	ldr	r3, [sp, #12]
}
 8004b5a:	4618      	mov	r0, r3
 8004b5c:	b004      	add	sp, #16
 8004b5e:	4770      	bx	lr
 8004b60:	2000095c 	.word	0x2000095c
 8004b64:	20000958 	.word	0x20000958
	...

08004b70 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 8004b70:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
 8004b72:	4b06      	ldr	r3, [pc, #24]	; (8004b8c <_heap_init+0x1c>)
 8004b74:	4a06      	ldr	r2, [pc, #24]	; (8004b90 <_heap_init+0x20>)
 8004b76:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 8004b78:	4b04      	ldr	r3, [pc, #16]	; (8004b8c <_heap_init+0x1c>)
 8004b7a:	2200      	movs	r2, #0
 8004b7c:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 8004b7e:	4b03      	ldr	r3, [pc, #12]	; (8004b8c <_heap_init+0x1c>)
 8004b80:	2200      	movs	r2, #0
 8004b82:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8004b84:	4803      	ldr	r0, [pc, #12]	; (8004b94 <_heap_init+0x24>)
 8004b86:	f001 fb23 	bl	80061d0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
 8004b8a:	bd08      	pop	{r3, pc}
 8004b8c:	20000960 	.word	0x20000960
 8004b90:	08005161 	.word	0x08005161
 8004b94:	20000970 	.word	0x20000970
	...

08004ba0 <port_lock.lto_priv.219>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004ba0:	b082      	sub	sp, #8
 8004ba2:	2320      	movs	r3, #32
 8004ba4:	9301      	str	r3, [sp, #4]
 8004ba6:	9b01      	ldr	r3, [sp, #4]
 8004ba8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004bac:	b002      	add	sp, #8
 8004bae:	4770      	bx	lr

08004bb0 <port_unlock.lto_priv.213>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004bb0:	b082      	sub	sp, #8
 8004bb2:	2300      	movs	r3, #0
 8004bb4:	9301      	str	r3, [sp, #4]
 8004bb6:	9b01      	ldr	r3, [sp, #4]
 8004bb8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004bbc:	b002      	add	sp, #8
 8004bbe:	4770      	bx	lr

08004bc0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8004bc0:	b508      	push	{r3, lr}

  port_lock();
 8004bc2:	f7ff ffed 	bl	8004ba0 <port_lock.lto_priv.219>
}
 8004bc6:	bd08      	pop	{r3, pc}
	...

08004bd0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8004bd0:	b508      	push	{r3, lr}

  port_unlock();
 8004bd2:	f7ff ffed 	bl	8004bb0 <port_unlock.lto_priv.213>
}
 8004bd6:	bd08      	pop	{r3, pc}
	...

08004be0 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8004be0:	b510      	push	{r4, lr}
 8004be2:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8004be4:	f3ef 8309 	mrs	r3, PSP
 8004be8:	461c      	mov	r4, r3
  return(result);
 8004bea:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 8004bec:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8004bee:	9b01      	ldr	r3, [sp, #4]
 8004bf0:	3320      	adds	r3, #32
 8004bf2:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 8004bf4:	9b01      	ldr	r3, [sp, #4]
 8004bf6:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8004bf8:	9b00      	ldr	r3, [sp, #0]
 8004bfa:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8004bfe:	f7ff ffe7 	bl	8004bd0 <port_unlock_from_isr>
}
 8004c02:	b002      	add	sp, #8
 8004c04:	bd10      	pop	{r4, pc}
 8004c06:	bf00      	nop
	...

08004c10 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8004c10:	b510      	push	{r4, lr}
 8004c12:	b082      	sub	sp, #8

  port_lock_from_isr();
 8004c14:	f7ff ffd4 	bl	8004bc0 <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8004c18:	4b13      	ldr	r3, [pc, #76]	; (8004c68 <_port_irq_epilogue+0x58>)
 8004c1a:	685b      	ldr	r3, [r3, #4]
 8004c1c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8004c20:	2b00      	cmp	r3, #0
 8004c22:	d01d      	beq.n	8004c60 <_port_irq_epilogue+0x50>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8004c24:	f3ef 8309 	mrs	r3, PSP
 8004c28:	461c      	mov	r4, r3
  return(result);
 8004c2a:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 8004c2c:	9301      	str	r3, [sp, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8004c2e:	9b01      	ldr	r3, [sp, #4]
 8004c30:	3b20      	subs	r3, #32
 8004c32:	9301      	str	r3, [sp, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8004c34:	9b01      	ldr	r3, [sp, #4]
 8004c36:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8004c3a:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 8004c3c:	9b01      	ldr	r3, [sp, #4]
 8004c3e:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8004c40:	9b00      	ldr	r3, [sp, #0]
 8004c42:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8004c46:	f000 ffe3 	bl	8005c10 <chSchIsPreemptionRequired>
 8004c4a:	4603      	mov	r3, r0
 8004c4c:	2b00      	cmp	r3, #0
 8004c4e:	d003      	beq.n	8004c58 <_port_irq_epilogue+0x48>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8004c50:	9b01      	ldr	r3, [sp, #4]
 8004c52:	4a06      	ldr	r2, [pc, #24]	; (8004c6c <_port_irq_epilogue+0x5c>)
 8004c54:	619a      	str	r2, [r3, #24]
 8004c56:	e005      	b.n	8004c64 <_port_irq_epilogue+0x54>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8004c58:	9b01      	ldr	r3, [sp, #4]
 8004c5a:	4a05      	ldr	r2, [pc, #20]	; (8004c70 <_port_irq_epilogue+0x60>)
 8004c5c:	619a      	str	r2, [r3, #24]
 8004c5e:	e001      	b.n	8004c64 <_port_irq_epilogue+0x54>

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
 8004c60:	f7ff ffb6 	bl	8004bd0 <port_unlock_from_isr>
}
 8004c64:	b002      	add	sp, #8
 8004c66:	bd10      	pop	{r4, pc}
 8004c68:	e000ed00 	.word	0xe000ed00
 8004c6c:	080002b1 	.word	0x080002b1
 8004c70:	080002b4 	.word	0x080002b4
	...

08004c80 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8004c80:	4770      	bx	lr
 8004c82:	bf00      	nop
	...

08004c90 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8004c90:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8004c92:	f7ff fff5 	bl	8004c80 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8004c96:	f7ff fe03 	bl	80048a0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8004c9a:	4808      	ldr	r0, [pc, #32]	; (8004cbc <halInit+0x2c>)
 8004c9c:	f7fe fc30 	bl	8003500 <_pal_lld_init>
#endif
#if (HAL_USE_DAC == TRUE) || defined(__DOXYGEN__)
  dacInit();
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
 8004ca0:	f000 f88e 	bl	8004dc0 <extInit>
#endif
#if (HAL_USE_MAC == TRUE) || defined(__DOXYGEN__)
  macInit();
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
 8004ca4:	f000 f8fc 	bl	8004ea0 <pwmInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
 8004ca8:	f7fe fef2 	bl	8003a90 <spiInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 8004cac:	f7ff fa10 	bl	80040d0 <usbInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8004cb0:	f7fc fbee 	bl	8001490 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8004cb4:	f000 f824 	bl	8004d00 <stInit>
#endif
}
 8004cb8:	bd08      	pop	{r3, pc}
 8004cba:	bf00      	nop
 8004cbc:	08006bb0 	.word	0x08006bb0

08004cc0 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8004cc0:	b082      	sub	sp, #8
 8004cc2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004cc4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8004cc8:	9b01      	ldr	r3, [sp, #4]
 8004cca:	6353      	str	r3, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8004ccc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004cd0:	2200      	movs	r2, #0
 8004cd2:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8004cd4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004cd8:	2202      	movs	r2, #2
 8004cda:	60da      	str	r2, [r3, #12]
}
 8004cdc:	b002      	add	sp, #8
 8004cde:	4770      	bx	lr

08004ce0 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8004ce0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004ce4:	2200      	movs	r2, #0
 8004ce6:	60da      	str	r2, [r3, #12]
}
 8004ce8:	4770      	bx	lr
 8004cea:	bf00      	nop
 8004cec:	0000      	movs	r0, r0
	...

08004cf0 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8004cf0:	b082      	sub	sp, #8
 8004cf2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004cf4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8004cf8:	9b01      	ldr	r3, [sp, #4]
 8004cfa:	6353      	str	r3, [r2, #52]	; 0x34
}
 8004cfc:	b002      	add	sp, #8
 8004cfe:	4770      	bx	lr

08004d00 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8004d00:	b508      	push	{r3, lr}

  st_lld_init();
 8004d02:	f7fd ffdd 	bl	8002cc0 <st_lld_init>
}
 8004d06:	bd08      	pop	{r3, pc}
	...

08004d10 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8004d10:	b500      	push	{lr}
 8004d12:	b083      	sub	sp, #12
 8004d14:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
 8004d16:	9801      	ldr	r0, [sp, #4]
 8004d18:	f7ff ffd2 	bl	8004cc0 <st_lld_start_alarm>
}
 8004d1c:	b003      	add	sp, #12
 8004d1e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004d22:	bf00      	nop
	...

08004d30 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8004d30:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8004d32:	f7ff ffd5 	bl	8004ce0 <st_lld_stop_alarm>
}
 8004d36:	bd08      	pop	{r3, pc}
	...

08004d40 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8004d40:	b500      	push	{lr}
 8004d42:	b083      	sub	sp, #12
 8004d44:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
 8004d46:	9801      	ldr	r0, [sp, #4]
 8004d48:	f7ff ffd2 	bl	8004cf0 <st_lld_set_alarm>
}
 8004d4c:	b003      	add	sp, #12
 8004d4e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004d52:	bf00      	nop
	...

08004d60 <port_lock.lto_priv.221>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004d60:	b082      	sub	sp, #8
 8004d62:	2320      	movs	r3, #32
 8004d64:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8004d66:	9b01      	ldr	r3, [sp, #4]
 8004d68:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004d6c:	b002      	add	sp, #8
 8004d6e:	4770      	bx	lr

08004d70 <port_unlock.lto_priv.215>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004d70:	b082      	sub	sp, #8
 8004d72:	2300      	movs	r3, #0
 8004d74:	9301      	str	r3, [sp, #4]
 8004d76:	9b01      	ldr	r3, [sp, #4]
 8004d78:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004d7c:	b002      	add	sp, #8
 8004d7e:	4770      	bx	lr

08004d80 <chSysLock.lto_priv.209>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8004d80:	b508      	push	{r3, lr}

  port_lock();
 8004d82:	f7ff ffed 	bl	8004d60 <port_lock.lto_priv.221>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8004d86:	bd08      	pop	{r3, pc}
	...

08004d90 <chSysUnlock.lto_priv.204>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8004d90:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8004d92:	f7ff ffed 	bl	8004d70 <port_unlock.lto_priv.215>
}
 8004d96:	bd08      	pop	{r3, pc}
	...

08004da0 <osalSysLock.lto_priv.228>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8004da0:	b508      	push	{r3, lr}

  chSysLock();
 8004da2:	f7ff ffed 	bl	8004d80 <chSysLock.lto_priv.209>
}
 8004da6:	bd08      	pop	{r3, pc}
	...

08004db0 <osalSysUnlock.lto_priv.225>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8004db0:	b508      	push	{r3, lr}

  chSysUnlock();
 8004db2:	f7ff ffed 	bl	8004d90 <chSysUnlock.lto_priv.204>
}
 8004db6:	bd08      	pop	{r3, pc}
	...

08004dc0 <extInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void extInit(void) {
 8004dc0:	b508      	push	{r3, lr}

  ext_lld_init();
 8004dc2:	f7fd ffb5 	bl	8002d30 <ext_lld_init>
}
 8004dc6:	bd08      	pop	{r3, pc}
	...

08004dd0 <extObjectInit>:
 *
 * @param[out] extp     pointer to the @p EXTDriver object
 *
 * @init
 */
void extObjectInit(EXTDriver *extp) {
 8004dd0:	b082      	sub	sp, #8
 8004dd2:	9001      	str	r0, [sp, #4]

  extp->state  = EXT_STOP;
 8004dd4:	9b01      	ldr	r3, [sp, #4]
 8004dd6:	2201      	movs	r2, #1
 8004dd8:	701a      	strb	r2, [r3, #0]
  extp->config = NULL;
 8004dda:	9b01      	ldr	r3, [sp, #4]
 8004ddc:	2200      	movs	r2, #0
 8004dde:	605a      	str	r2, [r3, #4]
}
 8004de0:	b002      	add	sp, #8
 8004de2:	4770      	bx	lr
	...

08004df0 <extStart>:
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] config    pointer to the @p EXTConfig object
 *
 * @api
 */
void extStart(EXTDriver *extp, const EXTConfig *config) {
 8004df0:	b500      	push	{lr}
 8004df2:	b083      	sub	sp, #12
 8004df4:	9001      	str	r0, [sp, #4]
 8004df6:	9100      	str	r1, [sp, #0]

  osalDbgCheck((extp != NULL) && (config != NULL));

  osalSysLock();
 8004df8:	f7ff ffd2 	bl	8004da0 <osalSysLock.lto_priv.228>
  osalDbgAssert((extp->state == EXT_STOP) || (extp->state == EXT_ACTIVE),
                "invalid state");
  extp->config = config;
 8004dfc:	9b01      	ldr	r3, [sp, #4]
 8004dfe:	9a00      	ldr	r2, [sp, #0]
 8004e00:	605a      	str	r2, [r3, #4]
  ext_lld_start(extp);
 8004e02:	9801      	ldr	r0, [sp, #4]
 8004e04:	f7fd ff9c 	bl	8002d40 <ext_lld_start>
  extp->state = EXT_ACTIVE;
 8004e08:	9b01      	ldr	r3, [sp, #4]
 8004e0a:	2202      	movs	r2, #2
 8004e0c:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 8004e0e:	f7ff ffcf 	bl	8004db0 <osalSysUnlock.lto_priv.225>
}
 8004e12:	b003      	add	sp, #12
 8004e14:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004e20 <extChannelEnable>:
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] channel   channel to be enabled
 *
 * @api
 */
void extChannelEnable(EXTDriver *extp, expchannel_t channel) {
 8004e20:	b500      	push	{lr}
 8004e22:	b083      	sub	sp, #12
 8004e24:	9001      	str	r0, [sp, #4]
 8004e26:	9100      	str	r1, [sp, #0]

  osalDbgCheck((extp != NULL) && (channel < (expchannel_t)EXT_MAX_CHANNELS));

  osalSysLock();
 8004e28:	f7ff ffba 	bl	8004da0 <osalSysLock.lto_priv.228>
  osalDbgAssert((extp->state == EXT_ACTIVE) &&
                ((extp->config->channels[channel].mode &
                  EXT_CH_MODE_EDGES_MASK) != EXT_CH_MODE_DISABLED),
                "invalid state");
  extChannelEnableI(extp, channel);
 8004e2c:	9801      	ldr	r0, [sp, #4]
 8004e2e:	9900      	ldr	r1, [sp, #0]
 8004e30:	f7fd ffae 	bl	8002d90 <ext_lld_channel_enable>
  osalSysUnlock();
 8004e34:	f7ff ffbc 	bl	8004db0 <osalSysUnlock.lto_priv.225>
}
 8004e38:	b003      	add	sp, #12
 8004e3a:	f85d fb04 	ldr.w	pc, [sp], #4
 8004e3e:	bf00      	nop

08004e40 <port_lock.lto_priv.222>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004e40:	b082      	sub	sp, #8
 8004e42:	2320      	movs	r3, #32
 8004e44:	9301      	str	r3, [sp, #4]
 8004e46:	9b01      	ldr	r3, [sp, #4]
 8004e48:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004e4c:	b002      	add	sp, #8
 8004e4e:	4770      	bx	lr

08004e50 <port_unlock.lto_priv.216>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004e50:	b082      	sub	sp, #8
 8004e52:	2300      	movs	r3, #0
 8004e54:	9301      	str	r3, [sp, #4]
 8004e56:	9b01      	ldr	r3, [sp, #4]
 8004e58:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004e5c:	b002      	add	sp, #8
 8004e5e:	4770      	bx	lr

08004e60 <chSysLock.lto_priv.210>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8004e60:	b508      	push	{r3, lr}

  port_lock();
 8004e62:	f7ff ffed 	bl	8004e40 <port_lock.lto_priv.222>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8004e66:	bd08      	pop	{r3, pc}
	...

08004e70 <chSysUnlock.lto_priv.205>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8004e70:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8004e72:	f7ff ffed 	bl	8004e50 <port_unlock.lto_priv.216>
}
 8004e76:	bd08      	pop	{r3, pc}
	...

08004e80 <osalSysLock.lto_priv.229>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8004e80:	b508      	push	{r3, lr}

  chSysLock();
 8004e82:	f7ff ffed 	bl	8004e60 <chSysLock.lto_priv.210>
}
 8004e86:	bd08      	pop	{r3, pc}
	...

08004e90 <osalSysUnlock.lto_priv.226>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8004e90:	b508      	push	{r3, lr}

  chSysUnlock();
 8004e92:	f7ff ffed 	bl	8004e70 <chSysUnlock.lto_priv.205>
}
 8004e96:	bd08      	pop	{r3, pc}
	...

08004ea0 <pwmInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void pwmInit(void) {
 8004ea0:	b508      	push	{r3, lr}

  pwm_lld_init();
 8004ea2:	f7fc f995 	bl	80011d0 <pwm_lld_init>
}
 8004ea6:	bd08      	pop	{r3, pc}
	...

08004eb0 <pwmObjectInit>:
 *
 * @param[out] pwmp     pointer to a @p PWMDriver object
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {
 8004eb0:	b082      	sub	sp, #8
 8004eb2:	9001      	str	r0, [sp, #4]

  pwmp->state    = PWM_STOP;
 8004eb4:	9b01      	ldr	r3, [sp, #4]
 8004eb6:	2201      	movs	r2, #1
 8004eb8:	701a      	strb	r2, [r3, #0]
  pwmp->config   = NULL;
 8004eba:	9b01      	ldr	r3, [sp, #4]
 8004ebc:	2200      	movs	r2, #0
 8004ebe:	605a      	str	r2, [r3, #4]
  pwmp->enabled  = 0;
 8004ec0:	9b01      	ldr	r3, [sp, #4]
 8004ec2:	2200      	movs	r2, #0
 8004ec4:	60da      	str	r2, [r3, #12]
  pwmp->channels = 0;
 8004ec6:	9b01      	ldr	r3, [sp, #4]
 8004ec8:	2200      	movs	r2, #0
 8004eca:	741a      	strb	r2, [r3, #16]
#if defined(PWM_DRIVER_EXT_INIT_HOOK)
  PWM_DRIVER_EXT_INIT_HOOK(pwmp);
#endif
}
 8004ecc:	b002      	add	sp, #8
 8004ece:	4770      	bx	lr

08004ed0 <pwmStart>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] config    pointer to a @p PWMConfig object
 *
 * @api
 */
void pwmStart(PWMDriver *pwmp, const PWMConfig *config) {
 8004ed0:	b500      	push	{lr}
 8004ed2:	b083      	sub	sp, #12
 8004ed4:	9001      	str	r0, [sp, #4]
 8004ed6:	9100      	str	r1, [sp, #0]

  osalDbgCheck((pwmp != NULL) && (config != NULL));

  osalSysLock();
 8004ed8:	f7ff ffd2 	bl	8004e80 <osalSysLock.lto_priv.229>
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwmp->config = config;
 8004edc:	9b01      	ldr	r3, [sp, #4]
 8004ede:	9a00      	ldr	r2, [sp, #0]
 8004ee0:	605a      	str	r2, [r3, #4]
  pwmp->period = config->period;
 8004ee2:	9b00      	ldr	r3, [sp, #0]
 8004ee4:	685a      	ldr	r2, [r3, #4]
 8004ee6:	9b01      	ldr	r3, [sp, #4]
 8004ee8:	609a      	str	r2, [r3, #8]
  pwm_lld_start(pwmp);
 8004eea:	9801      	ldr	r0, [sp, #4]
 8004eec:	f7fc f980 	bl	80011f0 <pwm_lld_start>
  pwmp->enabled = 0;
 8004ef0:	9b01      	ldr	r3, [sp, #4]
 8004ef2:	2200      	movs	r2, #0
 8004ef4:	60da      	str	r2, [r3, #12]
  pwmp->state = PWM_READY;
 8004ef6:	9b01      	ldr	r3, [sp, #4]
 8004ef8:	2202      	movs	r2, #2
 8004efa:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 8004efc:	f7ff ffc8 	bl	8004e90 <osalSysUnlock.lto_priv.226>
}
 8004f00:	b003      	add	sp, #12
 8004f02:	f85d fb04 	ldr.w	pc, [sp], #4
 8004f06:	bf00      	nop
	...

08004f10 <pwmEnableChannel>:
 *
 * @api
 */
void pwmEnableChannel(PWMDriver *pwmp,
                      pwmchannel_t channel,
                      pwmcnt_t width) {
 8004f10:	b500      	push	{lr}
 8004f12:	b085      	sub	sp, #20
 8004f14:	9003      	str	r0, [sp, #12]
 8004f16:	460b      	mov	r3, r1
 8004f18:	9201      	str	r2, [sp, #4]
 8004f1a:	f88d 300b 	strb.w	r3, [sp, #11]

  osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));

  osalSysLock();
 8004f1e:	f7ff ffaf 	bl	8004e80 <osalSysLock.lto_priv.229>

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");

  pwmEnableChannelI(pwmp, channel, width);
 8004f22:	9b03      	ldr	r3, [sp, #12]
 8004f24:	68da      	ldr	r2, [r3, #12]
 8004f26:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8004f2a:	2101      	movs	r1, #1
 8004f2c:	fa01 f303 	lsl.w	r3, r1, r3
 8004f30:	431a      	orrs	r2, r3
 8004f32:	9b03      	ldr	r3, [sp, #12]
 8004f34:	60da      	str	r2, [r3, #12]
 8004f36:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8004f3a:	9803      	ldr	r0, [sp, #12]
 8004f3c:	4619      	mov	r1, r3
 8004f3e:	9a01      	ldr	r2, [sp, #4]
 8004f40:	f7fc fa1e 	bl	8001380 <pwm_lld_enable_channel>

  osalSysUnlock();
 8004f44:	f7ff ffa4 	bl	8004e90 <osalSysUnlock.lto_priv.226>
}
 8004f48:	b005      	add	sp, #20
 8004f4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8004f4e:	bf00      	nop

08004f50 <port_lock.lto_priv.223>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004f50:	b082      	sub	sp, #8
 8004f52:	2320      	movs	r3, #32
 8004f54:	9301      	str	r3, [sp, #4]
 8004f56:	9b01      	ldr	r3, [sp, #4]
 8004f58:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004f5c:	b002      	add	sp, #8
 8004f5e:	4770      	bx	lr

08004f60 <port_unlock.lto_priv.217>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004f60:	b082      	sub	sp, #8
 8004f62:	2300      	movs	r3, #0
 8004f64:	9301      	str	r3, [sp, #4]
 8004f66:	9b01      	ldr	r3, [sp, #4]
 8004f68:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004f6c:	b002      	add	sp, #8
 8004f6e:	4770      	bx	lr

08004f70 <chSysLock.lto_priv.211>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8004f70:	b508      	push	{r3, lr}

  port_lock();
 8004f72:	f7ff ffed 	bl	8004f50 <port_lock.lto_priv.223>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8004f76:	bd08      	pop	{r3, pc}
	...

08004f80 <chSysUnlock.lto_priv.206>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8004f80:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8004f82:	f7ff ffed 	bl	8004f60 <port_unlock.lto_priv.217>
}
 8004f86:	bd08      	pop	{r3, pc}
	...

08004f90 <osalSysLock.lto_priv.197>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8004f90:	b508      	push	{r3, lr}

  chSysLock();
 8004f92:	f7ff ffed 	bl	8004f70 <chSysLock.lto_priv.211>
}
 8004f96:	bd08      	pop	{r3, pc}
	...

08004fa0 <osalSysUnlock.lto_priv.195>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8004fa0:	b508      	push	{r3, lr}

  chSysUnlock();
 8004fa2:	f7ff ffed 	bl	8004f80 <chSysUnlock.lto_priv.206>
}
 8004fa6:	bd08      	pop	{r3, pc}
	...

08004fb0 <osalThreadSuspendS.lto_priv.193>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8004fb0:	b500      	push	{lr}
 8004fb2:	b083      	sub	sp, #12
 8004fb4:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 8004fb6:	9801      	ldr	r0, [sp, #4]
 8004fb8:	f001 f82a 	bl	8006010 <chThdSuspendS>
 8004fbc:	4603      	mov	r3, r0
}
 8004fbe:	4618      	mov	r0, r3
 8004fc0:	b003      	add	sp, #12
 8004fc2:	f85d fb04 	ldr.w	pc, [sp], #4
 8004fc6:	bf00      	nop
	...

08004fd0 <osalMutexObjectInit.lto_priv.201>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 8004fd0:	b500      	push	{lr}
 8004fd2:	b083      	sub	sp, #12
 8004fd4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8004fd6:	9801      	ldr	r0, [sp, #4]
 8004fd8:	f001 f8fa 	bl	80061d0 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 8004fdc:	b003      	add	sp, #12
 8004fde:	f85d fb04 	ldr.w	pc, [sp], #4
 8004fe2:	bf00      	nop
	...

08004ff0 <port_lock.lto_priv.250>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004ff0:	b082      	sub	sp, #8
 8004ff2:	2320      	movs	r3, #32
 8004ff4:	9301      	str	r3, [sp, #4]
 8004ff6:	9b01      	ldr	r3, [sp, #4]
 8004ff8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004ffc:	b002      	add	sp, #8
 8004ffe:	4770      	bx	lr

08005000 <port_unlock.lto_priv.245>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005000:	b082      	sub	sp, #8
 8005002:	2300      	movs	r3, #0
 8005004:	9301      	str	r3, [sp, #4]
 8005006:	9b01      	ldr	r3, [sp, #4]
 8005008:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800500c:	b002      	add	sp, #8
 800500e:	4770      	bx	lr

08005010 <chSysLock.lto_priv.240>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8005010:	b508      	push	{r3, lr}

  port_lock();
 8005012:	f7ff ffed 	bl	8004ff0 <port_lock.lto_priv.250>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8005016:	bd08      	pop	{r3, pc}
	...

08005020 <chSysUnlock.lto_priv.234>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8005020:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8005022:	f7ff ffed 	bl	8005000 <port_unlock.lto_priv.245>
}
 8005026:	bd08      	pop	{r3, pc}
	...

08005030 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8005030:	b500      	push	{lr}
 8005032:	b083      	sub	sp, #12
 8005034:	9001      	str	r0, [sp, #4]
 8005036:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8005038:	9b01      	ldr	r3, [sp, #4]
 800503a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800503c:	9b00      	ldr	r3, [sp, #0]
 800503e:	431a      	orrs	r2, r3
 8005040:	9b01      	ldr	r3, [sp, #4]
 8005042:	635a      	str	r2, [r3, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8005044:	9b01      	ldr	r3, [sp, #4]
 8005046:	7f1b      	ldrb	r3, [r3, #28]
 8005048:	2b0a      	cmp	r3, #10
 800504a:	d106      	bne.n	800505a <chEvtSignalI+0x2a>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800504c:	9b01      	ldr	r3, [sp, #4]
 800504e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8005050:	9b01      	ldr	r3, [sp, #4]
 8005052:	6a1b      	ldr	r3, [r3, #32]
 8005054:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8005056:	2b00      	cmp	r3, #0
 8005058:	d10c      	bne.n	8005074 <chEvtSignalI+0x44>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 800505a:	9b01      	ldr	r3, [sp, #4]
 800505c:	7f1b      	ldrb	r3, [r3, #28]
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800505e:	2b0b      	cmp	r3, #11
 8005060:	d10e      	bne.n	8005080 <chEvtSignalI+0x50>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8005062:	9b01      	ldr	r3, [sp, #4]
 8005064:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8005066:	9b01      	ldr	r3, [sp, #4]
 8005068:	6a1b      	ldr	r3, [r3, #32]
 800506a:	401a      	ands	r2, r3
 800506c:	9b01      	ldr	r3, [sp, #4]
 800506e:	6a1b      	ldr	r3, [r3, #32]

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8005070:	429a      	cmp	r2, r3
 8005072:	d105      	bne.n	8005080 <chEvtSignalI+0x50>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8005074:	9b01      	ldr	r3, [sp, #4]
 8005076:	2200      	movs	r2, #0
 8005078:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 800507a:	9801      	ldr	r0, [sp, #4]
 800507c:	f000 fcc8 	bl	8005a10 <chSchReadyI>
  }
}
 8005080:	b003      	add	sp, #12
 8005082:	f85d fb04 	ldr.w	pc, [sp], #4
 8005086:	bf00      	nop
	...

08005090 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 8005090:	b500      	push	{lr}
 8005092:	b085      	sub	sp, #20
 8005094:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8005096:	4b13      	ldr	r3, [pc, #76]	; (80050e4 <chEvtWaitAny+0x54>)
 8005098:	699b      	ldr	r3, [r3, #24]
 800509a:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 800509c:	f7ff ffb8 	bl	8005010 <chSysLock.lto_priv.240>
  m = ctp->p_epending & events;
 80050a0:	9b02      	ldr	r3, [sp, #8]
 80050a2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80050a4:	9b01      	ldr	r3, [sp, #4]
 80050a6:	4013      	ands	r3, r2
 80050a8:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 80050aa:	9b03      	ldr	r3, [sp, #12]
 80050ac:	2b00      	cmp	r3, #0
 80050ae:	d10a      	bne.n	80050c6 <chEvtWaitAny+0x36>
    ctp->p_u.ewmask = events;
 80050b0:	9b02      	ldr	r3, [sp, #8]
 80050b2:	9a01      	ldr	r2, [sp, #4]
 80050b4:	621a      	str	r2, [r3, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 80050b6:	200a      	movs	r0, #10
 80050b8:	f000 fcd2 	bl	8005a60 <chSchGoSleepS>
    m = ctp->p_epending & events;
 80050bc:	9b02      	ldr	r3, [sp, #8]
 80050be:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80050c0:	9b01      	ldr	r3, [sp, #4]
 80050c2:	4013      	ands	r3, r2
 80050c4:	9303      	str	r3, [sp, #12]
  }
  ctp->p_epending &= ~m;
 80050c6:	9b02      	ldr	r3, [sp, #8]
 80050c8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80050ca:	9b03      	ldr	r3, [sp, #12]
 80050cc:	43db      	mvns	r3, r3
 80050ce:	401a      	ands	r2, r3
 80050d0:	9b02      	ldr	r3, [sp, #8]
 80050d2:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 80050d4:	f7ff ffa4 	bl	8005020 <chSysUnlock.lto_priv.234>

  return m;
 80050d8:	9b03      	ldr	r3, [sp, #12]
}
 80050da:	4618      	mov	r0, r3
 80050dc:	b005      	add	sp, #20
 80050de:	f85d fb04 	ldr.w	pc, [sp], #4
 80050e2:	bf00      	nop
 80050e4:	20000808 	.word	0x20000808
	...

080050f0 <port_lock.lto_priv.254>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80050f0:	b082      	sub	sp, #8
 80050f2:	2320      	movs	r3, #32
 80050f4:	9301      	str	r3, [sp, #4]
 80050f6:	9b01      	ldr	r3, [sp, #4]
 80050f8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80050fc:	b002      	add	sp, #8
 80050fe:	4770      	bx	lr

08005100 <port_unlock.lto_priv.249>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005100:	b082      	sub	sp, #8
 8005102:	2300      	movs	r3, #0
 8005104:	9301      	str	r3, [sp, #4]
 8005106:	9b01      	ldr	r3, [sp, #4]
 8005108:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800510c:	b002      	add	sp, #8
 800510e:	4770      	bx	lr

08005110 <chSysLock.lto_priv.244>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8005110:	b508      	push	{r3, lr}

  port_lock();
 8005112:	f7ff ffed 	bl	80050f0 <port_lock.lto_priv.254>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8005116:	bd08      	pop	{r3, pc}
	...

08005120 <chSysUnlock.lto_priv.238>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8005120:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8005122:	f7ff ffed 	bl	8005100 <port_unlock.lto_priv.249>
}
 8005126:	bd08      	pop	{r3, pc}
	...

08005130 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8005130:	4b06      	ldr	r3, [pc, #24]	; (800514c <_core_init+0x1c>)
 8005132:	3307      	adds	r3, #7
 8005134:	f023 0307 	bic.w	r3, r3, #7
 8005138:	461a      	mov	r2, r3
 800513a:	4b05      	ldr	r3, [pc, #20]	; (8005150 <_core_init+0x20>)
 800513c:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800513e:	4b05      	ldr	r3, [pc, #20]	; (8005154 <_core_init+0x24>)
 8005140:	f023 0307 	bic.w	r3, r3, #7
 8005144:	461a      	mov	r2, r3
 8005146:	4b04      	ldr	r3, [pc, #16]	; (8005158 <_core_init+0x28>)
 8005148:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 800514a:	4770      	bx	lr
 800514c:	20000f48 	.word	0x20000f48
 8005150:	20000958 	.word	0x20000958
 8005154:	20020000 	.word	0x20020000
 8005158:	2000095c 	.word	0x2000095c
 800515c:	00000000 	.word	0x00000000

08005160 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8005160:	b500      	push	{lr}
 8005162:	b085      	sub	sp, #20
 8005164:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
 8005166:	f7ff ffd3 	bl	8005110 <chSysLock.lto_priv.244>
  p = chCoreAllocI(size);
 800516a:	9801      	ldr	r0, [sp, #4]
 800516c:	f7ff fcd8 	bl	8004b20 <chCoreAllocI>
 8005170:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8005172:	f7ff ffd5 	bl	8005120 <chSysUnlock.lto_priv.238>

  return p;
 8005176:	9b03      	ldr	r3, [sp, #12]
}
 8005178:	4618      	mov	r0, r3
 800517a:	b005      	add	sp, #20
 800517c:	f85d fb04 	ldr.w	pc, [sp], #4

08005180 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8005180:	4770      	bx	lr
 8005182:	bf00      	nop
	...

08005190 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8005190:	4770      	bx	lr
 8005192:	bf00      	nop
	...

080051a0 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 80051a0:	e7fe      	b.n	80051a0 <__default_exit>
 80051a2:	bf00      	nop
	...

080051b0 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 80051b0:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 80051b2:	4b16      	ldr	r3, [pc, #88]	; (800520c <__init_ram_areas+0x5c>)
 80051b4:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 80051b6:	9b03      	ldr	r3, [sp, #12]
 80051b8:	681b      	ldr	r3, [r3, #0]
 80051ba:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 80051bc:	9b03      	ldr	r3, [sp, #12]
 80051be:	685b      	ldr	r3, [r3, #4]
 80051c0:	9301      	str	r3, [sp, #4]
 80051c2:	e009      	b.n	80051d8 <__init_ram_areas+0x28>

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 80051c4:	9b02      	ldr	r3, [sp, #8]
 80051c6:	681a      	ldr	r2, [r3, #0]
 80051c8:	9b01      	ldr	r3, [sp, #4]
 80051ca:	601a      	str	r2, [r3, #0]
      p++;
 80051cc:	9b01      	ldr	r3, [sp, #4]
 80051ce:	3304      	adds	r3, #4
 80051d0:	9301      	str	r3, [sp, #4]
      tp++;
 80051d2:	9b02      	ldr	r3, [sp, #8]
 80051d4:	3304      	adds	r3, #4
 80051d6:	9302      	str	r3, [sp, #8]
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80051d8:	9b03      	ldr	r3, [sp, #12]
 80051da:	689a      	ldr	r2, [r3, #8]
 80051dc:	9b01      	ldr	r3, [sp, #4]
 80051de:	429a      	cmp	r2, r3
 80051e0:	d8f0      	bhi.n	80051c4 <__init_ram_areas+0x14>
 80051e2:	e005      	b.n	80051f0 <__init_ram_areas+0x40>
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 80051e4:	9b01      	ldr	r3, [sp, #4]
 80051e6:	2200      	movs	r2, #0
 80051e8:	601a      	str	r2, [r3, #0]
      p++;
 80051ea:	9b01      	ldr	r3, [sp, #4]
 80051ec:	3304      	adds	r3, #4
 80051ee:	9301      	str	r3, [sp, #4]
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80051f0:	9b03      	ldr	r3, [sp, #12]
 80051f2:	68da      	ldr	r2, [r3, #12]
 80051f4:	9b01      	ldr	r3, [sp, #4]
 80051f6:	429a      	cmp	r2, r3
 80051f8:	d8f4      	bhi.n	80051e4 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
 80051fa:	9b03      	ldr	r3, [sp, #12]
 80051fc:	3310      	adds	r3, #16
 80051fe:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8005200:	9b03      	ldr	r3, [sp, #12]
 8005202:	4a03      	ldr	r2, [pc, #12]	; (8005210 <__init_ram_areas+0x60>)
 8005204:	4293      	cmp	r3, r2
 8005206:	d3d6      	bcc.n	80051b6 <__init_ram_areas+0x6>
#endif
}
 8005208:	b004      	add	sp, #16
 800520a:	4770      	bx	lr
 800520c:	080069e0 	.word	0x080069e0
 8005210:	08006a60 	.word	0x08006a60
	...

08005220 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8005220:	e7fe      	b.n	8005220 <BusFault_Handler>
 8005222:	bf00      	nop
	...

08005230 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8005230:	b084      	sub	sp, #16
 8005232:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8005234:	9b01      	ldr	r3, [sp, #4]
 8005236:	f003 0307 	and.w	r3, r3, #7
 800523a:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800523c:	4b0a      	ldr	r3, [pc, #40]	; (8005268 <NVIC_SetPriorityGrouping+0x38>)
 800523e:	68db      	ldr	r3, [r3, #12]
 8005240:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8005242:	9a02      	ldr	r2, [sp, #8]
 8005244:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8005248:	4013      	ands	r3, r2
 800524a:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
 800524c:	9b03      	ldr	r3, [sp, #12]
 800524e:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8005250:	9b02      	ldr	r3, [sp, #8]
 8005252:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8005254:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8005258:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800525c:	9302      	str	r3, [sp, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800525e:	4a02      	ldr	r2, [pc, #8]	; (8005268 <NVIC_SetPriorityGrouping+0x38>)
 8005260:	9b02      	ldr	r3, [sp, #8]
 8005262:	60d3      	str	r3, [r2, #12]
}
 8005264:	b004      	add	sp, #16
 8005266:	4770      	bx	lr
 8005268:	e000ed00 	.word	0xe000ed00
 800526c:	00000000 	.word	0x00000000

08005270 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8005270:	b082      	sub	sp, #8
 8005272:	4603      	mov	r3, r0
 8005274:	9100      	str	r1, [sp, #0]
 8005276:	f88d 3007 	strb.w	r3, [sp, #7]
  if((int32_t)IRQn < 0) {
 800527a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 800527e:	2b00      	cmp	r3, #0
 8005280:	da0c      	bge.n	800529c <NVIC_SetPriority+0x2c>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8005282:	490c      	ldr	r1, [pc, #48]	; (80052b4 <NVIC_SetPriority+0x44>)
 8005284:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8005288:	f003 030f 	and.w	r3, r3, #15
 800528c:	3b04      	subs	r3, #4
 800528e:	9a00      	ldr	r2, [sp, #0]
 8005290:	b2d2      	uxtb	r2, r2
 8005292:	0112      	lsls	r2, r2, #4
 8005294:	b2d2      	uxtb	r2, r2
 8005296:	440b      	add	r3, r1
 8005298:	761a      	strb	r2, [r3, #24]
 800529a:	e009      	b.n	80052b0 <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800529c:	4906      	ldr	r1, [pc, #24]	; (80052b8 <NVIC_SetPriority+0x48>)
 800529e:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 80052a2:	9a00      	ldr	r2, [sp, #0]
 80052a4:	b2d2      	uxtb	r2, r2
 80052a6:	0112      	lsls	r2, r2, #4
 80052a8:	b2d2      	uxtb	r2, r2
 80052aa:	440b      	add	r3, r1
 80052ac:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 80052b0:	b002      	add	sp, #8
 80052b2:	4770      	bx	lr
 80052b4:	e000ed00 	.word	0xe000ed00
 80052b8:	e000e100 	.word	0xe000e100
 80052bc:	00000000 	.word	0x00000000

080052c0 <port_init>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 80052c0:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 80052c2:	4b0e      	ldr	r3, [pc, #56]	; (80052fc <port_init+0x3c>)
 80052c4:	2200      	movs	r2, #0
 80052c6:	609a      	str	r2, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 80052c8:	2003      	movs	r0, #3
 80052ca:	f7ff ffb1 	bl	8005230 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80052ce:	4a0c      	ldr	r2, [pc, #48]	; (8005300 <port_init+0x40>)
 80052d0:	4b0b      	ldr	r3, [pc, #44]	; (8005300 <port_init+0x40>)
 80052d2:	68db      	ldr	r3, [r3, #12]
 80052d4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80052d8:	60d3      	str	r3, [r2, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80052da:	4a0a      	ldr	r2, [pc, #40]	; (8005304 <port_init+0x44>)
 80052dc:	4b09      	ldr	r3, [pc, #36]	; (8005304 <port_init+0x44>)
 80052de:	681b      	ldr	r3, [r3, #0]
 80052e0:	f043 0301 	orr.w	r3, r3, #1
 80052e4:	6013      	str	r3, [r2, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 80052e6:	f06f 0004 	mvn.w	r0, #4
 80052ea:	2101      	movs	r1, #1
 80052ec:	f7ff ffc0 	bl	8005270 <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 80052f0:	f06f 0001 	mvn.w	r0, #1
 80052f4:	2102      	movs	r1, #2
 80052f6:	f7ff ffbb 	bl	8005270 <NVIC_SetPriority>
}
 80052fa:	bd08      	pop	{r3, pc}
 80052fc:	e000ed00 	.word	0xe000ed00
 8005300:	e000edf0 	.word	0xe000edf0
 8005304:	e0001000 	.word	0xe0001000
	...

08005310 <port_lock.lto_priv.272>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8005310:	b082      	sub	sp, #8
 8005312:	2320      	movs	r3, #32
 8005314:	9301      	str	r3, [sp, #4]
 8005316:	9b01      	ldr	r3, [sp, #4]
 8005318:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800531c:	b002      	add	sp, #8
 800531e:	4770      	bx	lr

08005320 <port_unlock.lto_priv.264>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005320:	b082      	sub	sp, #8
 8005322:	2300      	movs	r3, #0
 8005324:	9301      	str	r3, [sp, #4]
 8005326:	9b01      	ldr	r3, [sp, #4]
 8005328:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800532c:	b002      	add	sp, #8
 800532e:	4770      	bx	lr

08005330 <port_lock_from_isr.lto_priv.323>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8005330:	b508      	push	{r3, lr}

  port_lock();
 8005332:	f7ff ffed 	bl	8005310 <port_lock.lto_priv.272>
}
 8005336:	bd08      	pop	{r3, pc}
	...

08005340 <port_unlock_from_isr.lto_priv.321>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8005340:	b508      	push	{r3, lr}

  port_unlock();
 8005342:	f7ff ffed 	bl	8005320 <port_unlock.lto_priv.264>
}
 8005346:	bd08      	pop	{r3, pc}
	...

08005350 <port_disable>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005350:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8005352:	4770      	bx	lr
	...

08005360 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 8005360:	b082      	sub	sp, #8
 8005362:	2300      	movs	r3, #0
 8005364:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8005366:	9b01      	ldr	r3, [sp, #4]
 8005368:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800536c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 800536e:	b002      	add	sp, #8
 8005370:	4770      	bx	lr
 8005372:	bf00      	nop
	...

08005380 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8005380:	4770      	bx	lr
 8005382:	bf00      	nop
	...

08005390 <port_rt_get_counter_value.lto_priv.306>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8005390:	4b01      	ldr	r3, [pc, #4]	; (8005398 <port_rt_get_counter_value.lto_priv.306+0x8>)
 8005392:	685b      	ldr	r3, [r3, #4]
}
 8005394:	4618      	mov	r0, r3
 8005396:	4770      	bx	lr
 8005398:	e0001000 	.word	0xe0001000
 800539c:	00000000 	.word	0x00000000

080053a0 <st_lld_get_counter.lto_priv.314>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80053a0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80053a4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80053a6:	4618      	mov	r0, r3
 80053a8:	4770      	bx	lr
 80053aa:	bf00      	nop
 80053ac:	0000      	movs	r0, r0
	...

080053b0 <port_timer_stop_alarm.lto_priv.327>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 80053b0:	b508      	push	{r3, lr}

  stStopAlarm();
 80053b2:	f7ff fcbd 	bl	8004d30 <stStopAlarm>
}
 80053b6:	bd08      	pop	{r3, pc}
	...

080053c0 <port_timer_set_alarm.lto_priv.325>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 80053c0:	b500      	push	{lr}
 80053c2:	b083      	sub	sp, #12
 80053c4:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 80053c6:	9801      	ldr	r0, [sp, #4]
 80053c8:	f7ff fcba 	bl	8004d40 <stSetAlarm>
}
 80053cc:	b003      	add	sp, #12
 80053ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80053d2:	bf00      	nop
	...

080053e0 <port_timer_get_time.lto_priv.311>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 80053e0:	b508      	push	{r3, lr}

  return stGetCounter();
 80053e2:	f7ff ffdd 	bl	80053a0 <st_lld_get_counter.lto_priv.314>
 80053e6:	4603      	mov	r3, r0
}
 80053e8:	4618      	mov	r0, r3
 80053ea:	bd08      	pop	{r3, pc}
 80053ec:	0000      	movs	r0, r0
	...

080053f0 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 80053f0:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 80053f2:	f7ff ffb5 	bl	8005360 <port_enable>
}
 80053f6:	bd08      	pop	{r3, pc}
	...

08005400 <chSysLockFromISR.lto_priv.319>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8005400:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8005402:	f7ff ff95 	bl	8005330 <port_lock_from_isr.lto_priv.323>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8005406:	bd08      	pop	{r3, pc}
	...

08005410 <chSysUnlockFromISR.lto_priv.317>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8005410:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8005412:	f7ff ff95 	bl	8005340 <port_unlock_from_isr.lto_priv.321>
}
 8005416:	bd08      	pop	{r3, pc}
	...

08005420 <chVTGetSystemTimeX.lto_priv.308>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8005420:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8005422:	f7ff ffdd 	bl	80053e0 <port_timer_get_time.lto_priv.311>
 8005426:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8005428:	4618      	mov	r0, r3
 800542a:	bd08      	pop	{r3, pc}
 800542c:	0000      	movs	r0, r0
	...

08005430 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 8005430:	b500      	push	{lr}
 8005432:	b085      	sub	sp, #20
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8005434:	4b2a      	ldr	r3, [pc, #168]	; (80054e0 <chVTDoTickI+0xb0>)
 8005436:	69db      	ldr	r3, [r3, #28]
 8005438:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
 800543a:	f7ff fff1 	bl	8005420 <chVTGetSystemTimeX.lto_priv.308>
 800543e:	9002      	str	r0, [sp, #8]
 8005440:	e02a      	b.n	8005498 <chVTDoTickI+0x68>
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8005442:	4b27      	ldr	r3, [pc, #156]	; (80054e0 <chVTDoTickI+0xb0>)
 8005444:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8005446:	9b03      	ldr	r3, [sp, #12]
 8005448:	689b      	ldr	r3, [r3, #8]
 800544a:	4413      	add	r3, r2
 800544c:	4a24      	ldr	r2, [pc, #144]	; (80054e0 <chVTDoTickI+0xb0>)
 800544e:	6293      	str	r3, [r2, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8005450:	9b03      	ldr	r3, [sp, #12]
 8005452:	681b      	ldr	r3, [r3, #0]
 8005454:	4a23      	ldr	r2, [pc, #140]	; (80054e4 <chVTDoTickI+0xb4>)
 8005456:	605a      	str	r2, [r3, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 8005458:	9b03      	ldr	r3, [sp, #12]
 800545a:	681b      	ldr	r3, [r3, #0]
 800545c:	4a20      	ldr	r2, [pc, #128]	; (80054e0 <chVTDoTickI+0xb0>)
 800545e:	61d3      	str	r3, [r2, #28]
    fn = vtp->vt_func;
 8005460:	9b03      	ldr	r3, [sp, #12]
 8005462:	68db      	ldr	r3, [r3, #12]
 8005464:	9300      	str	r3, [sp, #0]
    vtp->vt_func = NULL;
 8005466:	9b03      	ldr	r3, [sp, #12]
 8005468:	2200      	movs	r2, #0
 800546a:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 800546c:	4b1c      	ldr	r3, [pc, #112]	; (80054e0 <chVTDoTickI+0xb0>)
 800546e:	69db      	ldr	r3, [r3, #28]
 8005470:	4a1c      	ldr	r2, [pc, #112]	; (80054e4 <chVTDoTickI+0xb4>)
 8005472:	4293      	cmp	r3, r2
 8005474:	d101      	bne.n	800547a <chVTDoTickI+0x4a>
      port_timer_stop_alarm();
 8005476:	f7ff ff9b 	bl	80053b0 <port_timer_stop_alarm.lto_priv.327>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
 800547a:	f7ff ffc9 	bl	8005410 <chSysUnlockFromISR.lto_priv.317>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 800547e:	9b03      	ldr	r3, [sp, #12]
 8005480:	691a      	ldr	r2, [r3, #16]
 8005482:	9b00      	ldr	r3, [sp, #0]
 8005484:	4610      	mov	r0, r2
 8005486:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
 8005488:	f7ff ffba 	bl	8005400 <chSysLockFromISR.lto_priv.319>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 800548c:	4b14      	ldr	r3, [pc, #80]	; (80054e0 <chVTDoTickI+0xb0>)
 800548e:	69db      	ldr	r3, [r3, #28]
 8005490:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
 8005492:	f7ff ffc5 	bl	8005420 <chVTGetSystemTimeX.lto_priv.308>
 8005496:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8005498:	9b03      	ldr	r3, [sp, #12]
 800549a:	689a      	ldr	r2, [r3, #8]
 800549c:	4b10      	ldr	r3, [pc, #64]	; (80054e0 <chVTDoTickI+0xb0>)
 800549e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80054a0:	9902      	ldr	r1, [sp, #8]
 80054a2:	1acb      	subs	r3, r1, r3
 80054a4:	429a      	cmp	r2, r3
 80054a6:	d9cc      	bls.n	8005442 <chVTDoTickI+0x12>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 80054a8:	4b0d      	ldr	r3, [pc, #52]	; (80054e0 <chVTDoTickI+0xb0>)
 80054aa:	69db      	ldr	r3, [r3, #28]
 80054ac:	4a0d      	ldr	r2, [pc, #52]	; (80054e4 <chVTDoTickI+0xb4>)
 80054ae:	4293      	cmp	r3, r2
 80054b0:	d012      	beq.n	80054d8 <chVTDoTickI+0xa8>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 80054b2:	4b0b      	ldr	r3, [pc, #44]	; (80054e0 <chVTDoTickI+0xb0>)
 80054b4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80054b6:	9b03      	ldr	r3, [sp, #12]
 80054b8:	689b      	ldr	r3, [r3, #8]
 80054ba:	441a      	add	r2, r3
 80054bc:	9b02      	ldr	r3, [sp, #8]
 80054be:	1ad3      	subs	r3, r2, r3
 80054c0:	9301      	str	r3, [sp, #4]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80054c2:	9b01      	ldr	r3, [sp, #4]
 80054c4:	2b01      	cmp	r3, #1
 80054c6:	d801      	bhi.n	80054cc <chVTDoTickI+0x9c>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 80054c8:	2302      	movs	r3, #2
 80054ca:	9301      	str	r3, [sp, #4]
  }
  port_timer_set_alarm(now + delta);
 80054cc:	9a02      	ldr	r2, [sp, #8]
 80054ce:	9b01      	ldr	r3, [sp, #4]
 80054d0:	4413      	add	r3, r2
 80054d2:	4618      	mov	r0, r3
 80054d4:	f7ff ff74 	bl	80053c0 <port_timer_set_alarm.lto_priv.325>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80054d8:	b005      	add	sp, #20
 80054da:	f85d fb04 	ldr.w	pc, [sp], #4
 80054de:	bf00      	nop
 80054e0:	20000808 	.word	0x20000808
 80054e4:	20000824 	.word	0x20000824
	...

080054f0 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 80054f0:	b082      	sub	sp, #8
 80054f2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 80054f4:	4b02      	ldr	r3, [pc, #8]	; (8005500 <chRegSetThreadName+0x10>)
 80054f6:	699b      	ldr	r3, [r3, #24]
 80054f8:	9a01      	ldr	r2, [sp, #4]
 80054fa:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 80054fc:	b002      	add	sp, #8
 80054fe:	4770      	bx	lr
 8005500:	20000808 	.word	0x20000808
	...

08005510 <chRegSetThreadNameX>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
 8005510:	b082      	sub	sp, #8
 8005512:	9001      	str	r0, [sp, #4]
 8005514:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8005516:	9b01      	ldr	r3, [sp, #4]
 8005518:	9a00      	ldr	r2, [sp, #0]
 800551a:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
 800551c:	b002      	add	sp, #8
 800551e:	4770      	bx	lr

08005520 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8005520:	b500      	push	{lr}
 8005522:	b083      	sub	sp, #12
 8005524:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8005526:	f7ff ff2b 	bl	8005380 <port_wait_for_interrupt>
 800552a:	e7fc      	b.n	8005526 <_idle_thread+0x6>
 800552c:	0000      	movs	r0, r0
	...

08005530 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8005530:	b500      	push	{lr}
 8005532:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 8005534:	f7ff fec4 	bl	80052c0 <port_init>
  _scheduler_init();
 8005538:	f000 fa5a 	bl	80059f0 <_scheduler_init>
  _vt_init();
 800553c:	f000 f8c0 	bl	80056c0 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 8005540:	f000 fdd6 	bl	80060f0 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 8005544:	f7ff fdf4 	bl	8005130 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 8005548:	f7ff fb12 	bl	8004b70 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 800554c:	480f      	ldr	r0, [pc, #60]	; (800558c <chSysInit+0x5c>)
 800554e:	2140      	movs	r1, #64	; 0x40
 8005550:	f000 fc3e 	bl	8005dd0 <_thread_init>
 8005554:	4602      	mov	r2, r0
 8005556:	4b0e      	ldr	r3, [pc, #56]	; (8005590 <chSysInit+0x60>)
 8005558:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 800555a:	4b0d      	ldr	r3, [pc, #52]	; (8005590 <chSysInit+0x60>)
 800555c:	699b      	ldr	r3, [r3, #24]
 800555e:	2201      	movs	r2, #1
 8005560:	771a      	strb	r2, [r3, #28]
#if CH_DBG_STATISTICS == TRUE
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->p_stats);
#endif

  chSysEnable();
 8005562:	f7ff ff45 	bl	80053f0 <chSysEnable>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
 8005566:	480b      	ldr	r0, [pc, #44]	; (8005594 <chSysInit+0x64>)
 8005568:	f7ff ffc2 	bl	80054f0 <chRegSetThreadName>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 800556c:	2300      	movs	r3, #0
 800556e:	9300      	str	r3, [sp, #0]
 8005570:	4809      	ldr	r0, [pc, #36]	; (8005598 <chSysInit+0x68>)
 8005572:	21d8      	movs	r1, #216	; 0xd8
 8005574:	2201      	movs	r2, #1
 8005576:	4b09      	ldr	r3, [pc, #36]	; (800559c <chSysInit+0x6c>)
 8005578:	f000 fcaa 	bl	8005ed0 <chThdCreateStatic>
 800557c:	9003      	str	r0, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
 800557e:	9803      	ldr	r0, [sp, #12]
 8005580:	4907      	ldr	r1, [pc, #28]	; (80055a0 <chSysInit+0x70>)
 8005582:	f7ff ffc5 	bl	8005510 <chRegSetThreadNameX>
  }
#endif
}
 8005586:	b005      	add	sp, #20
 8005588:	f85d fb04 	ldr.w	pc, [sp], #4
 800558c:	20000838 	.word	0x20000838
 8005590:	20000808 	.word	0x20000808
 8005594:	08006a60 	.word	0x08006a60
 8005598:	20000880 	.word	0x20000880
 800559c:	08005521 	.word	0x08005521
 80055a0:	080064f0 	.word	0x080064f0
	...

080055b0 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 80055b0:	b500      	push	{lr}
 80055b2:	b083      	sub	sp, #12
 80055b4:	9001      	str	r0, [sp, #4]

  port_disable();
 80055b6:	f7ff fecb 	bl	8005350 <port_disable>
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 80055ba:	4a02      	ldr	r2, [pc, #8]	; (80055c4 <chSysHalt+0x14>)
 80055bc:	9b01      	ldr	r3, [sp, #4]
 80055be:	62d3      	str	r3, [r2, #44]	; 0x2c
 80055c0:	e7fe      	b.n	80055c0 <chSysHalt+0x10>
 80055c2:	bf00      	nop
 80055c4:	20000808 	.word	0x20000808
	...

080055d0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 80055d0:	b508      	push	{r3, lr}
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
 80055d2:	f7ff ff2d 	bl	8005430 <chVTDoTickI>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 80055d6:	bd08      	pop	{r3, pc}
	...

080055e0 <chSysIsCounterWithinX>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {
 80055e0:	b084      	sub	sp, #16
 80055e2:	9003      	str	r0, [sp, #12]
 80055e4:	9102      	str	r1, [sp, #8]
 80055e6:	9201      	str	r2, [sp, #4]

  return (bool)((cnt - start) < (end - start));
 80055e8:	9a03      	ldr	r2, [sp, #12]
 80055ea:	9b02      	ldr	r3, [sp, #8]
 80055ec:	1ad2      	subs	r2, r2, r3
 80055ee:	9901      	ldr	r1, [sp, #4]
 80055f0:	9b02      	ldr	r3, [sp, #8]
 80055f2:	1acb      	subs	r3, r1, r3
 80055f4:	429a      	cmp	r2, r3
 80055f6:	bf34      	ite	cc
 80055f8:	2301      	movcc	r3, #1
 80055fa:	2300      	movcs	r3, #0
 80055fc:	b2db      	uxtb	r3, r3
}
 80055fe:	4618      	mov	r0, r3
 8005600:	b004      	add	sp, #16
 8005602:	4770      	bx	lr
	...

08005610 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 8005610:	b500      	push	{lr}
 8005612:	b085      	sub	sp, #20
 8005614:	9001      	str	r0, [sp, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
 8005616:	f7ff febb 	bl	8005390 <port_rt_get_counter_value.lto_priv.306>
 800561a:	9003      	str	r0, [sp, #12]
  rtcnt_t end  = start + cycles;
 800561c:	9a03      	ldr	r2, [sp, #12]
 800561e:	9b01      	ldr	r3, [sp, #4]
 8005620:	4413      	add	r3, r2
 8005622:	9302      	str	r3, [sp, #8]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8005624:	f7ff feb4 	bl	8005390 <port_rt_get_counter_value.lto_priv.306>
 8005628:	4603      	mov	r3, r0
 800562a:	4618      	mov	r0, r3
 800562c:	9903      	ldr	r1, [sp, #12]
 800562e:	9a02      	ldr	r2, [sp, #8]
 8005630:	f7ff ffd6 	bl	80055e0 <chSysIsCounterWithinX>
 8005634:	4603      	mov	r3, r0
 8005636:	2b00      	cmp	r3, #0
 8005638:	d1f4      	bne.n	8005624 <chSysPolledDelayX+0x14>
  }
}
 800563a:	b005      	add	sp, #20
 800563c:	f85d fb04 	ldr.w	pc, [sp], #4

08005640 <st_lld_get_counter.lto_priv.315>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8005640:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005644:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8005646:	4618      	mov	r0, r3
 8005648:	4770      	bx	lr
 800564a:	bf00      	nop
 800564c:	0000      	movs	r0, r0
	...

08005650 <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 8005650:	b500      	push	{lr}
 8005652:	b083      	sub	sp, #12
 8005654:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
 8005656:	9801      	ldr	r0, [sp, #4]
 8005658:	f7ff fb5a 	bl	8004d10 <stStartAlarm>
}
 800565c:	b003      	add	sp, #12
 800565e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005662:	bf00      	nop
	...

08005670 <port_timer_stop_alarm.lto_priv.328>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8005670:	b508      	push	{r3, lr}

  stStopAlarm();
 8005672:	f7ff fb5d 	bl	8004d30 <stStopAlarm>
}
 8005676:	bd08      	pop	{r3, pc}
	...

08005680 <port_timer_set_alarm.lto_priv.326>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8005680:	b500      	push	{lr}
 8005682:	b083      	sub	sp, #12
 8005684:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 8005686:	9801      	ldr	r0, [sp, #4]
 8005688:	f7ff fb5a 	bl	8004d40 <stSetAlarm>
}
 800568c:	b003      	add	sp, #12
 800568e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005692:	bf00      	nop
	...

080056a0 <port_timer_get_time.lto_priv.312>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 80056a0:	b508      	push	{r3, lr}

  return stGetCounter();
 80056a2:	f7ff ffcd 	bl	8005640 <st_lld_get_counter.lto_priv.315>
 80056a6:	4603      	mov	r3, r0
}
 80056a8:	4618      	mov	r0, r3
 80056aa:	bd08      	pop	{r3, pc}
 80056ac:	0000      	movs	r0, r0
	...

080056b0 <chVTGetSystemTimeX.lto_priv.309>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 80056b0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 80056b2:	f7ff fff5 	bl	80056a0 <port_timer_get_time.lto_priv.312>
 80056b6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80056b8:	4618      	mov	r0, r3
 80056ba:	bd08      	pop	{r3, pc}
 80056bc:	0000      	movs	r0, r0
	...

080056c0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 80056c0:	4b06      	ldr	r3, [pc, #24]	; (80056dc <_vt_init+0x1c>)
 80056c2:	4a07      	ldr	r2, [pc, #28]	; (80056e0 <_vt_init+0x20>)
 80056c4:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 80056c6:	4b05      	ldr	r3, [pc, #20]	; (80056dc <_vt_init+0x1c>)
 80056c8:	4a05      	ldr	r2, [pc, #20]	; (80056e0 <_vt_init+0x20>)
 80056ca:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 80056cc:	4b03      	ldr	r3, [pc, #12]	; (80056dc <_vt_init+0x1c>)
 80056ce:	f04f 32ff 	mov.w	r2, #4294967295
 80056d2:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 80056d4:	4b01      	ldr	r3, [pc, #4]	; (80056dc <_vt_init+0x1c>)
 80056d6:	2200      	movs	r2, #0
 80056d8:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80056da:	4770      	bx	lr
 80056dc:	20000808 	.word	0x20000808
 80056e0:	20000824 	.word	0x20000824
	...

080056f0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 80056f0:	b500      	push	{lr}
 80056f2:	b089      	sub	sp, #36	; 0x24
 80056f4:	9003      	str	r0, [sp, #12]
 80056f6:	9102      	str	r1, [sp, #8]
 80056f8:	9201      	str	r2, [sp, #4]
 80056fa:	9300      	str	r3, [sp, #0]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 80056fc:	9b03      	ldr	r3, [sp, #12]
 80056fe:	9a00      	ldr	r2, [sp, #0]
 8005700:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
 8005702:	9b03      	ldr	r3, [sp, #12]
 8005704:	9a01      	ldr	r2, [sp, #4]
 8005706:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 8005708:	f7ff ffd2 	bl	80056b0 <chVTGetSystemTimeX.lto_priv.309>
 800570c:	9005      	str	r0, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800570e:	9b02      	ldr	r3, [sp, #8]
 8005710:	2b01      	cmp	r3, #1
 8005712:	d801      	bhi.n	8005718 <chVTDoSetI+0x28>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8005714:	2302      	movs	r3, #2
 8005716:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8005718:	4b31      	ldr	r3, [pc, #196]	; (80057e0 <chVTDoSetI+0xf0>)
 800571a:	69db      	ldr	r3, [r3, #28]
 800571c:	4a31      	ldr	r2, [pc, #196]	; (80057e4 <chVTDoSetI+0xf4>)
 800571e:	4293      	cmp	r3, r2
 8005720:	d119      	bne.n	8005756 <chVTDoSetI+0x66>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 8005722:	4a2f      	ldr	r2, [pc, #188]	; (80057e0 <chVTDoSetI+0xf0>)
 8005724:	9b05      	ldr	r3, [sp, #20]
 8005726:	6293      	str	r3, [r2, #40]	; 0x28
      ch.vtlist.vt_next = vtp;
 8005728:	4a2d      	ldr	r2, [pc, #180]	; (80057e0 <chVTDoSetI+0xf0>)
 800572a:	9b03      	ldr	r3, [sp, #12]
 800572c:	61d3      	str	r3, [r2, #28]
      ch.vtlist.vt_prev = vtp;
 800572e:	4a2c      	ldr	r2, [pc, #176]	; (80057e0 <chVTDoSetI+0xf0>)
 8005730:	9b03      	ldr	r3, [sp, #12]
 8005732:	6213      	str	r3, [r2, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 8005734:	9b03      	ldr	r3, [sp, #12]
 8005736:	4a2b      	ldr	r2, [pc, #172]	; (80057e4 <chVTDoSetI+0xf4>)
 8005738:	601a      	str	r2, [r3, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800573a:	9b03      	ldr	r3, [sp, #12]
 800573c:	4a29      	ldr	r2, [pc, #164]	; (80057e4 <chVTDoSetI+0xf4>)
 800573e:	605a      	str	r2, [r3, #4]
      vtp->vt_delta = delay;
 8005740:	9b03      	ldr	r3, [sp, #12]
 8005742:	9a02      	ldr	r2, [sp, #8]
 8005744:	609a      	str	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 8005746:	4b26      	ldr	r3, [pc, #152]	; (80057e0 <chVTDoSetI+0xf0>)
 8005748:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800574a:	9b02      	ldr	r3, [sp, #8]
 800574c:	4413      	add	r3, r2
 800574e:	4618      	mov	r0, r3
 8005750:	f7ff ff7e 	bl	8005650 <port_timer_start_alarm>
 8005754:	e040      	b.n	80057d8 <chVTDoSetI+0xe8>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8005756:	9a05      	ldr	r2, [sp, #20]
 8005758:	9b02      	ldr	r3, [sp, #8]
 800575a:	441a      	add	r2, r3
 800575c:	4b20      	ldr	r3, [pc, #128]	; (80057e0 <chVTDoSetI+0xf0>)
 800575e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005760:	1ad3      	subs	r3, r2, r3
 8005762:	9306      	str	r3, [sp, #24]
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8005764:	4b1e      	ldr	r3, [pc, #120]	; (80057e0 <chVTDoSetI+0xf0>)
 8005766:	69db      	ldr	r3, [r3, #28]
 8005768:	689a      	ldr	r2, [r3, #8]
 800576a:	9b06      	ldr	r3, [sp, #24]
 800576c:	429a      	cmp	r2, r3
 800576e:	d906      	bls.n	800577e <chVTDoSetI+0x8e>

      /* New alarm deadline.*/
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
 8005770:	4b1b      	ldr	r3, [pc, #108]	; (80057e0 <chVTDoSetI+0xf0>)
 8005772:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8005774:	9b06      	ldr	r3, [sp, #24]
 8005776:	4413      	add	r3, r2
 8005778:	4618      	mov	r0, r3
 800577a:	f7ff ff81 	bl	8005680 <port_timer_set_alarm.lto_priv.326>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 800577e:	4b18      	ldr	r3, [pc, #96]	; (80057e0 <chVTDoSetI+0xf0>)
 8005780:	69db      	ldr	r3, [r3, #28]
 8005782:	9307      	str	r3, [sp, #28]
 8005784:	e007      	b.n	8005796 <chVTDoSetI+0xa6>
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 8005786:	9b07      	ldr	r3, [sp, #28]
 8005788:	689b      	ldr	r3, [r3, #8]
 800578a:	9a06      	ldr	r2, [sp, #24]
 800578c:	1ad3      	subs	r3, r2, r3
 800578e:	9306      	str	r3, [sp, #24]
    p = p->vt_next;
 8005790:	9b07      	ldr	r3, [sp, #28]
 8005792:	681b      	ldr	r3, [r3, #0]
 8005794:	9307      	str	r3, [sp, #28]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8005796:	9b07      	ldr	r3, [sp, #28]
 8005798:	689a      	ldr	r2, [r3, #8]
 800579a:	9b06      	ldr	r3, [sp, #24]
 800579c:	429a      	cmp	r2, r3
 800579e:	d3f2      	bcc.n	8005786 <chVTDoSetI+0x96>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 80057a0:	9b03      	ldr	r3, [sp, #12]
 80057a2:	9a07      	ldr	r2, [sp, #28]
 80057a4:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 80057a6:	9b03      	ldr	r3, [sp, #12]
 80057a8:	681b      	ldr	r3, [r3, #0]
 80057aa:	685a      	ldr	r2, [r3, #4]
 80057ac:	9b03      	ldr	r3, [sp, #12]
 80057ae:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
 80057b0:	9b03      	ldr	r3, [sp, #12]
 80057b2:	685b      	ldr	r3, [r3, #4]
 80057b4:	9a03      	ldr	r2, [sp, #12]
 80057b6:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
 80057b8:	9b07      	ldr	r3, [sp, #28]
 80057ba:	9a03      	ldr	r2, [sp, #12]
 80057bc:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
 80057be:	9b03      	ldr	r3, [sp, #12]
 80057c0:	9a06      	ldr	r2, [sp, #24]
 80057c2:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 80057c4:	9b07      	ldr	r3, [sp, #28]
 80057c6:	689a      	ldr	r2, [r3, #8]
 80057c8:	9b06      	ldr	r3, [sp, #24]
 80057ca:	1ad2      	subs	r2, r2, r3
 80057cc:	9b07      	ldr	r3, [sp, #28]
 80057ce:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 80057d0:	4b03      	ldr	r3, [pc, #12]	; (80057e0 <chVTDoSetI+0xf0>)
 80057d2:	f04f 32ff 	mov.w	r2, #4294967295
 80057d6:	625a      	str	r2, [r3, #36]	; 0x24
}
 80057d8:	b009      	add	sp, #36	; 0x24
 80057da:	f85d fb04 	ldr.w	pc, [sp], #4
 80057de:	bf00      	nop
 80057e0:	20000808 	.word	0x20000808
 80057e4:	20000824 	.word	0x20000824
	...

080057f0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 80057f0:	b500      	push	{lr}
 80057f2:	b085      	sub	sp, #20
 80057f4:	9001      	str	r0, [sp, #4]
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 80057f6:	4b30      	ldr	r3, [pc, #192]	; (80058b8 <chVTDoResetI+0xc8>)
 80057f8:	69da      	ldr	r2, [r3, #28]
 80057fa:	9b01      	ldr	r3, [sp, #4]
 80057fc:	429a      	cmp	r2, r3
 80057fe:	d01b      	beq.n	8005838 <chVTDoResetI+0x48>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8005800:	9b01      	ldr	r3, [sp, #4]
 8005802:	685b      	ldr	r3, [r3, #4]
 8005804:	9a01      	ldr	r2, [sp, #4]
 8005806:	6812      	ldr	r2, [r2, #0]
 8005808:	601a      	str	r2, [r3, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 800580a:	9b01      	ldr	r3, [sp, #4]
 800580c:	681b      	ldr	r3, [r3, #0]
 800580e:	9a01      	ldr	r2, [sp, #4]
 8005810:	6852      	ldr	r2, [r2, #4]
 8005812:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
 8005814:	9b01      	ldr	r3, [sp, #4]
 8005816:	2200      	movs	r2, #0
 8005818:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 800581a:	9b01      	ldr	r3, [sp, #4]
 800581c:	681b      	ldr	r3, [r3, #0]
 800581e:	4a27      	ldr	r2, [pc, #156]	; (80058bc <chVTDoResetI+0xcc>)
 8005820:	4293      	cmp	r3, r2
 8005822:	d046      	beq.n	80058b2 <chVTDoResetI+0xc2>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 8005824:	9b01      	ldr	r3, [sp, #4]
 8005826:	681b      	ldr	r3, [r3, #0]
 8005828:	9a01      	ldr	r2, [sp, #4]
 800582a:	6812      	ldr	r2, [r2, #0]
 800582c:	6891      	ldr	r1, [r2, #8]
 800582e:	9a01      	ldr	r2, [sp, #4]
 8005830:	6892      	ldr	r2, [r2, #8]
 8005832:	440a      	add	r2, r1
 8005834:	609a      	str	r2, [r3, #8]
 8005836:	e03c      	b.n	80058b2 <chVTDoResetI+0xc2>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 8005838:	9b01      	ldr	r3, [sp, #4]
 800583a:	681b      	ldr	r3, [r3, #0]
 800583c:	4a1e      	ldr	r2, [pc, #120]	; (80058b8 <chVTDoResetI+0xc8>)
 800583e:	61d3      	str	r3, [r2, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8005840:	4b1d      	ldr	r3, [pc, #116]	; (80058b8 <chVTDoResetI+0xc8>)
 8005842:	69db      	ldr	r3, [r3, #28]
 8005844:	4a1d      	ldr	r2, [pc, #116]	; (80058bc <chVTDoResetI+0xcc>)
 8005846:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 8005848:	9b01      	ldr	r3, [sp, #4]
 800584a:	2200      	movs	r2, #0
 800584c:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800584e:	4b1a      	ldr	r3, [pc, #104]	; (80058b8 <chVTDoResetI+0xc8>)
 8005850:	69db      	ldr	r3, [r3, #28]
 8005852:	4a1a      	ldr	r2, [pc, #104]	; (80058bc <chVTDoResetI+0xcc>)
 8005854:	4293      	cmp	r3, r2
 8005856:	d102      	bne.n	800585e <chVTDoResetI+0x6e>
    port_timer_stop_alarm();
 8005858:	f7ff ff0a 	bl	8005670 <port_timer_stop_alarm.lto_priv.328>
 800585c:	e029      	b.n	80058b2 <chVTDoResetI+0xc2>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 800585e:	4b16      	ldr	r3, [pc, #88]	; (80058b8 <chVTDoResetI+0xc8>)
 8005860:	69db      	ldr	r3, [r3, #28]
 8005862:	4a15      	ldr	r2, [pc, #84]	; (80058b8 <chVTDoResetI+0xc8>)
 8005864:	69d2      	ldr	r2, [r2, #28]
 8005866:	6891      	ldr	r1, [r2, #8]
 8005868:	9a01      	ldr	r2, [sp, #4]
 800586a:	6892      	ldr	r2, [r2, #8]
 800586c:	440a      	add	r2, r1
 800586e:	609a      	str	r2, [r3, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 8005870:	f7ff ff1e 	bl	80056b0 <chVTGetSystemTimeX.lto_priv.309>
 8005874:	4602      	mov	r2, r0
 8005876:	4b10      	ldr	r3, [pc, #64]	; (80058b8 <chVTDoResetI+0xc8>)
 8005878:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800587a:	1ad3      	subs	r3, r2, r3
 800587c:	9302      	str	r3, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 800587e:	4b0e      	ldr	r3, [pc, #56]	; (80058b8 <chVTDoResetI+0xc8>)
 8005880:	69db      	ldr	r3, [r3, #28]
 8005882:	689a      	ldr	r2, [r3, #8]
 8005884:	9b02      	ldr	r3, [sp, #8]
 8005886:	429a      	cmp	r2, r3
 8005888:	d913      	bls.n	80058b2 <chVTDoResetI+0xc2>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 800588a:	4b0b      	ldr	r3, [pc, #44]	; (80058b8 <chVTDoResetI+0xc8>)
 800588c:	69db      	ldr	r3, [r3, #28]
 800588e:	689a      	ldr	r2, [r3, #8]
 8005890:	9b02      	ldr	r3, [sp, #8]
 8005892:	1ad3      	subs	r3, r2, r3
 8005894:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8005896:	9b03      	ldr	r3, [sp, #12]
 8005898:	2b01      	cmp	r3, #1
 800589a:	d801      	bhi.n	80058a0 <chVTDoResetI+0xb0>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800589c:	2302      	movs	r3, #2
 800589e:	9303      	str	r3, [sp, #12]
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 80058a0:	4b05      	ldr	r3, [pc, #20]	; (80058b8 <chVTDoResetI+0xc8>)
 80058a2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80058a4:	9b02      	ldr	r3, [sp, #8]
 80058a6:	441a      	add	r2, r3
 80058a8:	9b03      	ldr	r3, [sp, #12]
 80058aa:	4413      	add	r3, r2
 80058ac:	4618      	mov	r0, r3
 80058ae:	f7ff fee7 	bl	8005680 <port_timer_set_alarm.lto_priv.326>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80058b2:	b005      	add	sp, #20
 80058b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80058b8:	20000808 	.word	0x20000808
 80058bc:	20000824 	.word	0x20000824

080058c0 <port_lock.lto_priv.273>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80058c0:	b082      	sub	sp, #8
 80058c2:	2320      	movs	r3, #32
 80058c4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80058c6:	9b01      	ldr	r3, [sp, #4]
 80058c8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80058cc:	b002      	add	sp, #8
 80058ce:	4770      	bx	lr

080058d0 <port_unlock.lto_priv.265>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80058d0:	b082      	sub	sp, #8
 80058d2:	2300      	movs	r3, #0
 80058d4:	9301      	str	r3, [sp, #4]
 80058d6:	9b01      	ldr	r3, [sp, #4]
 80058d8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80058dc:	b002      	add	sp, #8
 80058de:	4770      	bx	lr

080058e0 <port_lock_from_isr.lto_priv.324>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80058e0:	b508      	push	{r3, lr}

  port_lock();
 80058e2:	f7ff ffed 	bl	80058c0 <port_lock.lto_priv.273>
}
 80058e6:	bd08      	pop	{r3, pc}
	...

080058f0 <port_unlock_from_isr.lto_priv.322>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80058f0:	b508      	push	{r3, lr}

  port_unlock();
 80058f2:	f7ff ffed 	bl	80058d0 <port_unlock.lto_priv.265>
}
 80058f6:	bd08      	pop	{r3, pc}
	...

08005900 <queue_init.lto_priv.300>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8005900:	b082      	sub	sp, #8
 8005902:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8005904:	9b01      	ldr	r3, [sp, #4]
 8005906:	9a01      	ldr	r2, [sp, #4]
 8005908:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800590a:	9b01      	ldr	r3, [sp, #4]
 800590c:	9a01      	ldr	r2, [sp, #4]
 800590e:	605a      	str	r2, [r3, #4]
}
 8005910:	b002      	add	sp, #8
 8005912:	4770      	bx	lr
	...

08005920 <queue_fifo_remove.lto_priv.294>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8005920:	b084      	sub	sp, #16
 8005922:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8005924:	9b01      	ldr	r3, [sp, #4]
 8005926:	681b      	ldr	r3, [r3, #0]
 8005928:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800592a:	9b03      	ldr	r3, [sp, #12]
 800592c:	681a      	ldr	r2, [r3, #0]
 800592e:	9b01      	ldr	r3, [sp, #4]
 8005930:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8005932:	9b01      	ldr	r3, [sp, #4]
 8005934:	681b      	ldr	r3, [r3, #0]
 8005936:	9a01      	ldr	r2, [sp, #4]
 8005938:	605a      	str	r2, [r3, #4]

  return tp;
 800593a:	9b03      	ldr	r3, [sp, #12]
}
 800593c:	4618      	mov	r0, r3
 800593e:	b004      	add	sp, #16
 8005940:	4770      	bx	lr
 8005942:	bf00      	nop
	...

08005950 <queue_dequeue.lto_priv.292>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8005950:	b082      	sub	sp, #8
 8005952:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8005954:	9b01      	ldr	r3, [sp, #4]
 8005956:	685b      	ldr	r3, [r3, #4]
 8005958:	9a01      	ldr	r2, [sp, #4]
 800595a:	6812      	ldr	r2, [r2, #0]
 800595c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 800595e:	9b01      	ldr	r3, [sp, #4]
 8005960:	681b      	ldr	r3, [r3, #0]
 8005962:	9a01      	ldr	r2, [sp, #4]
 8005964:	6852      	ldr	r2, [r2, #4]
 8005966:	605a      	str	r2, [r3, #4]

  return tp;
 8005968:	9b01      	ldr	r3, [sp, #4]
}
 800596a:	4618      	mov	r0, r3
 800596c:	b002      	add	sp, #8
 800596e:	4770      	bx	lr

08005970 <chSchIsRescRequiredI>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8005970:	4b06      	ldr	r3, [pc, #24]	; (800598c <chSchIsRescRequiredI+0x1c>)
 8005972:	681b      	ldr	r3, [r3, #0]
 8005974:	689a      	ldr	r2, [r3, #8]
 8005976:	4b05      	ldr	r3, [pc, #20]	; (800598c <chSchIsRescRequiredI+0x1c>)
 8005978:	699b      	ldr	r3, [r3, #24]
 800597a:	689b      	ldr	r3, [r3, #8]
 800597c:	429a      	cmp	r2, r3
 800597e:	bf8c      	ite	hi
 8005980:	2301      	movhi	r3, #1
 8005982:	2300      	movls	r3, #0
 8005984:	b2db      	uxtb	r3, r3
}
 8005986:	4618      	mov	r0, r3
 8005988:	4770      	bx	lr
 800598a:	bf00      	nop
 800598c:	20000808 	.word	0x20000808

08005990 <chSysLockFromISR.lto_priv.320>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8005990:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8005992:	f7ff ffa5 	bl	80058e0 <port_lock_from_isr.lto_priv.324>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8005996:	bd08      	pop	{r3, pc}
	...

080059a0 <chSysUnlockFromISR.lto_priv.318>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80059a0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80059a2:	f7ff ffa5 	bl	80058f0 <port_unlock_from_isr.lto_priv.322>
}
 80059a6:	bd08      	pop	{r3, pc}
	...

080059b0 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 80059b0:	b082      	sub	sp, #8
 80059b2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 80059b4:	9b01      	ldr	r3, [sp, #4]
 80059b6:	68db      	ldr	r3, [r3, #12]
 80059b8:	2b00      	cmp	r3, #0
 80059ba:	bf14      	ite	ne
 80059bc:	2301      	movne	r3, #1
 80059be:	2300      	moveq	r3, #0
 80059c0:	b2db      	uxtb	r3, r3
}
 80059c2:	4618      	mov	r0, r3
 80059c4:	b002      	add	sp, #8
 80059c6:	4770      	bx	lr
	...

080059d0 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 80059d0:	b082      	sub	sp, #8
 80059d2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->s_cnt++;
 80059d4:	9b01      	ldr	r3, [sp, #4]
 80059d6:	689b      	ldr	r3, [r3, #8]
 80059d8:	1c5a      	adds	r2, r3, #1
 80059da:	9b01      	ldr	r3, [sp, #4]
 80059dc:	609a      	str	r2, [r3, #8]
}
 80059de:	b002      	add	sp, #8
 80059e0:	4770      	bx	lr
 80059e2:	bf00      	nop
	...

080059f0 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 80059f0:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
 80059f2:	4806      	ldr	r0, [pc, #24]	; (8005a0c <_scheduler_init+0x1c>)
 80059f4:	f7ff ff84 	bl	8005900 <queue_init.lto_priv.300>
  ch.rlist.r_prio = NOPRIO;
 80059f8:	4b04      	ldr	r3, [pc, #16]	; (8005a0c <_scheduler_init+0x1c>)
 80059fa:	2200      	movs	r2, #0
 80059fc:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 80059fe:	4b03      	ldr	r3, [pc, #12]	; (8005a0c <_scheduler_init+0x1c>)
 8005a00:	4a02      	ldr	r2, [pc, #8]	; (8005a0c <_scheduler_init+0x1c>)
 8005a02:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 8005a04:	4b01      	ldr	r3, [pc, #4]	; (8005a0c <_scheduler_init+0x1c>)
 8005a06:	4a01      	ldr	r2, [pc, #4]	; (8005a0c <_scheduler_init+0x1c>)
 8005a08:	615a      	str	r2, [r3, #20]
#endif
}
 8005a0a:	bd08      	pop	{r3, pc}
 8005a0c:	20000808 	.word	0x20000808

08005a10 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8005a10:	b084      	sub	sp, #16
 8005a12:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8005a14:	9b01      	ldr	r3, [sp, #4]
 8005a16:	2200      	movs	r2, #0
 8005a18:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8005a1a:	4b0e      	ldr	r3, [pc, #56]	; (8005a54 <chSchReadyI+0x44>)
 8005a1c:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 8005a1e:	9b03      	ldr	r3, [sp, #12]
 8005a20:	681b      	ldr	r3, [r3, #0]
 8005a22:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
 8005a24:	9b03      	ldr	r3, [sp, #12]
 8005a26:	689a      	ldr	r2, [r3, #8]
 8005a28:	9b01      	ldr	r3, [sp, #4]
 8005a2a:	689b      	ldr	r3, [r3, #8]
 8005a2c:	429a      	cmp	r2, r3
 8005a2e:	d2f6      	bcs.n	8005a1e <chSchReadyI+0xe>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8005a30:	9b01      	ldr	r3, [sp, #4]
 8005a32:	9a03      	ldr	r2, [sp, #12]
 8005a34:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8005a36:	9b03      	ldr	r3, [sp, #12]
 8005a38:	685a      	ldr	r2, [r3, #4]
 8005a3a:	9b01      	ldr	r3, [sp, #4]
 8005a3c:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8005a3e:	9b01      	ldr	r3, [sp, #4]
 8005a40:	685b      	ldr	r3, [r3, #4]
 8005a42:	9a01      	ldr	r2, [sp, #4]
 8005a44:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 8005a46:	9b03      	ldr	r3, [sp, #12]
 8005a48:	9a01      	ldr	r2, [sp, #4]
 8005a4a:	605a      	str	r2, [r3, #4]

  return tp;
 8005a4c:	9b01      	ldr	r3, [sp, #4]
}
 8005a4e:	4618      	mov	r0, r3
 8005a50:	b004      	add	sp, #16
 8005a52:	4770      	bx	lr
 8005a54:	20000808 	.word	0x20000808
	...

08005a60 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8005a60:	b500      	push	{lr}
 8005a62:	b085      	sub	sp, #20
 8005a64:	4603      	mov	r3, r0
 8005a66:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8005a6a:	4b0d      	ldr	r3, [pc, #52]	; (8005aa0 <chSchGoSleepS+0x40>)
 8005a6c:	699b      	ldr	r3, [r3, #24]
 8005a6e:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
 8005a70:	9b03      	ldr	r3, [sp, #12]
 8005a72:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8005a76:	771a      	strb	r2, [r3, #28]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8005a78:	4809      	ldr	r0, [pc, #36]	; (8005aa0 <chSchGoSleepS+0x40>)
 8005a7a:	f7ff ff51 	bl	8005920 <queue_fifo_remove.lto_priv.294>
 8005a7e:	4602      	mov	r2, r0
 8005a80:	4b07      	ldr	r3, [pc, #28]	; (8005aa0 <chSchGoSleepS+0x40>)
 8005a82:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8005a84:	4b06      	ldr	r3, [pc, #24]	; (8005aa0 <chSchGoSleepS+0x40>)
 8005a86:	699b      	ldr	r3, [r3, #24]
 8005a88:	2201      	movs	r2, #1
 8005a8a:	771a      	strb	r2, [r3, #28]
  chSysSwitch(currp, otp);
 8005a8c:	4b04      	ldr	r3, [pc, #16]	; (8005aa0 <chSchGoSleepS+0x40>)
 8005a8e:	699b      	ldr	r3, [r3, #24]
 8005a90:	4618      	mov	r0, r3
 8005a92:	9903      	ldr	r1, [sp, #12]
 8005a94:	f7fa fbfc 	bl	8000290 <_port_switch>
}
 8005a98:	b005      	add	sp, #20
 8005a9a:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a9e:	bf00      	nop
 8005aa0:	20000808 	.word	0x20000808
	...

08005ab0 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8005ab0:	b500      	push	{lr}
 8005ab2:	b085      	sub	sp, #20
 8005ab4:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8005ab6:	9b01      	ldr	r3, [sp, #4]
 8005ab8:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 8005aba:	f7ff ff69 	bl	8005990 <chSysLockFromISR.lto_priv.320>
  switch (tp->p_state) {
 8005abe:	9b03      	ldr	r3, [sp, #12]
 8005ac0:	7f1b      	ldrb	r3, [r3, #28]
 8005ac2:	2b07      	cmp	r3, #7
 8005ac4:	d822      	bhi.n	8005b0c <wakeup+0x5c>
 8005ac6:	a201      	add	r2, pc, #4	; (adr r2, 8005acc <wakeup+0x1c>)
 8005ac8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005acc:	08005aed 	.word	0x08005aed
 8005ad0:	08005b0d 	.word	0x08005b0d
 8005ad4:	08005b0d 	.word	0x08005b0d
 8005ad8:	08005af3 	.word	0x08005af3
 8005adc:	08005b07 	.word	0x08005b07
 8005ae0:	08005afd 	.word	0x08005afd
 8005ae4:	08005b0d 	.word	0x08005b0d
 8005ae8:	08005b07 	.word	0x08005b07
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8005aec:	f7ff ff58 	bl	80059a0 <chSysUnlockFromISR.lto_priv.318>
 8005af0:	e015      	b.n	8005b1e <wakeup+0x6e>
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8005af2:	9b03      	ldr	r3, [sp, #12]
 8005af4:	6a1b      	ldr	r3, [r3, #32]
 8005af6:	2200      	movs	r2, #0
 8005af8:	601a      	str	r2, [r3, #0]
 8005afa:	e007      	b.n	8005b0c <wakeup+0x5c>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8005afc:	9b03      	ldr	r3, [sp, #12]
 8005afe:	6a1b      	ldr	r3, [r3, #32]
 8005b00:	4618      	mov	r0, r3
 8005b02:	f7ff ff65 	bl	80059d0 <chSemFastSignalI>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 8005b06:	9803      	ldr	r0, [sp, #12]
 8005b08:	f7ff ff22 	bl	8005950 <queue_dequeue.lto_priv.292>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8005b0c:	9b03      	ldr	r3, [sp, #12]
 8005b0e:	f04f 32ff 	mov.w	r2, #4294967295
 8005b12:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 8005b14:	9803      	ldr	r0, [sp, #12]
 8005b16:	f7ff ff7b 	bl	8005a10 <chSchReadyI>
  chSysUnlockFromISR();
 8005b1a:	f7ff ff41 	bl	80059a0 <chSysUnlockFromISR.lto_priv.318>
}
 8005b1e:	b005      	add	sp, #20
 8005b20:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08005b30 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8005b30:	b500      	push	{lr}
 8005b32:	b089      	sub	sp, #36	; 0x24
 8005b34:	4603      	mov	r3, r0
 8005b36:	9100      	str	r1, [sp, #0]
 8005b38:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8005b3c:	9b00      	ldr	r3, [sp, #0]
 8005b3e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005b42:	d018      	beq.n	8005b76 <chSchGoSleepTimeoutS+0x46>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8005b44:	4b12      	ldr	r3, [pc, #72]	; (8005b90 <chSchGoSleepTimeoutS+0x60>)
 8005b46:	699b      	ldr	r3, [r3, #24]
 8005b48:	aa03      	add	r2, sp, #12
 8005b4a:	4610      	mov	r0, r2
 8005b4c:	9900      	ldr	r1, [sp, #0]
 8005b4e:	4a11      	ldr	r2, [pc, #68]	; (8005b94 <chSchGoSleepTimeoutS+0x64>)
 8005b50:	f7ff fdce 	bl	80056f0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8005b54:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8005b58:	4618      	mov	r0, r3
 8005b5a:	f7ff ff81 	bl	8005a60 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8005b5e:	ab03      	add	r3, sp, #12
 8005b60:	4618      	mov	r0, r3
 8005b62:	f7ff ff25 	bl	80059b0 <chVTIsArmedI>
 8005b66:	4603      	mov	r3, r0
 8005b68:	2b00      	cmp	r3, #0
 8005b6a:	d009      	beq.n	8005b80 <chSchGoSleepTimeoutS+0x50>
      chVTDoResetI(&vt);
 8005b6c:	ab03      	add	r3, sp, #12
 8005b6e:	4618      	mov	r0, r3
 8005b70:	f7ff fe3e 	bl	80057f0 <chVTDoResetI>
 8005b74:	e004      	b.n	8005b80 <chSchGoSleepTimeoutS+0x50>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8005b76:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8005b7a:	4618      	mov	r0, r3
 8005b7c:	f7ff ff70 	bl	8005a60 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8005b80:	4b03      	ldr	r3, [pc, #12]	; (8005b90 <chSchGoSleepTimeoutS+0x60>)
 8005b82:	699b      	ldr	r3, [r3, #24]
 8005b84:	6a1b      	ldr	r3, [r3, #32]
}
 8005b86:	4618      	mov	r0, r3
 8005b88:	b009      	add	sp, #36	; 0x24
 8005b8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8005b8e:	bf00      	nop
 8005b90:	20000808 	.word	0x20000808
 8005b94:	08005ab1 	.word	0x08005ab1
	...

08005ba0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8005ba0:	b500      	push	{lr}
 8005ba2:	b085      	sub	sp, #20
 8005ba4:	9001      	str	r0, [sp, #4]
 8005ba6:	9100      	str	r1, [sp, #0]
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8005ba8:	9b01      	ldr	r3, [sp, #4]
 8005baa:	9a00      	ldr	r2, [sp, #0]
 8005bac:	621a      	str	r2, [r3, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8005bae:	9b01      	ldr	r3, [sp, #4]
 8005bb0:	689a      	ldr	r2, [r3, #8]
 8005bb2:	4b0e      	ldr	r3, [pc, #56]	; (8005bec <chSchWakeupS+0x4c>)
 8005bb4:	699b      	ldr	r3, [r3, #24]
 8005bb6:	689b      	ldr	r3, [r3, #8]
 8005bb8:	429a      	cmp	r2, r3
 8005bba:	d803      	bhi.n	8005bc4 <chSchWakeupS+0x24>
    (void) chSchReadyI(ntp);
 8005bbc:	9801      	ldr	r0, [sp, #4]
 8005bbe:	f7ff ff27 	bl	8005a10 <chSchReadyI>
 8005bc2:	e00f      	b.n	8005be4 <chSchWakeupS+0x44>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8005bc4:	4b09      	ldr	r3, [pc, #36]	; (8005bec <chSchWakeupS+0x4c>)
 8005bc6:	699b      	ldr	r3, [r3, #24]
 8005bc8:	4618      	mov	r0, r3
 8005bca:	f7ff ff21 	bl	8005a10 <chSchReadyI>
 8005bce:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
 8005bd0:	4a06      	ldr	r2, [pc, #24]	; (8005bec <chSchWakeupS+0x4c>)
 8005bd2:	9b01      	ldr	r3, [sp, #4]
 8005bd4:	6193      	str	r3, [r2, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8005bd6:	9b01      	ldr	r3, [sp, #4]
 8005bd8:	2201      	movs	r2, #1
 8005bda:	771a      	strb	r2, [r3, #28]
    chSysSwitch(ntp, otp);
 8005bdc:	9801      	ldr	r0, [sp, #4]
 8005bde:	9903      	ldr	r1, [sp, #12]
 8005be0:	f7fa fb56 	bl	8000290 <_port_switch>
  }
}
 8005be4:	b005      	add	sp, #20
 8005be6:	f85d fb04 	ldr.w	pc, [sp], #4
 8005bea:	bf00      	nop
 8005bec:	20000808 	.word	0x20000808

08005bf0 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8005bf0:	b508      	push	{r3, lr}

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8005bf2:	f7ff febd 	bl	8005970 <chSchIsRescRequiredI>
 8005bf6:	4603      	mov	r3, r0
 8005bf8:	2b00      	cmp	r3, #0
 8005bfa:	d001      	beq.n	8005c00 <chSchRescheduleS+0x10>
    chSchDoRescheduleAhead();
 8005bfc:	f000 f820 	bl	8005c40 <chSchDoRescheduleAhead>
  }
}
 8005c00:	bd08      	pop	{r3, pc}
 8005c02:	bf00      	nop
	...

08005c10 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8005c10:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8005c12:	4b09      	ldr	r3, [pc, #36]	; (8005c38 <chSchIsPreemptionRequired+0x28>)
 8005c14:	681b      	ldr	r3, [r3, #0]
 8005c16:	689b      	ldr	r3, [r3, #8]
 8005c18:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
 8005c1a:	4b07      	ldr	r3, [pc, #28]	; (8005c38 <chSchIsPreemptionRequired+0x28>)
 8005c1c:	699b      	ldr	r3, [r3, #24]
 8005c1e:	689b      	ldr	r3, [r3, #8]
 8005c20:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8005c22:	9a01      	ldr	r2, [sp, #4]
 8005c24:	9b00      	ldr	r3, [sp, #0]
 8005c26:	429a      	cmp	r2, r3
 8005c28:	bf8c      	ite	hi
 8005c2a:	2301      	movhi	r3, #1
 8005c2c:	2300      	movls	r3, #0
 8005c2e:	b2db      	uxtb	r3, r3
#endif
}
 8005c30:	4618      	mov	r0, r3
 8005c32:	b002      	add	sp, #8
 8005c34:	4770      	bx	lr
 8005c36:	bf00      	nop
 8005c38:	20000808 	.word	0x20000808
 8005c3c:	00000000 	.word	0x00000000

08005c40 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8005c40:	b500      	push	{lr}
 8005c42:	b083      	sub	sp, #12
  thread_t *otp, *cp;

  otp = currp;
 8005c44:	4b18      	ldr	r3, [pc, #96]	; (8005ca8 <chSchDoRescheduleAhead+0x68>)
 8005c46:	699b      	ldr	r3, [r3, #24]
 8005c48:	9300      	str	r3, [sp, #0]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8005c4a:	4817      	ldr	r0, [pc, #92]	; (8005ca8 <chSchDoRescheduleAhead+0x68>)
 8005c4c:	f7ff fe68 	bl	8005920 <queue_fifo_remove.lto_priv.294>
 8005c50:	4602      	mov	r2, r0
 8005c52:	4b15      	ldr	r3, [pc, #84]	; (8005ca8 <chSchDoRescheduleAhead+0x68>)
 8005c54:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8005c56:	4b14      	ldr	r3, [pc, #80]	; (8005ca8 <chSchDoRescheduleAhead+0x68>)
 8005c58:	699b      	ldr	r3, [r3, #24]
 8005c5a:	2201      	movs	r2, #1
 8005c5c:	771a      	strb	r2, [r3, #28]

  otp->p_state = CH_STATE_READY;
 8005c5e:	9b00      	ldr	r3, [sp, #0]
 8005c60:	2200      	movs	r2, #0
 8005c62:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8005c64:	4b10      	ldr	r3, [pc, #64]	; (8005ca8 <chSchDoRescheduleAhead+0x68>)
 8005c66:	9301      	str	r3, [sp, #4]
  do {
    cp = cp->p_next;
 8005c68:	9b01      	ldr	r3, [sp, #4]
 8005c6a:	681b      	ldr	r3, [r3, #0]
 8005c6c:	9301      	str	r3, [sp, #4]
  } while (cp->p_prio > otp->p_prio);
 8005c6e:	9b01      	ldr	r3, [sp, #4]
 8005c70:	689a      	ldr	r2, [r3, #8]
 8005c72:	9b00      	ldr	r3, [sp, #0]
 8005c74:	689b      	ldr	r3, [r3, #8]
 8005c76:	429a      	cmp	r2, r3
 8005c78:	d8f6      	bhi.n	8005c68 <chSchDoRescheduleAhead+0x28>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8005c7a:	9b00      	ldr	r3, [sp, #0]
 8005c7c:	9a01      	ldr	r2, [sp, #4]
 8005c7e:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
 8005c80:	9b01      	ldr	r3, [sp, #4]
 8005c82:	685a      	ldr	r2, [r3, #4]
 8005c84:	9b00      	ldr	r3, [sp, #0]
 8005c86:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
 8005c88:	9b00      	ldr	r3, [sp, #0]
 8005c8a:	685b      	ldr	r3, [r3, #4]
 8005c8c:	9a00      	ldr	r2, [sp, #0]
 8005c8e:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
 8005c90:	9b01      	ldr	r3, [sp, #4]
 8005c92:	9a00      	ldr	r2, [sp, #0]
 8005c94:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
 8005c96:	4b04      	ldr	r3, [pc, #16]	; (8005ca8 <chSchDoRescheduleAhead+0x68>)
 8005c98:	699b      	ldr	r3, [r3, #24]
 8005c9a:	4618      	mov	r0, r3
 8005c9c:	9900      	ldr	r1, [sp, #0]
 8005c9e:	f7fa faf7 	bl	8000290 <_port_switch>
}
 8005ca2:	b003      	add	sp, #12
 8005ca4:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ca8:	20000808 	.word	0x20000808
 8005cac:	00000000 	.word	0x00000000

08005cb0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8005cb0:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8005cb2:	f7ff ffc5 	bl	8005c40 <chSchDoRescheduleAhead>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8005cb6:	bd08      	pop	{r3, pc}
	...

08005cc0 <port_lock.lto_priv.274>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8005cc0:	b082      	sub	sp, #8
 8005cc2:	2320      	movs	r3, #32
 8005cc4:	9301      	str	r3, [sp, #4]
 8005cc6:	9b01      	ldr	r3, [sp, #4]
 8005cc8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005ccc:	b002      	add	sp, #8
 8005cce:	4770      	bx	lr

08005cd0 <port_unlock.lto_priv.266>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005cd0:	b082      	sub	sp, #8
 8005cd2:	2300      	movs	r3, #0
 8005cd4:	9301      	str	r3, [sp, #4]
 8005cd6:	9b01      	ldr	r3, [sp, #4]
 8005cd8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005cdc:	b002      	add	sp, #8
 8005cde:	4770      	bx	lr

08005ce0 <st_lld_get_counter.lto_priv.316>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8005ce0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005ce4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8005ce6:	4618      	mov	r0, r3
 8005ce8:	4770      	bx	lr
 8005cea:	bf00      	nop
 8005cec:	0000      	movs	r0, r0
	...

08005cf0 <port_timer_get_time.lto_priv.313>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8005cf0:	b508      	push	{r3, lr}

  return stGetCounter();
 8005cf2:	f7ff fff5 	bl	8005ce0 <st_lld_get_counter.lto_priv.316>
 8005cf6:	4603      	mov	r3, r0
}
 8005cf8:	4618      	mov	r0, r3
 8005cfa:	bd08      	pop	{r3, pc}
 8005cfc:	0000      	movs	r0, r0
	...

08005d00 <list_init>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 8005d00:	b082      	sub	sp, #8
 8005d02:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
 8005d04:	9b01      	ldr	r3, [sp, #4]
 8005d06:	9a01      	ldr	r2, [sp, #4]
 8005d08:	601a      	str	r2, [r3, #0]
}
 8005d0a:	b002      	add	sp, #8
 8005d0c:	4770      	bx	lr
 8005d0e:	bf00      	nop

08005d10 <list_notempty>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 8005d10:	b082      	sub	sp, #8
 8005d12:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8005d14:	9b01      	ldr	r3, [sp, #4]
 8005d16:	681a      	ldr	r2, [r3, #0]
 8005d18:	9b01      	ldr	r3, [sp, #4]
 8005d1a:	429a      	cmp	r2, r3
 8005d1c:	bf14      	ite	ne
 8005d1e:	2301      	movne	r3, #1
 8005d20:	2300      	moveq	r3, #0
 8005d22:	b2db      	uxtb	r3, r3
}
 8005d24:	4618      	mov	r0, r3
 8005d26:	b002      	add	sp, #8
 8005d28:	4770      	bx	lr
 8005d2a:	bf00      	nop
 8005d2c:	0000      	movs	r0, r0
	...

08005d30 <queue_init.lto_priv.301>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8005d30:	b082      	sub	sp, #8
 8005d32:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8005d34:	9b01      	ldr	r3, [sp, #4]
 8005d36:	9a01      	ldr	r2, [sp, #4]
 8005d38:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8005d3a:	9b01      	ldr	r3, [sp, #4]
 8005d3c:	9a01      	ldr	r2, [sp, #4]
 8005d3e:	605a      	str	r2, [r3, #4]
}
 8005d40:	b002      	add	sp, #8
 8005d42:	4770      	bx	lr
	...

08005d50 <list_remove>:

  tp->p_next = tlp->p_next;
  tlp->p_next = tp;
}

static inline thread_t *list_remove(threads_list_t *tlp) {
 8005d50:	b084      	sub	sp, #16
 8005d52:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
 8005d54:	9b01      	ldr	r3, [sp, #4]
 8005d56:	681b      	ldr	r3, [r3, #0]
 8005d58:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
 8005d5a:	9b03      	ldr	r3, [sp, #12]
 8005d5c:	681a      	ldr	r2, [r3, #0]
 8005d5e:	9b01      	ldr	r3, [sp, #4]
 8005d60:	601a      	str	r2, [r3, #0]

  return tp;
 8005d62:	9b03      	ldr	r3, [sp, #12]
}
 8005d64:	4618      	mov	r0, r3
 8005d66:	b004      	add	sp, #16
 8005d68:	4770      	bx	lr
 8005d6a:	bf00      	nop
 8005d6c:	0000      	movs	r0, r0
	...

08005d70 <chSysLock.lto_priv.287>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8005d70:	b508      	push	{r3, lr}

  port_lock();
 8005d72:	f7ff ffa5 	bl	8005cc0 <port_lock.lto_priv.274>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8005d76:	bd08      	pop	{r3, pc}
	...

08005d80 <chSysUnlock.lto_priv.281>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8005d80:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8005d82:	f7ff ffa5 	bl	8005cd0 <port_unlock.lto_priv.266>
}
 8005d86:	bd08      	pop	{r3, pc}
	...

08005d90 <chVTGetSystemTimeX.lto_priv.310>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8005d90:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8005d92:	f7ff ffad 	bl	8005cf0 <port_timer_get_time.lto_priv.313>
 8005d96:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8005d98:	4618      	mov	r0, r3
 8005d9a:	bd08      	pop	{r3, pc}
 8005d9c:	0000      	movs	r0, r0
	...

08005da0 <chThdGetSelfX.lto_priv.262>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8005da0:	4b01      	ldr	r3, [pc, #4]	; (8005da8 <chThdGetSelfX.lto_priv.262+0x8>)
 8005da2:	699b      	ldr	r3, [r3, #24]
}
 8005da4:	4618      	mov	r0, r3
 8005da6:	4770      	bx	lr
 8005da8:	20000808 	.word	0x20000808
 8005dac:	00000000 	.word	0x00000000

08005db0 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
 8005db0:	b500      	push	{lr}
 8005db2:	b083      	sub	sp, #12
 8005db4:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8005db6:	2008      	movs	r0, #8
 8005db8:	9901      	ldr	r1, [sp, #4]
 8005dba:	f7ff feb9 	bl	8005b30 <chSchGoSleepTimeoutS>
}
 8005dbe:	b003      	add	sp, #12
 8005dc0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08005dd0 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8005dd0:	b500      	push	{lr}
 8005dd2:	b083      	sub	sp, #12
 8005dd4:	9001      	str	r0, [sp, #4]
 8005dd6:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
 8005dd8:	9b01      	ldr	r3, [sp, #4]
 8005dda:	9a00      	ldr	r2, [sp, #0]
 8005ddc:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
 8005dde:	9b01      	ldr	r3, [sp, #4]
 8005de0:	2202      	movs	r2, #2
 8005de2:	771a      	strb	r2, [r3, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8005de4:	9b01      	ldr	r3, [sp, #4]
 8005de6:	2200      	movs	r2, #0
 8005de8:	775a      	strb	r2, [r3, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8005dea:	9b01      	ldr	r3, [sp, #4]
 8005dec:	9a00      	ldr	r2, [sp, #0]
 8005dee:	63da      	str	r2, [r3, #60]	; 0x3c
  tp->p_mtxlist = NULL;
 8005df0:	9b01      	ldr	r3, [sp, #4]
 8005df2:	2200      	movs	r2, #0
 8005df4:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8005df6:	9b01      	ldr	r3, [sp, #4]
 8005df8:	2200      	movs	r2, #0
 8005dfa:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8005dfc:	9b01      	ldr	r3, [sp, #4]
 8005dfe:	2201      	movs	r2, #1
 8005e00:	779a      	strb	r2, [r3, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8005e02:	9b01      	ldr	r3, [sp, #4]
 8005e04:	2200      	movs	r2, #0
 8005e06:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 8005e08:	9b01      	ldr	r3, [sp, #4]
 8005e0a:	4a0e      	ldr	r2, [pc, #56]	; (8005e44 <_thread_init+0x74>)
 8005e0c:	611a      	str	r2, [r3, #16]
 8005e0e:	4b0d      	ldr	r3, [pc, #52]	; (8005e44 <_thread_init+0x74>)
 8005e10:	695a      	ldr	r2, [r3, #20]
 8005e12:	9b01      	ldr	r3, [sp, #4]
 8005e14:	615a      	str	r2, [r3, #20]
 8005e16:	9b01      	ldr	r3, [sp, #4]
 8005e18:	695b      	ldr	r3, [r3, #20]
 8005e1a:	9a01      	ldr	r2, [sp, #4]
 8005e1c:	611a      	str	r2, [r3, #16]
 8005e1e:	4a09      	ldr	r2, [pc, #36]	; (8005e44 <_thread_init+0x74>)
 8005e20:	9b01      	ldr	r3, [sp, #4]
 8005e22:	6153      	str	r3, [r2, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8005e24:	9b01      	ldr	r3, [sp, #4]
 8005e26:	3324      	adds	r3, #36	; 0x24
 8005e28:	4618      	mov	r0, r3
 8005e2a:	f7ff ff69 	bl	8005d00 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8005e2e:	9b01      	ldr	r3, [sp, #4]
 8005e30:	3328      	adds	r3, #40	; 0x28
 8005e32:	4618      	mov	r0, r3
 8005e34:	f7ff ff7c 	bl	8005d30 <queue_init.lto_priv.301>
  chTMObjectInit(&tp->p_stats);
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
 8005e38:	9b01      	ldr	r3, [sp, #4]
}
 8005e3a:	4618      	mov	r0, r3
 8005e3c:	b003      	add	sp, #12
 8005e3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005e42:	bf00      	nop
 8005e44:	20000808 	.word	0x20000808
	...

08005e50 <_thread_memfill>:
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
 8005e50:	b084      	sub	sp, #16
 8005e52:	9003      	str	r0, [sp, #12]
 8005e54:	9102      	str	r1, [sp, #8]
 8005e56:	4613      	mov	r3, r2
 8005e58:	f88d 3007 	strb.w	r3, [sp, #7]
 8005e5c:	e005      	b.n	8005e6a <_thread_memfill+0x1a>

  while (startp < endp) {
    *startp++ = v;
 8005e5e:	9b03      	ldr	r3, [sp, #12]
 8005e60:	1c5a      	adds	r2, r3, #1
 8005e62:	9203      	str	r2, [sp, #12]
 8005e64:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8005e68:	701a      	strb	r2, [r3, #0]
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8005e6a:	9a03      	ldr	r2, [sp, #12]
 8005e6c:	9b02      	ldr	r3, [sp, #8]
 8005e6e:	429a      	cmp	r2, r3
 8005e70:	d3f5      	bcc.n	8005e5e <_thread_memfill+0xe>
    *startp++ = v;
  }
}
 8005e72:	b004      	add	sp, #16
 8005e74:	4770      	bx	lr
 8005e76:	bf00      	nop
	...

08005e80 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8005e80:	b500      	push	{lr}
 8005e82:	b087      	sub	sp, #28
 8005e84:	9003      	str	r0, [sp, #12]
 8005e86:	9102      	str	r1, [sp, #8]
 8005e88:	9201      	str	r2, [sp, #4]
 8005e8a:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
 8005e8c:	9b03      	ldr	r3, [sp, #12]
 8005e8e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8005e90:	9b02      	ldr	r3, [sp, #8]
 8005e92:	3b24      	subs	r3, #36	; 0x24
 8005e94:	9a03      	ldr	r2, [sp, #12]
 8005e96:	441a      	add	r2, r3
 8005e98:	9b05      	ldr	r3, [sp, #20]
 8005e9a:	60da      	str	r2, [r3, #12]
 8005e9c:	9b05      	ldr	r3, [sp, #20]
 8005e9e:	68db      	ldr	r3, [r3, #12]
 8005ea0:	9a00      	ldr	r2, [sp, #0]
 8005ea2:	601a      	str	r2, [r3, #0]
 8005ea4:	9b05      	ldr	r3, [sp, #20]
 8005ea6:	68db      	ldr	r3, [r3, #12]
 8005ea8:	9a08      	ldr	r2, [sp, #32]
 8005eaa:	605a      	str	r2, [r3, #4]
 8005eac:	9b05      	ldr	r3, [sp, #20]
 8005eae:	68db      	ldr	r3, [r3, #12]
 8005eb0:	4a05      	ldr	r2, [pc, #20]	; (8005ec8 <chThdCreateI+0x48>)
 8005eb2:	621a      	str	r2, [r3, #32]

  return _thread_init(tp, prio);
 8005eb4:	9805      	ldr	r0, [sp, #20]
 8005eb6:	9901      	ldr	r1, [sp, #4]
 8005eb8:	f7ff ff8a 	bl	8005dd0 <_thread_init>
 8005ebc:	4603      	mov	r3, r0
}
 8005ebe:	4618      	mov	r0, r3
 8005ec0:	b007      	add	sp, #28
 8005ec2:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ec6:	bf00      	nop
 8005ec8:	080002a1 	.word	0x080002a1
 8005ecc:	00000000 	.word	0x00000000

08005ed0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8005ed0:	b500      	push	{lr}
 8005ed2:	b089      	sub	sp, #36	; 0x24
 8005ed4:	9005      	str	r0, [sp, #20]
 8005ed6:	9104      	str	r1, [sp, #16]
 8005ed8:	9203      	str	r2, [sp, #12]
 8005eda:	9302      	str	r3, [sp, #8]
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 8005edc:	9b05      	ldr	r3, [sp, #20]
 8005ede:	3344      	adds	r3, #68	; 0x44
 8005ee0:	9805      	ldr	r0, [sp, #20]
 8005ee2:	4619      	mov	r1, r3
 8005ee4:	22ff      	movs	r2, #255	; 0xff
 8005ee6:	f7ff ffb3 	bl	8005e50 <_thread_memfill>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 8005eea:	9b05      	ldr	r3, [sp, #20]
 8005eec:	f103 0144 	add.w	r1, r3, #68	; 0x44
 8005ef0:	9a05      	ldr	r2, [sp, #20]
 8005ef2:	9b04      	ldr	r3, [sp, #16]
 8005ef4:	4413      	add	r3, r2
 8005ef6:	4608      	mov	r0, r1
 8005ef8:	4619      	mov	r1, r3
 8005efa:	2255      	movs	r2, #85	; 0x55
 8005efc:	f7ff ffa8 	bl	8005e50 <_thread_memfill>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 8005f00:	f7ff ff36 	bl	8005d70 <chSysLock.lto_priv.287>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8005f04:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8005f06:	9300      	str	r3, [sp, #0]
 8005f08:	9805      	ldr	r0, [sp, #20]
 8005f0a:	9904      	ldr	r1, [sp, #16]
 8005f0c:	9a03      	ldr	r2, [sp, #12]
 8005f0e:	9b02      	ldr	r3, [sp, #8]
 8005f10:	f7ff ffb6 	bl	8005e80 <chThdCreateI>
 8005f14:	9007      	str	r0, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
 8005f16:	9807      	ldr	r0, [sp, #28]
 8005f18:	2100      	movs	r1, #0
 8005f1a:	f7ff fe41 	bl	8005ba0 <chSchWakeupS>
  chSysUnlock();
 8005f1e:	f7ff ff2f 	bl	8005d80 <chSysUnlock.lto_priv.281>

  return tp;
 8005f22:	9b07      	ldr	r3, [sp, #28]
}
 8005f24:	4618      	mov	r0, r3
 8005f26:	b009      	add	sp, #36	; 0x24
 8005f28:	f85d fb04 	ldr.w	pc, [sp], #4
 8005f2c:	0000      	movs	r0, r0
	...

08005f30 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8005f30:	b500      	push	{lr}
 8005f32:	b083      	sub	sp, #12
 8005f34:	9001      	str	r0, [sp, #4]

  chSysLock();
 8005f36:	f7ff ff1b 	bl	8005d70 <chSysLock.lto_priv.287>
  chThdSleepS(time);
 8005f3a:	9801      	ldr	r0, [sp, #4]
 8005f3c:	f7ff ff38 	bl	8005db0 <chThdSleepS>
  chSysUnlock();
 8005f40:	f7ff ff1e 	bl	8005d80 <chSysUnlock.lto_priv.281>
}
 8005f44:	b003      	add	sp, #12
 8005f46:	f85d fb04 	ldr.w	pc, [sp], #4
 8005f4a:	bf00      	nop
 8005f4c:	0000      	movs	r0, r0
	...

08005f50 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
 8005f50:	b500      	push	{lr}
 8005f52:	b083      	sub	sp, #12
 8005f54:	9001      	str	r0, [sp, #4]

  chSysLock();
 8005f56:	f7ff ff0b 	bl	8005d70 <chSysLock.lto_priv.287>
  time -= chVTGetSystemTimeX();
 8005f5a:	f7ff ff19 	bl	8005d90 <chVTGetSystemTimeX.lto_priv.310>
 8005f5e:	4602      	mov	r2, r0
 8005f60:	9b01      	ldr	r3, [sp, #4]
 8005f62:	1a9b      	subs	r3, r3, r2
 8005f64:	9301      	str	r3, [sp, #4]
  if (time > (systime_t)0) {
 8005f66:	9b01      	ldr	r3, [sp, #4]
 8005f68:	2b00      	cmp	r3, #0
 8005f6a:	d002      	beq.n	8005f72 <chThdSleepUntil+0x22>
    chThdSleepS(time);
 8005f6c:	9801      	ldr	r0, [sp, #4]
 8005f6e:	f7ff ff1f 	bl	8005db0 <chThdSleepS>
  }
  chSysUnlock();
 8005f72:	f7ff ff05 	bl	8005d80 <chSysUnlock.lto_priv.281>
}
 8005f76:	b003      	add	sp, #12
 8005f78:	f85d fb04 	ldr.w	pc, [sp], #4
 8005f7c:	0000      	movs	r0, r0
	...

08005f80 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8005f80:	b500      	push	{lr}
 8005f82:	b083      	sub	sp, #12
 8005f84:	9001      	str	r0, [sp, #4]

  chSysLock();
 8005f86:	f7ff fef3 	bl	8005d70 <chSysLock.lto_priv.287>
  chThdExitS(msg);
 8005f8a:	9801      	ldr	r0, [sp, #4]
 8005f8c:	f000 f808 	bl	8005fa0 <chThdExitS>
  /* The thread never returns here.*/
}
 8005f90:	b003      	add	sp, #12
 8005f92:	f85d fb04 	ldr.w	pc, [sp], #4
 8005f96:	bf00      	nop
	...

08005fa0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8005fa0:	b500      	push	{lr}
 8005fa2:	b085      	sub	sp, #20
 8005fa4:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 8005fa6:	4b17      	ldr	r3, [pc, #92]	; (8006004 <chThdExitS+0x64>)
 8005fa8:	699b      	ldr	r3, [r3, #24]
 8005faa:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
 8005fac:	9b03      	ldr	r3, [sp, #12]
 8005fae:	9a01      	ldr	r2, [sp, #4]
 8005fb0:	621a      	str	r2, [r3, #32]
 8005fb2:	e008      	b.n	8005fc6 <chThdExitS+0x26>
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 8005fb4:	9b03      	ldr	r3, [sp, #12]
 8005fb6:	3324      	adds	r3, #36	; 0x24
 8005fb8:	4618      	mov	r0, r3
 8005fba:	f7ff fec9 	bl	8005d50 <list_remove>
 8005fbe:	4603      	mov	r3, r0
 8005fc0:	4618      	mov	r0, r3
 8005fc2:	f7ff fd25 	bl	8005a10 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8005fc6:	9b03      	ldr	r3, [sp, #12]
 8005fc8:	3324      	adds	r3, #36	; 0x24
 8005fca:	4618      	mov	r0, r3
 8005fcc:	f7ff fea0 	bl	8005d10 <list_notempty>
 8005fd0:	4603      	mov	r3, r0
 8005fd2:	2b00      	cmp	r3, #0
 8005fd4:	d1ee      	bne.n	8005fb4 <chThdExitS+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8005fd6:	9b03      	ldr	r3, [sp, #12]
 8005fd8:	7f5b      	ldrb	r3, [r3, #29]
 8005fda:	f003 0303 	and.w	r3, r3, #3
 8005fde:	2b00      	cmp	r3, #0
 8005fe0:	d109      	bne.n	8005ff6 <chThdExitS+0x56>
    REG_REMOVE(tp);
 8005fe2:	9b03      	ldr	r3, [sp, #12]
 8005fe4:	695b      	ldr	r3, [r3, #20]
 8005fe6:	9a03      	ldr	r2, [sp, #12]
 8005fe8:	6912      	ldr	r2, [r2, #16]
 8005fea:	611a      	str	r2, [r3, #16]
 8005fec:	9b03      	ldr	r3, [sp, #12]
 8005fee:	691b      	ldr	r3, [r3, #16]
 8005ff0:	9a03      	ldr	r2, [sp, #12]
 8005ff2:	6952      	ldr	r2, [r2, #20]
 8005ff4:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8005ff6:	200f      	movs	r0, #15
 8005ff8:	f7ff fd32 	bl	8005a60 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 8005ffc:	b005      	add	sp, #20
 8005ffe:	f85d fb04 	ldr.w	pc, [sp], #4
 8006002:	bf00      	nop
 8006004:	20000808 	.word	0x20000808
	...

08006010 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 8006010:	b500      	push	{lr}
 8006012:	b085      	sub	sp, #20
 8006014:	9001      	str	r0, [sp, #4]
  thread_t *tp = chThdGetSelfX();
 8006016:	f7ff fec3 	bl	8005da0 <chThdGetSelfX.lto_priv.262>
 800601a:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
 800601c:	9b01      	ldr	r3, [sp, #4]
 800601e:	9a03      	ldr	r2, [sp, #12]
 8006020:	601a      	str	r2, [r3, #0]
  tp->p_u.wttrp = trp;
 8006022:	9b03      	ldr	r3, [sp, #12]
 8006024:	9a01      	ldr	r2, [sp, #4]
 8006026:	621a      	str	r2, [r3, #32]
  chSchGoSleepS(CH_STATE_SUSPENDED);
 8006028:	2003      	movs	r0, #3
 800602a:	f7ff fd19 	bl	8005a60 <chSchGoSleepS>

  return chThdGetSelfX()->p_u.rdymsg;
 800602e:	f7ff feb7 	bl	8005da0 <chThdGetSelfX.lto_priv.262>
 8006032:	4603      	mov	r3, r0
 8006034:	6a1b      	ldr	r3, [r3, #32]
}
 8006036:	4618      	mov	r0, r3
 8006038:	b005      	add	sp, #20
 800603a:	f85d fb04 	ldr.w	pc, [sp], #4
 800603e:	bf00      	nop

08006040 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8006040:	b500      	push	{lr}
 8006042:	b085      	sub	sp, #20
 8006044:	9001      	str	r0, [sp, #4]
 8006046:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8006048:	9b01      	ldr	r3, [sp, #4]
 800604a:	681b      	ldr	r3, [r3, #0]
 800604c:	2b00      	cmp	r3, #0
 800604e:	d00b      	beq.n	8006068 <chThdResumeI+0x28>
    thread_t *tp = *trp;
 8006050:	9b01      	ldr	r3, [sp, #4]
 8006052:	681b      	ldr	r3, [r3, #0]
 8006054:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8006056:	9b01      	ldr	r3, [sp, #4]
 8006058:	2200      	movs	r2, #0
 800605a:	601a      	str	r2, [r3, #0]
    tp->p_u.rdymsg = msg;
 800605c:	9b03      	ldr	r3, [sp, #12]
 800605e:	9a00      	ldr	r2, [sp, #0]
 8006060:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 8006062:	9803      	ldr	r0, [sp, #12]
 8006064:	f7ff fcd4 	bl	8005a10 <chSchReadyI>
  }
}
 8006068:	b005      	add	sp, #20
 800606a:	f85d fb04 	ldr.w	pc, [sp], #4
 800606e:	bf00      	nop

08006070 <port_rt_get_counter_value.lto_priv.307>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8006070:	4b01      	ldr	r3, [pc, #4]	; (8006078 <port_rt_get_counter_value.lto_priv.307+0x8>)
 8006072:	685b      	ldr	r3, [r3, #4]
}
 8006074:	4618      	mov	r0, r3
 8006076:	4770      	bx	lr
 8006078:	e0001000 	.word	0xe0001000
 800607c:	00000000 	.word	0x00000000

08006080 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 8006080:	b084      	sub	sp, #16
 8006082:	9003      	str	r0, [sp, #12]
 8006084:	9102      	str	r1, [sp, #8]
 8006086:	9201      	str	r2, [sp, #4]

  tmp->n++;
 8006088:	9b03      	ldr	r3, [sp, #12]
 800608a:	68db      	ldr	r3, [r3, #12]
 800608c:	1c5a      	adds	r2, r3, #1
 800608e:	9b03      	ldr	r3, [sp, #12]
 8006090:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8006092:	9b03      	ldr	r3, [sp, #12]
 8006094:	689b      	ldr	r3, [r3, #8]
 8006096:	9a02      	ldr	r2, [sp, #8]
 8006098:	1ad2      	subs	r2, r2, r3
 800609a:	9b01      	ldr	r3, [sp, #4]
 800609c:	1ad2      	subs	r2, r2, r3
 800609e:	9b03      	ldr	r3, [sp, #12]
 80060a0:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 80060a2:	9b03      	ldr	r3, [sp, #12]
 80060a4:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 80060a8:	9b03      	ldr	r3, [sp, #12]
 80060aa:	689b      	ldr	r3, [r3, #8]
 80060ac:	461a      	mov	r2, r3
 80060ae:	f04f 0300 	mov.w	r3, #0
 80060b2:	1812      	adds	r2, r2, r0
 80060b4:	eb43 0301 	adc.w	r3, r3, r1
 80060b8:	9903      	ldr	r1, [sp, #12]
 80060ba:	e9c1 2304 	strd	r2, r3, [r1, #16]
  if (tmp->last > tmp->worst) {
 80060be:	9b03      	ldr	r3, [sp, #12]
 80060c0:	689a      	ldr	r2, [r3, #8]
 80060c2:	9b03      	ldr	r3, [sp, #12]
 80060c4:	685b      	ldr	r3, [r3, #4]
 80060c6:	429a      	cmp	r2, r3
 80060c8:	d903      	bls.n	80060d2 <tm_stop+0x52>
    tmp->worst = tmp->last;
 80060ca:	9b03      	ldr	r3, [sp, #12]
 80060cc:	689a      	ldr	r2, [r3, #8]
 80060ce:	9b03      	ldr	r3, [sp, #12]
 80060d0:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 80060d2:	9b03      	ldr	r3, [sp, #12]
 80060d4:	689a      	ldr	r2, [r3, #8]
 80060d6:	9b03      	ldr	r3, [sp, #12]
 80060d8:	681b      	ldr	r3, [r3, #0]
 80060da:	429a      	cmp	r2, r3
 80060dc:	d203      	bcs.n	80060e6 <tm_stop+0x66>
    tmp->best = tmp->last;
 80060de:	9b03      	ldr	r3, [sp, #12]
 80060e0:	689a      	ldr	r2, [r3, #8]
 80060e2:	9b03      	ldr	r3, [sp, #12]
 80060e4:	601a      	str	r2, [r3, #0]
  }
}
 80060e6:	b004      	add	sp, #16
 80060e8:	4770      	bx	lr
 80060ea:	bf00      	nop
 80060ec:	0000      	movs	r0, r0
	...

080060f0 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 80060f0:	b500      	push	{lr}
 80060f2:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 80060f4:	4b0a      	ldr	r3, [pc, #40]	; (8006120 <_tm_init+0x30>)
 80060f6:	2200      	movs	r2, #0
 80060f8:	675a      	str	r2, [r3, #116]	; 0x74
  chTMObjectInit(&tm);
 80060fa:	466b      	mov	r3, sp
 80060fc:	4618      	mov	r0, r3
 80060fe:	f000 f817 	bl	8006130 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 8006102:	466b      	mov	r3, sp
 8006104:	4618      	mov	r0, r3
 8006106:	f000 f82b 	bl	8006160 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 800610a:	466b      	mov	r3, sp
 800610c:	4618      	mov	r0, r3
 800610e:	f000 f837 	bl	8006180 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8006112:	9b02      	ldr	r3, [sp, #8]
 8006114:	4a02      	ldr	r2, [pc, #8]	; (8006120 <_tm_init+0x30>)
 8006116:	6753      	str	r3, [r2, #116]	; 0x74
}
 8006118:	b007      	add	sp, #28
 800611a:	f85d fb04 	ldr.w	pc, [sp], #4
 800611e:	bf00      	nop
 8006120:	20000808 	.word	0x20000808
	...

08006130 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 8006130:	b082      	sub	sp, #8
 8006132:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 8006134:	9b01      	ldr	r3, [sp, #4]
 8006136:	f04f 32ff 	mov.w	r2, #4294967295
 800613a:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 800613c:	9b01      	ldr	r3, [sp, #4]
 800613e:	2200      	movs	r2, #0
 8006140:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 8006142:	9b01      	ldr	r3, [sp, #4]
 8006144:	2200      	movs	r2, #0
 8006146:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 8006148:	9b01      	ldr	r3, [sp, #4]
 800614a:	2200      	movs	r2, #0
 800614c:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 800614e:	9901      	ldr	r1, [sp, #4]
 8006150:	f04f 0200 	mov.w	r2, #0
 8006154:	f04f 0300 	mov.w	r3, #0
 8006158:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 800615c:	b002      	add	sp, #8
 800615e:	4770      	bx	lr

08006160 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 8006160:	b500      	push	{lr}
 8006162:	b083      	sub	sp, #12
 8006164:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
 8006166:	f7ff ff83 	bl	8006070 <port_rt_get_counter_value.lto_priv.307>
 800616a:	4602      	mov	r2, r0
 800616c:	9b01      	ldr	r3, [sp, #4]
 800616e:	609a      	str	r2, [r3, #8]
}
 8006170:	b003      	add	sp, #12
 8006172:	f85d fb04 	ldr.w	pc, [sp], #4
 8006176:	bf00      	nop
	...

08006180 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8006180:	b500      	push	{lr}
 8006182:	b083      	sub	sp, #12
 8006184:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8006186:	f7ff ff73 	bl	8006070 <port_rt_get_counter_value.lto_priv.307>
 800618a:	4602      	mov	r2, r0
 800618c:	4b04      	ldr	r3, [pc, #16]	; (80061a0 <chTMStopMeasurementX+0x20>)
 800618e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8006190:	9801      	ldr	r0, [sp, #4]
 8006192:	4611      	mov	r1, r2
 8006194:	461a      	mov	r2, r3
 8006196:	f7ff ff73 	bl	8006080 <tm_stop>
}
 800619a:	b003      	add	sp, #12
 800619c:	f85d fb04 	ldr.w	pc, [sp], #4
 80061a0:	20000808 	.word	0x20000808
	...

080061b0 <queue_init.lto_priv.303>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80061b0:	b082      	sub	sp, #8
 80061b2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 80061b4:	9b01      	ldr	r3, [sp, #4]
 80061b6:	9a01      	ldr	r2, [sp, #4]
 80061b8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80061ba:	9b01      	ldr	r3, [sp, #4]
 80061bc:	9a01      	ldr	r2, [sp, #4]
 80061be:	605a      	str	r2, [r3, #4]
}
 80061c0:	b002      	add	sp, #8
 80061c2:	4770      	bx	lr
	...

080061d0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 80061d0:	b500      	push	{lr}
 80061d2:	b083      	sub	sp, #12
 80061d4:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
 80061d6:	9b01      	ldr	r3, [sp, #4]
 80061d8:	4618      	mov	r0, r3
 80061da:	f7ff ffe9 	bl	80061b0 <queue_init.lto_priv.303>
  mp->m_owner = NULL;
 80061de:	9b01      	ldr	r3, [sp, #4]
 80061e0:	2200      	movs	r2, #0
 80061e2:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 80061e4:	b003      	add	sp, #12
 80061e6:	f85d fb04 	ldr.w	pc, [sp], #4
 80061ea:	bf00      	nop
 80061ec:	0000      	movs	r0, r0
	...

080061f0 <memset>:
 80061f0:	b470      	push	{r4, r5, r6}
 80061f2:	0784      	lsls	r4, r0, #30
 80061f4:	d046      	beq.n	8006284 <memset+0x94>
 80061f6:	1e54      	subs	r4, r2, #1
 80061f8:	2a00      	cmp	r2, #0
 80061fa:	d041      	beq.n	8006280 <memset+0x90>
 80061fc:	b2cd      	uxtb	r5, r1
 80061fe:	4603      	mov	r3, r0
 8006200:	e002      	b.n	8006208 <memset+0x18>
 8006202:	1e62      	subs	r2, r4, #1
 8006204:	b3e4      	cbz	r4, 8006280 <memset+0x90>
 8006206:	4614      	mov	r4, r2
 8006208:	f803 5b01 	strb.w	r5, [r3], #1
 800620c:	079a      	lsls	r2, r3, #30
 800620e:	d1f8      	bne.n	8006202 <memset+0x12>
 8006210:	2c03      	cmp	r4, #3
 8006212:	d92e      	bls.n	8006272 <memset+0x82>
 8006214:	b2cd      	uxtb	r5, r1
 8006216:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800621a:	2c0f      	cmp	r4, #15
 800621c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8006220:	d919      	bls.n	8006256 <memset+0x66>
 8006222:	f103 0210 	add.w	r2, r3, #16
 8006226:	4626      	mov	r6, r4
 8006228:	3e10      	subs	r6, #16
 800622a:	2e0f      	cmp	r6, #15
 800622c:	f842 5c10 	str.w	r5, [r2, #-16]
 8006230:	f842 5c0c 	str.w	r5, [r2, #-12]
 8006234:	f842 5c08 	str.w	r5, [r2, #-8]
 8006238:	f842 5c04 	str.w	r5, [r2, #-4]
 800623c:	f102 0210 	add.w	r2, r2, #16
 8006240:	d8f2      	bhi.n	8006228 <memset+0x38>
 8006242:	f1a4 0210 	sub.w	r2, r4, #16
 8006246:	f022 020f 	bic.w	r2, r2, #15
 800624a:	f004 040f 	and.w	r4, r4, #15
 800624e:	3210      	adds	r2, #16
 8006250:	2c03      	cmp	r4, #3
 8006252:	4413      	add	r3, r2
 8006254:	d90d      	bls.n	8006272 <memset+0x82>
 8006256:	461e      	mov	r6, r3
 8006258:	4622      	mov	r2, r4
 800625a:	3a04      	subs	r2, #4
 800625c:	2a03      	cmp	r2, #3
 800625e:	f846 5b04 	str.w	r5, [r6], #4
 8006262:	d8fa      	bhi.n	800625a <memset+0x6a>
 8006264:	1f22      	subs	r2, r4, #4
 8006266:	f022 0203 	bic.w	r2, r2, #3
 800626a:	3204      	adds	r2, #4
 800626c:	4413      	add	r3, r2
 800626e:	f004 0403 	and.w	r4, r4, #3
 8006272:	b12c      	cbz	r4, 8006280 <memset+0x90>
 8006274:	b2c9      	uxtb	r1, r1
 8006276:	441c      	add	r4, r3
 8006278:	f803 1b01 	strb.w	r1, [r3], #1
 800627c:	42a3      	cmp	r3, r4
 800627e:	d1fb      	bne.n	8006278 <memset+0x88>
 8006280:	bc70      	pop	{r4, r5, r6}
 8006282:	4770      	bx	lr
 8006284:	4614      	mov	r4, r2
 8006286:	4603      	mov	r3, r0
 8006288:	e7c2      	b.n	8006210 <memset+0x20>
 800628a:	bf00      	nop
 800628c:	0000      	movs	r0, r0
 800628e:	0000      	movs	r0, r0
 8006290:	6c756e28 	.word	0x6c756e28
 8006294:	0000296c 	.word	0x0000296c
 8006298:	74697277 	.word	0x74697277
 800629c:	00007265 	.word	0x00007265
 80062a0:	65636361 	.word	0x65636361
 80062a4:	6165526c 	.word	0x6165526c
 80062a8:	00726564 	.word	0x00726564
 80062ac:	00000000 	.word	0x00000000
 80062b0:	5f627375 	.word	0x5f627375
 80062b4:	5f646c6c 	.word	0x5f646c6c
 80062b8:	706d7570 	.word	0x706d7570
 80062bc:	00000000 	.word	0x00000000
 80062c0:	20414d44 	.word	0x20414d44
 80062c4:	6c696166 	.word	0x6c696166
 80062c8:	00657275 	.word	0x00657275
 80062cc:	00000a0d 	.word	0x00000a0d
 80062d0:	00000000 	.word	0x00000000
 80062d4:	202a2a2a 	.word	0x202a2a2a
 80062d8:	62696843 	.word	0x62696843
 80062dc:	2f534f69 	.word	0x2f534f69
 80062e0:	74205452 	.word	0x74205452
 80062e4:	20747365 	.word	0x20747365
 80062e8:	74697573 	.word	0x74697573
 80062ec:	00000065 	.word	0x00000065
 80062f0:	002a2a2a 	.word	0x002a2a2a
 80062f4:	202a2a2a 	.word	0x202a2a2a
 80062f8:	6e72654b 	.word	0x6e72654b
 80062fc:	203a6c65 	.word	0x203a6c65
 8006300:	20202020 	.word	0x20202020
 8006304:	00002020 	.word	0x00002020
 8006308:	2e312e33 	.word	0x2e312e33
 800630c:	00000033 	.word	0x00000033
 8006310:	202a2a2a 	.word	0x202a2a2a
 8006314:	706d6f43 	.word	0x706d6f43
 8006318:	64656c69 	.word	0x64656c69
 800631c:	2020203a 	.word	0x2020203a
 8006320:	00002020 	.word	0x00002020
 8006324:	206c754a 	.word	0x206c754a
 8006328:	32203520 	.word	0x32203520
 800632c:	20363130 	.word	0x20363130
 8006330:	3132202d 	.word	0x3132202d
 8006334:	3a38323a 	.word	0x3a38323a
 8006338:	00003835 	.word	0x00003835
 800633c:	202a2a2a 	.word	0x202a2a2a
 8006340:	706d6f43 	.word	0x706d6f43
 8006344:	72656c69 	.word	0x72656c69
 8006348:	2020203a 	.word	0x2020203a
 800634c:	00002020 	.word	0x00002020
 8006350:	20434347 	.word	0x20434347
 8006354:	2e392e34 	.word	0x2e392e34
 8006358:	30322033 	.word	0x30322033
 800635c:	35303531 	.word	0x35303531
 8006360:	28203932 	.word	0x28203932
 8006364:	656c6572 	.word	0x656c6572
 8006368:	29657361 	.word	0x29657361
 800636c:	52415b20 	.word	0x52415b20
 8006370:	6d652f4d 	.word	0x6d652f4d
 8006374:	64646562 	.word	0x64646562
 8006378:	342d6465 	.word	0x342d6465
 800637c:	622d395f 	.word	0x622d395f
 8006380:	636e6172 	.word	0x636e6172
 8006384:	65722068 	.word	0x65722068
 8006388:	69736976 	.word	0x69736976
 800638c:	32206e6f 	.word	0x32206e6f
 8006390:	37393732 	.word	0x37393732
 8006394:	00005d37 	.word	0x00005d37
 8006398:	202a2a2a 	.word	0x202a2a2a
 800639c:	68637241 	.word	0x68637241
 80063a0:	63657469 	.word	0x63657469
 80063a4:	65727574 	.word	0x65727574
 80063a8:	0000203a 	.word	0x0000203a
 80063ac:	764d5241 	.word	0x764d5241
 80063b0:	4d2d4537 	.word	0x4d2d4537
 80063b4:	00000000 	.word	0x00000000
 80063b8:	202a2a2a 	.word	0x202a2a2a
 80063bc:	65726f43 	.word	0x65726f43
 80063c0:	72615620 	.word	0x72615620
 80063c4:	746e6169 	.word	0x746e6169
 80063c8:	0000203a 	.word	0x0000203a
 80063cc:	74726f43 	.word	0x74726f43
 80063d0:	4d2d7865 	.word	0x4d2d7865
 80063d4:	00000034 	.word	0x00000034
 80063d8:	202a2a2a 	.word	0x202a2a2a
 80063dc:	74726f50 	.word	0x74726f50
 80063e0:	666e4920 	.word	0x666e4920
 80063e4:	20203a6f 	.word	0x20203a6f
 80063e8:	00002020 	.word	0x00002020
 80063ec:	61766441 	.word	0x61766441
 80063f0:	6465636e 	.word	0x6465636e
 80063f4:	72656b20 	.word	0x72656b20
 80063f8:	206c656e 	.word	0x206c656e
 80063fc:	65646f6d 	.word	0x65646f6d
 8006400:	00000000 	.word	0x00000000
 8006404:	202a2a2a 	.word	0x202a2a2a
 8006408:	74616c50 	.word	0x74616c50
 800640c:	6d726f66 	.word	0x6d726f66
 8006410:	2020203a 	.word	0x2020203a
 8006414:	00002020 	.word	0x00002020
 8006418:	334d5453 	.word	0x334d5453
 800641c:	30344632 	.word	0x30344632
 8006420:	69482037 	.word	0x69482037
 8006424:	50206867 	.word	0x50206867
 8006428:	6f667265 	.word	0x6f667265
 800642c:	6e616d72 	.word	0x6e616d72
 8006430:	77206563 	.word	0x77206563
 8006434:	20687469 	.word	0x20687469
 8006438:	20505344 	.word	0x20505344
 800643c:	20646e61 	.word	0x20646e61
 8006440:	00555046 	.word	0x00555046
 8006444:	202a2a2a 	.word	0x202a2a2a
 8006448:	74736554 	.word	0x74736554
 800644c:	616f4220 	.word	0x616f4220
 8006450:	203a6472 	.word	0x203a6472
 8006454:	00002020 	.word	0x00002020
 8006458:	694d5453 	.word	0x694d5453
 800645c:	656f7263 	.word	0x656f7263
 8006460:	7463656c 	.word	0x7463656c
 8006464:	696e6f72 	.word	0x696e6f72
 8006468:	53207363 	.word	0x53207363
 800646c:	32334d54 	.word	0x32334d54
 8006470:	442d3446 	.word	0x442d3446
 8006474:	6f637369 	.word	0x6f637369
 8006478:	79726576 	.word	0x79726576
 800647c:	00000000 	.word	0x00000000
 8006480:	202d2d2d 	.word	0x202d2d2d
 8006484:	74736554 	.word	0x74736554
 8006488:	73614320 	.word	0x73614320
 800648c:	00002065 	.word	0x00002065
 8006490:	0000002e 	.word	0x0000002e
 8006494:	00002820 	.word	0x00002820
 8006498:	00000029 	.word	0x00000029
 800649c:	202d2d2d 	.word	0x202d2d2d
 80064a0:	75736552 	.word	0x75736552
 80064a4:	203a746c 	.word	0x203a746c
 80064a8:	4c494146 	.word	0x4c494146
 80064ac:	20455255 	.word	0x20455255
 80064b0:	00002328 	.word	0x00002328
 80064b4:	00005b20 	.word	0x00005b20
 80064b8:	0000295d 	.word	0x0000295d
 80064bc:	202d2d2d 	.word	0x202d2d2d
 80064c0:	75736552 	.word	0x75736552
 80064c4:	203a746c 	.word	0x203a746c
 80064c8:	43435553 	.word	0x43435553
 80064cc:	00535345 	.word	0x00535345
 80064d0:	616e6946 	.word	0x616e6946
 80064d4:	6572206c 	.word	0x6572206c
 80064d8:	746c7573 	.word	0x746c7573
 80064dc:	0000203a 	.word	0x0000203a
 80064e0:	4c494146 	.word	0x4c494146
 80064e4:	00455255 	.word	0x00455255
 80064e8:	43435553 	.word	0x43435553
 80064ec:	00535345 	.word	0x00535345
 80064f0:	656c6469 	.word	0x656c6469
 80064f4:	00000000 	.word	0x00000000
 80064f8:	65726854 	.word	0x65726854
 80064fc:	2c736461 	.word	0x2c736461
 8006500:	716e6520 	.word	0x716e6520
 8006504:	69756575 	.word	0x69756575
 8006508:	7420676e 	.word	0x7420676e
 800650c:	20747365 	.word	0x20747365
 8006510:	00003123 	.word	0x00003123
 8006514:	65726854 	.word	0x65726854
 8006518:	2c736461 	.word	0x2c736461
 800651c:	716e6520 	.word	0x716e6520
 8006520:	69756575 	.word	0x69756575
 8006524:	7420676e 	.word	0x7420676e
 8006528:	20747365 	.word	0x20747365
 800652c:	00003223 	.word	0x00003223
 8006530:	65726854 	.word	0x65726854
 8006534:	2c736461 	.word	0x2c736461
 8006538:	69727020 	.word	0x69727020
 800653c:	7469726f 	.word	0x7469726f
 8006540:	68632079 	.word	0x68632079
 8006544:	65676e61 	.word	0x65676e61
 8006548:	00000000 	.word	0x00000000
 800654c:	65726854 	.word	0x65726854
 8006550:	2c736461 	.word	0x2c736461
 8006554:	6c656420 	.word	0x6c656420
 8006558:	00737961 	.word	0x00737961
 800655c:	616d6553 	.word	0x616d6553
 8006560:	726f6870 	.word	0x726f6870
 8006564:	202c7365 	.word	0x202c7365
 8006568:	75716e65 	.word	0x75716e65
 800656c:	6e697565 	.word	0x6e697565
 8006570:	00000067 	.word	0x00000067
 8006574:	616d6553 	.word	0x616d6553
 8006578:	726f6870 	.word	0x726f6870
 800657c:	202c7365 	.word	0x202c7365
 8006580:	656d6974 	.word	0x656d6974
 8006584:	0074756f 	.word	0x0074756f
 8006588:	616d6553 	.word	0x616d6553
 800658c:	726f6870 	.word	0x726f6870
 8006590:	202c7365 	.word	0x202c7365
 8006594:	6d6f7461 	.word	0x6d6f7461
 8006598:	73206369 	.word	0x73206369
 800659c:	616e6769 	.word	0x616e6769
 80065a0:	61772d6c 	.word	0x61772d6c
 80065a4:	00007469 	.word	0x00007469
 80065a8:	616e6942 	.word	0x616e6942
 80065ac:	53207972 	.word	0x53207972
 80065b0:	70616d65 	.word	0x70616d65
 80065b4:	65726f68 	.word	0x65726f68
 80065b8:	66202c73 	.word	0x66202c73
 80065bc:	74636e75 	.word	0x74636e75
 80065c0:	616e6f69 	.word	0x616e6f69
 80065c4:	7974696c 	.word	0x7974696c
 80065c8:	00000000 	.word	0x00000000
 80065cc:	6574754d 	.word	0x6574754d
 80065d0:	2c736578 	.word	0x2c736578
 80065d4:	69727020 	.word	0x69727020
 80065d8:	7469726f 	.word	0x7469726f
 80065dc:	6e652079 	.word	0x6e652079
 80065e0:	75657571 	.word	0x75657571
 80065e4:	20676e69 	.word	0x20676e69
 80065e8:	74736574 	.word	0x74736574
 80065ec:	00000000 	.word	0x00000000
 80065f0:	6574754d 	.word	0x6574754d
 80065f4:	2c736578 	.word	0x2c736578
 80065f8:	69727020 	.word	0x69727020
 80065fc:	7469726f 	.word	0x7469726f
 8006600:	65722079 	.word	0x65722079
 8006604:	6e727574 	.word	0x6e727574
 8006608:	00000000 	.word	0x00000000
 800660c:	6574754d 	.word	0x6574754d
 8006610:	2c736578 	.word	0x2c736578
 8006614:	61747320 	.word	0x61747320
 8006618:	00737574 	.word	0x00737574
 800661c:	646e6f43 	.word	0x646e6f43
 8006620:	2c726156 	.word	0x2c726156
 8006624:	67697320 	.word	0x67697320
 8006628:	206c616e 	.word	0x206c616e
 800662c:	74736574 	.word	0x74736574
 8006630:	00000000 	.word	0x00000000
 8006634:	646e6f43 	.word	0x646e6f43
 8006638:	2c726156 	.word	0x2c726156
 800663c:	6f726220 	.word	0x6f726220
 8006640:	61636461 	.word	0x61636461
 8006644:	74207473 	.word	0x74207473
 8006648:	00747365 	.word	0x00747365
 800664c:	646e6f43 	.word	0x646e6f43
 8006650:	2c726156 	.word	0x2c726156
 8006654:	6f6f6220 	.word	0x6f6f6220
 8006658:	74207473 	.word	0x74207473
 800665c:	00747365 	.word	0x00747365
 8006660:	7373654d 	.word	0x7373654d
 8006664:	73656761 	.word	0x73656761
 8006668:	6f6c202c 	.word	0x6f6c202c
 800666c:	0000706f 	.word	0x0000706f
 8006670:	6c69614d 	.word	0x6c69614d
 8006674:	65786f62 	.word	0x65786f62
 8006678:	71202c73 	.word	0x71202c73
 800667c:	69756575 	.word	0x69756575
 8006680:	6120676e 	.word	0x6120676e
 8006684:	7420646e 	.word	0x7420646e
 8006688:	6f656d69 	.word	0x6f656d69
 800668c:	00737475 	.word	0x00737475
 8006690:	6e657645 	.word	0x6e657645
 8006694:	202c7374 	.word	0x202c7374
 8006698:	69676572 	.word	0x69676572
 800669c:	61727473 	.word	0x61727473
 80066a0:	6e6f6974 	.word	0x6e6f6974
 80066a4:	646e6120 	.word	0x646e6120
 80066a8:	73696420 	.word	0x73696420
 80066ac:	63746170 	.word	0x63746170
 80066b0:	00000068 	.word	0x00000068
 80066b4:	6e657645 	.word	0x6e657645
 80066b8:	202c7374 	.word	0x202c7374
 80066bc:	74696177 	.word	0x74696177
 80066c0:	646e6120 	.word	0x646e6120
 80066c4:	6f726220 	.word	0x6f726220
 80066c8:	61636461 	.word	0x61636461
 80066cc:	00007473 	.word	0x00007473
 80066d0:	6e657645 	.word	0x6e657645
 80066d4:	202c7374 	.word	0x202c7374
 80066d8:	656d6974 	.word	0x656d6974
 80066dc:	7374756f 	.word	0x7374756f
 80066e0:	00000000 	.word	0x00000000
 80066e4:	70616548 	.word	0x70616548
 80066e8:	6c61202c 	.word	0x6c61202c
 80066ec:	61636f6c 	.word	0x61636f6c
 80066f0:	6e6f6974 	.word	0x6e6f6974
 80066f4:	646e6120 	.word	0x646e6120
 80066f8:	61726620 	.word	0x61726620
 80066fc:	6e656d67 	.word	0x6e656d67
 8006700:	69746174 	.word	0x69746174
 8006704:	74206e6f 	.word	0x74206e6f
 8006708:	00747365 	.word	0x00747365
 800670c:	6f6d654d 	.word	0x6f6d654d
 8006710:	50207972 	.word	0x50207972
 8006714:	736c6f6f 	.word	0x736c6f6f
 8006718:	7571202c 	.word	0x7571202c
 800671c:	2f657565 	.word	0x2f657565
 8006720:	75716564 	.word	0x75716564
 8006724:	00657565 	.word	0x00657565
 8006728:	616e7944 	.word	0x616e7944
 800672c:	2063696d 	.word	0x2063696d
 8006730:	73495041 	.word	0x73495041
 8006734:	6874202c 	.word	0x6874202c
 8006738:	64616572 	.word	0x64616572
 800673c:	72632073 	.word	0x72632073
 8006740:	69746165 	.word	0x69746165
 8006744:	66206e6f 	.word	0x66206e6f
 8006748:	206d6f72 	.word	0x206d6f72
 800674c:	70616568 	.word	0x70616568
 8006750:	00000000 	.word	0x00000000
 8006754:	616e7944 	.word	0x616e7944
 8006758:	2063696d 	.word	0x2063696d
 800675c:	73495041 	.word	0x73495041
 8006760:	6874202c 	.word	0x6874202c
 8006764:	64616572 	.word	0x64616572
 8006768:	72632073 	.word	0x72632073
 800676c:	69746165 	.word	0x69746165
 8006770:	66206e6f 	.word	0x66206e6f
 8006774:	206d6f72 	.word	0x206d6f72
 8006778:	6f6d656d 	.word	0x6f6d656d
 800677c:	70207972 	.word	0x70207972
 8006780:	006c6f6f 	.word	0x006c6f6f
 8006784:	616e7944 	.word	0x616e7944
 8006788:	2063696d 	.word	0x2063696d
 800678c:	73495041 	.word	0x73495041
 8006790:	6572202c 	.word	0x6572202c
 8006794:	74736967 	.word	0x74736967
 8006798:	61207972 	.word	0x61207972
 800679c:	7220646e 	.word	0x7220646e
 80067a0:	72656665 	.word	0x72656665
 80067a4:	65636e65 	.word	0x65636e65
 80067a8:	00000073 	.word	0x00000073
 80067ac:	75657551 	.word	0x75657551
 80067b0:	202c7365 	.word	0x202c7365
 80067b4:	75706e69 	.word	0x75706e69
 80067b8:	75712074 	.word	0x75712074
 80067bc:	73657565 	.word	0x73657565
 80067c0:	00000000 	.word	0x00000000
 80067c4:	75657551 	.word	0x75657551
 80067c8:	202c7365 	.word	0x202c7365
 80067cc:	7074756f 	.word	0x7074756f
 80067d0:	71207475 	.word	0x71207475
 80067d4:	65756575 	.word	0x65756575
 80067d8:	00000073 	.word	0x00000073
 80067dc:	74737953 	.word	0x74737953
 80067e0:	202c6d65 	.word	0x202c6d65
 80067e4:	74697263 	.word	0x74697263
 80067e8:	6c616369 	.word	0x6c616369
 80067ec:	6e6f7a20 	.word	0x6e6f7a20
 80067f0:	00007365 	.word	0x00007365
 80067f4:	74737953 	.word	0x74737953
 80067f8:	202c6d65 	.word	0x202c6d65
 80067fc:	65746e69 	.word	0x65746e69
 8006800:	70757272 	.word	0x70757272
 8006804:	68207374 	.word	0x68207374
 8006808:	6c646e61 	.word	0x6c646e61
 800680c:	00676e69 	.word	0x00676e69
 8006810:	74737953 	.word	0x74737953
 8006814:	202c6d65 	.word	0x202c6d65
 8006818:	65746e69 	.word	0x65746e69
 800681c:	74697267 	.word	0x74697267
 8006820:	00000079 	.word	0x00000079
 8006824:	636e6542 	.word	0x636e6542
 8006828:	72616d68 	.word	0x72616d68
 800682c:	6d202c6b 	.word	0x6d202c6b
 8006830:	61737365 	.word	0x61737365
 8006834:	20736567 	.word	0x20736567
 8006838:	00003123 	.word	0x00003123
 800683c:	636e6542 	.word	0x636e6542
 8006840:	72616d68 	.word	0x72616d68
 8006844:	6d202c6b 	.word	0x6d202c6b
 8006848:	61737365 	.word	0x61737365
 800684c:	20736567 	.word	0x20736567
 8006850:	00003223 	.word	0x00003223
 8006854:	636e6542 	.word	0x636e6542
 8006858:	72616d68 	.word	0x72616d68
 800685c:	6d202c6b 	.word	0x6d202c6b
 8006860:	61737365 	.word	0x61737365
 8006864:	20736567 	.word	0x20736567
 8006868:	00003323 	.word	0x00003323
 800686c:	636e6542 	.word	0x636e6542
 8006870:	72616d68 	.word	0x72616d68
 8006874:	63202c6b 	.word	0x63202c6b
 8006878:	65746e6f 	.word	0x65746e6f
 800687c:	73207478 	.word	0x73207478
 8006880:	63746977 	.word	0x63746977
 8006884:	00000068 	.word	0x00000068
 8006888:	636e6542 	.word	0x636e6542
 800688c:	72616d68 	.word	0x72616d68
 8006890:	74202c6b 	.word	0x74202c6b
 8006894:	61657268 	.word	0x61657268
 8006898:	202c7364 	.word	0x202c7364
 800689c:	6c6c7566 	.word	0x6c6c7566
 80068a0:	63796320 	.word	0x63796320
 80068a4:	0000656c 	.word	0x0000656c
 80068a8:	636e6542 	.word	0x636e6542
 80068ac:	72616d68 	.word	0x72616d68
 80068b0:	74202c6b 	.word	0x74202c6b
 80068b4:	61657268 	.word	0x61657268
 80068b8:	202c7364 	.word	0x202c7364
 80068bc:	61657263 	.word	0x61657263
 80068c0:	6f206574 	.word	0x6f206574
 80068c4:	00796c6e 	.word	0x00796c6e
 80068c8:	636e6542 	.word	0x636e6542
 80068cc:	72616d68 	.word	0x72616d68
 80068d0:	6d202c6b 	.word	0x6d202c6b
 80068d4:	20737361 	.word	0x20737361
 80068d8:	63736572 	.word	0x63736572
 80068dc:	75646568 	.word	0x75646568
 80068e0:	202c656c 	.word	0x202c656c
 80068e4:	68742035 	.word	0x68742035
 80068e8:	64616572 	.word	0x64616572
 80068ec:	00000073 	.word	0x00000073
 80068f0:	636e6542 	.word	0x636e6542
 80068f4:	72616d68 	.word	0x72616d68
 80068f8:	72202c6b 	.word	0x72202c6b
 80068fc:	646e756f 	.word	0x646e756f
 8006900:	626f7220 	.word	0x626f7220
 8006904:	63206e69 	.word	0x63206e69
 8006908:	65746e6f 	.word	0x65746e6f
 800690c:	73207478 	.word	0x73207478
 8006910:	63746977 	.word	0x63746977
 8006914:	676e6968 	.word	0x676e6968
 8006918:	00000000 	.word	0x00000000
 800691c:	636e6542 	.word	0x636e6542
 8006920:	72616d68 	.word	0x72616d68
 8006924:	49202c6b 	.word	0x49202c6b
 8006928:	51204f2f 	.word	0x51204f2f
 800692c:	65756575 	.word	0x65756575
 8006930:	68742073 	.word	0x68742073
 8006934:	67756f72 	.word	0x67756f72
 8006938:	74757068 	.word	0x74757068
 800693c:	00000000 	.word	0x00000000
 8006940:	636e6542 	.word	0x636e6542
 8006944:	72616d68 	.word	0x72616d68
 8006948:	76202c6b 	.word	0x76202c6b
 800694c:	75747269 	.word	0x75747269
 8006950:	74206c61 	.word	0x74206c61
 8006954:	72656d69 	.word	0x72656d69
 8006958:	65732073 	.word	0x65732073
 800695c:	65722f74 	.word	0x65722f74
 8006960:	00746573 	.word	0x00746573
 8006964:	636e6542 	.word	0x636e6542
 8006968:	72616d68 	.word	0x72616d68
 800696c:	73202c6b 	.word	0x73202c6b
 8006970:	70616d65 	.word	0x70616d65
 8006974:	65726f68 	.word	0x65726f68
 8006978:	61772073 	.word	0x61772073
 800697c:	732f7469 	.word	0x732f7469
 8006980:	616e6769 	.word	0x616e6769
 8006984:	0000006c 	.word	0x0000006c
 8006988:	636e6542 	.word	0x636e6542
 800698c:	72616d68 	.word	0x72616d68
 8006990:	6d202c6b 	.word	0x6d202c6b
 8006994:	78657475 	.word	0x78657475
 8006998:	6c207365 	.word	0x6c207365
 800699c:	2f6b636f 	.word	0x2f6b636f
 80069a0:	6f6c6e75 	.word	0x6f6c6e75
 80069a4:	00006b63 	.word	0x00006b63
 80069a8:	636e6542 	.word	0x636e6542
 80069ac:	72616d68 	.word	0x72616d68
 80069b0:	52202c6b 	.word	0x52202c6b
 80069b4:	66204d41 	.word	0x66204d41
 80069b8:	70746f6f 	.word	0x70746f6f
 80069bc:	746e6972 	.word	0x746e6972
 80069c0:	00000000 	.word	0x00000000
 80069c4:	6f666e69 	.word	0x6f666e69
 80069c8:	00000000 	.word	0x00000000
 80069cc:	74737973 	.word	0x74737973
 80069d0:	00656d69 	.word	0x00656d69
	...

080069e0 <ram_areas>:
 80069e0:	08006f50 20000f44 20000f44 20000f44     Po..D.. D.. D.. 
 80069f0:	08006f50 20000000 20000000 20000000     Po..... ... ... 
 8006a00:	08006f50 2001c000 2001c000 2001c000     Po..... ... ... 
 8006a10:	08006f50 00000000 00000000 00000000     Po..............
 8006a20:	08006f50 10000000 10000000 10000000     Po..............
 8006a30:	08006f50 40024000 40024000 40024000     Po...@.@.@.@.@.@
 8006a40:	08006f50 00000000 00000000 00000000     Po..............
 8006a50:	08006f50 00000000 00000000 00000000     Po..............

08006a60 <ch_debug>:
 8006a60:	6e69616d 18431600 08440404 1814100c     main..C...D.....
 8006a70:	1e1d1c00 00000000 00000000 00000000     ................

08006a80 <zero_status.lto_priv.190>:
	...

08006a90 <active_status.lto_priv.192>:
	...

08006aa0 <halted_status.lto_priv.191>:
 8006aa0:	00000001 00000000 00000000 00000000     ................

08006ab0 <_stm32_dma_streams>:
 8006ab0:	40026010 40026008 000b0000 40026028     .`.@.`.@....(`.@
 8006ac0:	40026008 000c0106 40026040 40026008     .`.@....@`.@.`.@
 8006ad0:	000d0210 40026058 40026008 000e0316     ....X`.@.`.@....
 8006ae0:	40026070 4002600c 000f0400 40026088     p`.@.`.@.....`.@
 8006af0:	4002600c 00100506 400260a0 4002600c     .`.@.....`.@.`.@
 8006b00:	00110610 400260b8 4002600c 002f0716     .....`.@.`.@../.
 8006b10:	40026410 40026408 00380800 40026428     .d.@.d.@..8.(d.@
 8006b20:	40026408 00390906 40026440 40026408     .d.@..9.@d.@.d.@
 8006b30:	003a0a10 40026458 40026408 003b0b16     ..:.Xd.@.d.@..;.
 8006b40:	40026470 4002640c 003c0c00 40026488     pd.@.d.@..<..d.@
 8006b50:	4002640c 00440d06 400264a0 4002640c     .d.@..D..d.@.d.@
 8006b60:	00450e10 400264b8 4002640c 00460f16     ..E..d.@.d.@..F.

08006b70 <ep0config.lto_priv.160>:
 8006b70:	00000000 080044f1 08004651 08004751     .....D..QF..QG..
 8006b80:	00400040 20000bc0 20000bc0 00000001     @.@.... ... ....
 8006b90:	20000bd4 00000000 00000000 00000000     ... ............

08006ba0 <fsparams.lto_priv.161>:
 8006ba0:	00000080 00000140 00000003 00000000     ....@...........

08006bb0 <pal_default_config>:
 8006bb0:	2aa0aa00 00000000 ffffabff 40010054     ...*........T..@
 8006bc0:	0000ffff 55560000 000aaa00 00082080     ......VU..... ..
 8006bd0:	00000240 ffffffff 55514515 0000ffff     @........EQU....
 8006be0:	04000000 00000040 02208001 00000000     ....@..... .....
 8006bf0:	ffffffff 54451554 0000ffff 60000000     ....T.ET.......`
 8006c00:	00060600 55000100 00000000 ffffffff     .......U........
 8006c10:	00555055 00000fff 00000000 00000000     UPU.............
 8006c20:	00000040 00000000 ffffffff 00000000     @...............
 8006c30:	0000ffff 00000000 00000000 00000000     ................
 8006c40:	00000000 ffffffff 00000000 0000ffff     ................
	...
 8006c60:	ffffffff 00000000 0000ffff 00000000     ................
	...
 8006c7c:	ffffffff 00000000 0000ffff 00000000     ................
	...
 8006c98:	ffffffff 00000000 0000ffff 00000000     ................
	...

08006cb0 <usb_device_descriptor_data.lto_priv.36>:
 8006cb0:	02000112 400000ff f00d0483 02010200     .......@........
 8006cc0:	00000103 00000000 00000000 00000000     ................

08006cd0 <usb_device_descriptor.lto_priv.29>:
 8006cd0:	00000012 08006cb0 00000000 00000000     .....l..........

08006ce0 <usb_configuration_descriptor_data.lto_priv.37>:
 8006ce0:	00200209 c0000101 00040932 00ff0200     .. .....2.......
 8006cf0:	05070000 00400301 81050700 00004003     ......@......@..

08006d00 <usb_configuration_descriptor.lto_priv.30>:
 8006d00:	00000020 08006ce0 00000000 00000000      ....l..........

08006d10 <usb_string0.lto_priv.38>:
 8006d10:	04090304 00000000 00000000 00000000     ................

08006d20 <usb_string1.lto_priv.39>:
 8006d20:	00530326 004d0054 00630069 006f0072     &.S.T.M.i.c.r.o.
 8006d30:	006c0065 00630065 00720074 006e006f     e.l.e.c.t.r.o.n.
 8006d40:	00630069 00000073 00000000 00000000     i.c.s...........

08006d50 <usb_string2.lto_priv.40>:
 8006d50:	00430344 00690068 00690062 0053004f     D.C.h.i.b.i.O.S.
 8006d60:	0052002f 00200054 00690046 0069006c     /.R.T. .F.i.l.i.
 8006d70:	00550070 00420053 00410020 00630063     p.U.S.B. .A.c.c.
 8006d80:	006c0065 00720065 006d006f 00740065     e.l.e.r.o.m.e.t.
 8006d90:	00720065 00000000 00000000 00000000     e.r.............

08006da0 <usb_string3.lto_priv.41>:
 8006da0:	00330308 00330031 00000000 00000000     ..3.1.3.........

08006db0 <usb_strings.lto_priv.31>:
 8006db0:	00000004 08006d10 00000026 08006d20     .....m..&... m..
 8006dc0:	00000044 08006d50 00000008 08006da0     D...Pm.......m..

08006dd0 <ep1config.lto_priv.27>:
 8006dd0:	00000003 00000000 00000000 00000000     ................
 8006de0:	00400040 20000c34 20000c48 00000004     @.@.4.. H.. ....
	...

08006e00 <ep2config.lto_priv.28>:
 8006e00:	00000003 00000000 00000000 00000000     ................
 8006e10:	00000010 20000c5c 00000000 00000001     ....\.. ........
	...

08006e30 <usbcfg>:
 8006e30:	080004c1 08000461 08000521 00000000     ....a...!.......

08006e40 <pwmcfg.lto_priv.2>:
 8006e40:	000186a0 00000080 00000000 00000001     ................
 8006e50:	00000000 00000001 00000000 00000001     ................
 8006e60:	00000000 00000001 00000000 00000000     ................
	...

08006e80 <spi1cfg.lto_priv.0>:
 8006e80:	00000000 40021000 001b0003 00000000     .......@........

08006e90 <extcfg.lto_priv.1>:
 8006e90:	00000041 080006c1 00000000 00000000     A...............
	...
